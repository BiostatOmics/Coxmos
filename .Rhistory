toKeep.zv = NULL
comp_model_lst <- list()
fold_list <- list()
run_list <- list()
eta_model_lst <- NULL
info <- NULL # for sPLS
## CHECK METHOD
if(is.null(eta.list) & is.null(EN.alpha.list) & !method %in% c(pkg.env$plsicox, pkg.env$splsdacox_mixomics, pkg.env$splsdrcox_mixomics, pkg.env$sb.plsicox, pkg.env$mb.splsdrcox, pkg.env$mb.splsdacox)){
stop_quietly("Method must be one of 'PLS-ICOX', 'sPLS-DACOX-MixOmics', 'MB.sPLS-DACOX' or 'sPLS-DRCOX-MixOmics' if 'eta.list' and 'EN.alpha.list' is NULL.")
}else if(!is.null(eta.list) & is.null(EN.alpha.list)  & !method %in% c(pkg.env$splsdrcox, pkg.env$sb.splsdrcox)){
stop_quietly("Method must be 'sPLS-DRCOX' if 'eta.list' is not NULL.")
}else if(!is.null(EN.alpha.list) & !method %in% c(pkg.env$coxEN)){
stop_quietly("Method must be 'coxEN' if 'EN.alpha.list' is not NULL.")
}
pb_text <- "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated remaining time: :eta]"
pb <- progress::progress_bar$new(format = pb_text,
total = total_models,
complete = "=",   # Caracteres de las iteraciones finalizadas
incomplete = "-", # Caracteres de las iteraciones no finalizadas
current = ">",    # Caracter actual
clear = FALSE,    # Si TRUE, borra la barra cuando termine
width = 100)      # Ancho de la barra de progreso
message(paste0("Training all possible models for ", method, "..."))
pb$tick(0)
##################
# COMP-REP-FOLDS #
##################
if(method %in% c(pkg.env$plsicox, pkg.env$splsdacox_mixomics, pkg.env$splsdrcox_mixomics, pkg.env$sb.plsicox, pkg.env$mb.splsdrcox, pkg.env$mb.splsdacox)){
#function to compute all models at the same time - just last component
lst_inputs <- list()
cont = 1
lst_names = NULL
for(i in max.ncomp){
for(r in 1:n_run){
for(f in 1:k_folds){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$comp = i
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(i, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
## Sometimes, when you compute the model with the higher number of dimensions it fail and should be working with one lesser component,
## when you compute the model by iterations it is easy to do, but know the model itself has to compute its better number of components
## if using one fail (use one lesser) !!!! HAVE TO BE IMPLEMENTED !!!!
if(PARALLEL){
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
if(method==pkg.env$plsicox){
lst_all_models <- furrr::future_map(lst_inputs, ~plsicox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
MIN_EPV = MIN_EPV, returnData = F, verbose = verbose), .options = furrr_options(seed = 123))
}else if(method==pkg.env$splsdacox_mixomics){
lst_all_models <- furrr::future_map(lst_inputs, ~splsdacox_mixOmics(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD,
MIN_EPV = MIN_EPV, returnData = F, verbose = verbose), .options = furrr_options(seed = 123))
}else if(method==pkg.env$splsdrcox_mixomics){
lst_all_models <- furrr::future_map(lst_inputs, ~splsdrcox_mixOmics(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD,
MIN_EPV = MIN_EPV, returnData = F, verbose = verbose), .options = furrr_options(seed = 123))
}else if(method==pkg.env$sb.plsicox){
lst_all_models <- furrr::future_map(lst_inputs, ~sb.plsicox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}else if(method==pkg.env$mb.splsdacox){
lst_all_models <- furrr::future_map(lst_inputs, ~mb.splsdacox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, MIN_AUC_INCREASE = MIN_AUC_INCREASE,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant, max.iter = max.iter,
MIN_EPV = MIN_EPV, returnData = F, verbose = verbose), .options = furrr_options(seed = 123))
}else if(method==pkg.env$mb.splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~mb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, MIN_AUC_INCREASE = MIN_AUC_INCREASE,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
MIN_EPV = MIN_EPV, returnData = F, verbose = verbose), .options = furrr_options(seed = 123))
}
future::plan("sequential")
}else{
if(method==pkg.env$plsicox){
lst_all_models <- purrr::map(lst_inputs, ~plsicox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
MIN_EPV = MIN_EPV, remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
returnData = F))
}else if(method==pkg.env$splsdacox_mixomics){
lst_all_models <- purrr::map(lst_inputs, ~splsdacox_mixOmics(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
MIN_EPV = MIN_EPV, remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD,
returnData = F))
}else if(method==pkg.env$splsdrcox_mixomics){
lst_all_models <- purrr::map(lst_inputs, ~splsdrcox_mixOmics(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD,
MIN_EPV = MIN_EPV, returnData = F))
}else if(method==pkg.env$sb.plsicox){
lst_all_models <- purrr::map(lst_inputs, ~sb.plsicox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}else if(method==pkg.env$mb.splsdacox){
lst_all_models <- purrr::map(lst_inputs, ~mb.splsdacox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, MIN_AUC_INCREASE = MIN_AUC_INCREASE,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant, max.iter = max.iter,
MIN_EPV = MIN_EPV, returnData = F, verbose = F))
}else if(method==pkg.env$mb.splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~mb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, MIN_AUC_INCREASE = MIN_AUC_INCREASE,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
MIN_EPV = MIN_EPV, returnData = F))
}
rm(lst_inputs)
## We need to return a list of lists: COMP->REP->FOLDS
comp_model_lst <- list()
for(c in max.ncomp){
run_model_lst <- list()
for(r in 1:n_run){
fold_model_lst <- list()
for(f in 1:k_folds){
name <- paste0(c, "_", r, "_", f)
fold_model_lst[[f]] = lst_all_models[[name]]
}
names(fold_model_lst) <- paste0("fold_",1:k_folds)
run_model_lst[[r]] <- fold_model_lst
}
names(run_model_lst) <- paste0("run_",1:n_run)
comp_model_lst[[c]] <- run_model_lst
}
names(comp_model_lst) <- paste0("comp_",1:max.ncomp)
## We need to fill models from 1:max.ncomp (it uses max.ncomp to fill the others, if it is NULL, method fail!!!)
for(comp in 1:(max.ncomp-1)){
run_model_lst <- list()
for(r in 1:n_run){
fold_model_lst <- list()
for(f in 1:k_folds){
if(method %in% c(pkg.env$sb.plsicox, pkg.env$mb.splsdrcox, pkg.env$mb.splsdacox)){
fold_model <- getSubModel.mb(model = comp_model_lst[[max.ncomp]][[r]][[f]], comp = comp, remove_non_significant = remove_non_significant)
}else{
fold_model <- getSubModel(model = comp_model_lst[[max.ncomp]][[r]][[f]], comp = comp, remove_non_significant = remove_non_significant)
}
fold_model_lst[[f]] <- fold_model
}
names(fold_model_lst) <- paste0("fold_",1:k_folds)
run_model_lst[[r]] <- fold_model_lst
}
names(run_model_lst) <- paste0("run_",1:n_run)
comp_model_lst[[comp]] <- run_model_lst
}
return(comp_model_lst)
}
method %in% c(pkg.env$coxEN)
#function to compute all models at the same time
lst_inputs <- list()
lst_names = NULL
cont = 1
for(i in 1:length(EN.alpha.list)){
for(r in 1:n_run){
for(f in 1:k_folds){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$alpha_index = i
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(i, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
if(PARALLEL){
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
if(method==pkg.env$coxEN){
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F), .options = furrr_options(seed = 123))
#test with for:
# for(i in lst_inputs){
#   coxEN(X = data.matrix(lst_X_train[[lst_inputs[[1]]$run]][[lst_inputs[[1]]$fold]]),
#         Y = data.matrix(lst_Y_train[[lst_inputs[[1]]$run]][[lst_inputs[[1]]$fold]]),
#         EN.alpha = EN.alpha.list[[lst_inputs[[1]]$alpha_index]],
#         max.variables = max.variables,
#         x.center = x.center, x.scale = x.scale,
#         y.center = y.center, y.scale = y.scale,
#         remove_non_significant = remove_non_significant,
#         remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
#         alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
#         returnData = F)
# }
}
future::plan("sequential")
}else{
if(method==pkg.env$coxEN){
lst_all_models <- purrr::map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F))
}
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
method==pkg.env$coxEN
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F), .options = furrr_options(seed = 123))
coxen_model <- coxEN(X = X_train, Y = Y_train,
EN.alpha = 0, #cv.coxen_res$opt.EN.alpha
max.variables = 9, #cv.coxen_res$opt.nvar
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 5, returnData = T, verbose = F)
coxen_model
lst_all_models <- purrr::map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F))
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
library(RColorConesa)
#theme_set(theme_colorConesa()) #under development
# load Tasic dataset
data("X_small_data_E.MTAB.386")
data("Y_small_data_E.MTAB.386")
X <- X_small_data_E.MTAB.386
Y <- Y_small_data_E.MTAB.386
rm(X_small_data_E.MTAB.386, Y_small_data_E.MTAB.386)
