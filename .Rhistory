}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}
t2 <- Sys.time()
t2-t1
#function to compute all models at the same time
lst_inputs <- list()
cont = 1
lst_names = NULL
for(c in max.ncomp){ #computing all components it is the same as computing by iterations
for(e in 1:length(eta.list)){
for(r in 1:n_run){
for(f in 4){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$comp <- c
lst_inputs[[cont]]$eta_index <- e
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(c, "_", e, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
t1 <- Sys.time()
if(PARALLEL){
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
if(method==pkg.env$splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}
future::plan("sequential")
}else{
if(method==pkg.env$splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}
t2 <- Sys.time()
t2-t1
k_folds
#function to compute all models at the same time
lst_inputs <- list()
cont = 1
lst_names = NULL
for(c in max.ncomp){ #computing all components it is the same as computing by iterations
for(e in 1:length(eta.list)){
for(r in 1:n_run){
for(f in 5){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$comp <- c
lst_inputs[[cont]]$eta_index <- e
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(c, "_", e, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
t1 <- Sys.time()
if(PARALLEL){
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
if(method==pkg.env$splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}
future::plan("sequential")
}else{
if(method==pkg.env$splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}
t2 <- Sys.time()
t2-t1
#function to compute all models at the same time
lst_inputs <- list()
cont = 1
lst_names = NULL
for(c in max.ncomp){ #computing all components it is the same as computing by iterations
for(e in 1:length(eta.list)){
for(r in 1:n_run){
for(f in 6){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$comp <- c
lst_inputs[[cont]]$eta_index <- e
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(c, "_", e, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
t1 <- Sys.time()
if(PARALLEL){
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
if(method==pkg.env$splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}
future::plan("sequential")
}else{
if(method==pkg.env$splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}
t2 <- Sys.time()
t2-t1
#function to compute all models at the same time
lst_inputs <- list()
cont = 1
lst_names = NULL
for(c in max.ncomp){ #computing all components it is the same as computing by iterations
for(e in 1:length(eta.list)){
for(r in 1:n_run){
for(f in 7){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$comp <- c
lst_inputs[[cont]]$eta_index <- e
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(c, "_", e, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
t1 <- Sys.time()
if(PARALLEL){
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
if(method==pkg.env$splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}
future::plan("sequential")
}else{
if(method==pkg.env$splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}
t2 <- Sys.time()
t2-t1
lst_inputs
lst_inputs <- list()
cont = 1
lst_names = NULL
for(c in max.ncomp){ #computing all components it is the same as computing by iterations
for(e in 1:length(eta.list)){
for(r in 1:n_run){
for(f in 8){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$comp <- c
lst_inputs[[cont]]$eta_index <- e
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(c, "_", e, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
t1 <- Sys.time()
if(PARALLEL){
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
if(method==pkg.env$splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}
future::plan("sequential")
}else{
if(method==pkg.env$splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}
t2 <- Sys.time()
t2-t1
#function to compute all models at the same time
lst_inputs <- list()
cont = 1
lst_names = NULL
for(c in max.ncomp){ #computing all components it is the same as computing by iterations
for(e in 1:length(eta.list)){
for(r in 1:n_run){
for(f in 9){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$comp <- c
lst_inputs[[cont]]$eta_index <- e
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(c, "_", e, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
t1 <- Sys.time()
if(PARALLEL){
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
if(method==pkg.env$splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}
future::plan("sequential")
}else{
if(method==pkg.env$splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}
t2 <- Sys.time()
t2-t1
#function to compute all models at the same time
lst_inputs <- list()
cont = 1
lst_names = NULL
for(c in max.ncomp){ #computing all components it is the same as computing by iterations
for(e in 1:length(eta.list)){
for(r in 1:n_run){
for(f in 10){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$comp <- c
lst_inputs[[cont]]$eta_index <- e
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(c, "_", e, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
t1 <- Sys.time()
if(PARALLEL){
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
if(method==pkg.env$splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}
future::plan("sequential")
}else{
if(method==pkg.env$splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~splsdrcox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}else if(method==pkg.env$sb.splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~sb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, eta = eta.list[[.$eta_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
verbose = verbose,
MIN_EPV = MIN_EPV, returnData = F))
}
t2 <- Sys.time()
t2-t1
devtools::load_all(".")
