ggp_density
ggp_density <- ggplot(dd, aes(fill=Category, x=Time, y=Values)) +
#geom_bar(position="stack", stat="identity") +
geom_bar(stat = "identity") +
ylab("Number of patients") +
xlim(c(min, max)) +
scale_x_continuous(breaks = breaks) +
scale_y_continuous(n.breaks = 10) +
guides(fill=guide_legend(title="Event type"), color = "none")
ggp_density
ggp_density <- ggplot(dd, aes(fill=Category, x=Time, y=Values)) +
#geom_bar(position="stack", stat="identity") +
geom_bar(stat = "identity") +
ylab("Number of patients") +
xlim(c(min, max)) +
scale_y_continuous(n.breaks = 10) +
guides(fill=guide_legend(title="Event type"), color = "none")
ggp_density
ggp_density <- ggplot(dd, aes(fill=Category, x=Time, y=Values)) +
#geom_bar(position="stack", stat="identity") +
geom_bar(stat = "identity") +
ylab("Number of patients") +
xlim(c(min, max)) +
scale_x_continuous(breaks = breaks) +
scale_y_continuous(n.breaks = 10) +
guides(fill=guide_legend(title="Event type"), color = "none")
ggp_density <- ggplot(dd, aes(fill=Category, x=Time, y=Values)) +
#geom_bar(position="stack", stat="identity") +
geom_bar(stat = "identity") +
ylab("Number of patients") +
scale_x_continuous(breaks = breaks) +
scale_y_continuous(n.breaks = 10) +
guides(fill=guide_legend(title="Event type"), color = "none")
ggp_density
breaks
ggp_density <- ggplot(dd, aes(fill=Category, x=Time, y=Values)) +
#geom_bar(position="stack", stat="identity") +
geom_bar(stat = "identity") +
ylab("Number of patients") +
scale_x_continuous(n.breaks = breaks) +
scale_y_continuous(n.breaks = 10) +
guides(fill=guide_legend(title="Event type"), color = "none")
ggp_density
bsize
bsize = (max-min) / max.breaks
bsize
max.breaks
bsize = (max-min) / roundTo
bsize
max.breaks = 20
n.b = (max-min) / roundTo
if(n.b>max.breaks){
n.b = max.breaks
}
bsize = (max-min) / n.b
bsize
breaks = seq(min, max, by=bsize)
breaks
ggp_density <- ggplot(dd, aes(fill=Category, x=Time, y=Values)) +
#geom_bar(position="stack", stat="identity") +
geom_bar(stat = "identity") +
ylab("Number of patients") +
scale_x_continuous(breaks = breaks) +
scale_y_continuous(n.breaks = 10) +
guides(fill=guide_legend(title="Event type"), color = "none")
ggp_density
breaks = seq(min, max+bsize, by=bsize)
breaks
ggp_density <- ggplot(dd, aes(fill=Category, x=Time, y=Values)) +
#geom_bar(position="stack", stat="identity") +
geom_bar(stat = "identity") +
ylab("Number of patients") +
scale_x_continuous(breaks = breaks) +
scale_y_continuous(n.breaks = 10) +
guides(fill=guide_legend(title="Event type"), color = "none")
ggp_density
roundTo
Y$time
length(unique(Y$time))
time_aux <- round2any(as.numeric(Y$time), roundTo)
length(unique(time_aux))>max.breaks
time_aux <- round2any(as.numeric(Y$time), roundTo)
while(length(unique(time_aux))>max.breaks){
roundTo = roundTo + 0.05
time_aux <- round2any(as.numeric(Y$time), roundTo)
}
roundTo
Y$time <- round2any(as.numeric(Y$time), roundTo)
Y$time
vt=NULL
vcategory=NULL
vvalues=NULL
for(t in sort(unique(Y$time))){
vt <- c(vt, as.numeric(t), as.numeric(t))
vcategory <- c(vcategory, categories)
vvalues<- c(vvalues, sum(Y[Y$time==t, "event"]==T), sum(Y[Y$time==t, "event"]==F))
}
dd <- data.frame(Time=vt, Category=vcategory, Values=vvalues)
min <- 0
if(round){
max <- round2any(max(dd$Time), accuracy = 1, f = ceiling)
}else{
max <- ceiling(max(dd$Time))+1
}
bsize
roundTo
breaks = seq(min, max, by=roundTo)
ggp_density <- ggplot(dd, aes(fill=Category, x=Time, y=Values)) +
#geom_bar(position="stack", stat="identity") +
geom_bar(stat = "identity") +
ylab("Number of patients") +
scale_x_continuous(breaks = breaks) +
scale_y_continuous(n.breaks = 10) +
guides(fill=guide_legend(title="Event type"), color = "none")
ggp_density
cut(0,8,ggp_density)
cut(0,8,0.35)
cut(x = 0:8,0.35)
?cut
Y$time
min(Y$time)
min(Y$time),max(Y$time)
c(min(Y$time),max(Y$time))
x.names <- cut(x = c(min(Y$time),max(Y$time)), breaks = roundTo)
breaks = seq(min, max, by=roundTo)
breaks
length(breaks)
roundTo=0.25
time_aux <- round2any(as.numeric(Y$time), roundTo)
length(unique(time_aux))
max.breaks
length(unique(time_aux))
Y <- Y_small_data_E.MTAB.386
#DFCALLS
Category <- Time <- Values <- NULL
if(class(Y[,"event"])!="logical"){
message("Warning: Y matrix must has event column as TRUE, FALSE. as.logical() function has been used.")
Y$event <- as.logical(Y$event)
}
time_aux <- round2any(as.numeric(Y$time), roundTo)
time_aux
length(unique(time_aux))
roundTo = roundTo + 0.05
time_aux <- round2any(as.numeric(Y$time), roundTo)
length(unique(time_aux))
roundTo = roundTo + 0.05
time_aux <- round2any(as.numeric(Y$time), roundTo)
length(unique(time_aux))
roundTo = roundTo + 0.05
time_aux <- round2any(as.numeric(Y$time), roundTo)
length(unique(time_aux))
roundTo
time_aux
roundTo
Y$time <- round2any(as.numeric(Y$time), roundTo)
breaks = seq(min, max, by=roundTo)
breaks
length(breaks)
x.names <- cut(x = c(min(Y$time),max(Y$time)), breaks = breaks)
x.names
levels(x.names)
vt=NULL
vcategory=NULL
vvalues=NULL
for(t in sort(unique(Y$time))){
vt <- c(vt, as.numeric(t), as.numeric(t))
vcategory <- c(vcategory, categories)
vvalues<- c(vvalues, sum(Y[Y$time==t, "event"]==T), sum(Y[Y$time==t, "event"]==F))
}
dd <- data.frame(Time=vt, Category=vcategory, Values=vvalues)
min <- 0
if(round){
max <- round2any(max(dd$Time), accuracy = 1, f = ceiling)
}else{
max <- ceiling(max(dd$Time))+1
}
ggp_density <- ggplot(dd, aes(fill=Category, x=Time, y=Values)) +
#geom_bar(position="stack", stat="identity") +
geom_bar(stat = "identity") +
ylab("Number of patients") +
scale_y_continuous(n.breaks = 10) +
guides(fill=guide_legend(title="Event type"), color = "none")
if(round){
ggp_density <- ggp_density +
scale_x_continuous(breaks = breaks) +
scale_x_discrete(limits=levels(x.names))
}
if(requireNamespace("RColorConesa", quietly = TRUE)){
ggp_density <- ggp_density + RColorConesa::scale_fill_conesa()
}
ggp_density
breaks
ggp_density <- ggp_density +
scale_x_continuous(labels = levels(x.names), breaks = breaks)
breaks
length(breaks)
length(levels(x.names))
levels(x.names)
Y <- Y_small_data_E.MTAB.386
#DFCALLS
Category <- Time <- Values <- x.names <- breaks<- NULL
if(class(Y[,"event"])!="logical"){
message("Warning: Y matrix must has event column as TRUE, FALSE. as.logical() function has been used.")
Y$event <- as.logical(Y$event)
}
time_aux <- round2any(as.numeric(Y$time), roundTo)
while(length(unique(time_aux))>max.breaks){
roundTo = roundTo + 0.05
time_aux <- round2any(as.numeric(Y$time), roundTo)
}
Y$time <- round2any(as.numeric(Y$time), roundTo)
breaks = seq(min(Y$time), max(Y$time), by=roundTo)
x.names <- cut(x = c(min(Y$time),max(Y$time)), breaks = breaks)
length(breaks)
length(x.names)
x.names
length(levels(x.names))
max(Y$time)
x.names <- cut(x = Y$time, breaks = breaks)
x.names
Y <- Y_small_data_E.MTAB.386
time_aux <- round2any(as.numeric(Y$time), roundTo)
while(length(unique(time_aux))>max.breaks){
roundTo = roundTo + 0.05
time_aux <- round2any(as.numeric(Y$time), roundTo)
}
breaks = seq(min(Y$time), max(Y$time), by=roundTo)
x.names <- cut(x = Y$time, breaks = breaks)
x.names
breaks
roundTo
breaks
breaks = round2any(breaks, 0.1)
breaks
x.names <- cut(x = Y$time, breaks = breaks)
x.names
breaks
roundTo
breaks = c(breaks,max(breaks)+roundTo)
breaks
x.names <- cut(x = Y$time, breaks = breaks)
x.names
x.names <- droplevels(x.names)
x.names
Y$time_g <- x.names
Y
sort(unique(Y$time))
vt=NULL
vcategory=NULL
vvalues=NULL
for(t in levels(x.names)){
vt <- c(vt, t, t)
vcategory <- c(vcategory, categories)
vvalues<- c(vvalues, sum(Y[Y$time==t, "event"]==T), sum(Y[Y$time==t, "event"]==F))
}
dd <- data.frame(Time=vt, Category=vcategory, Values=vvalues)
dd
vt=NULL
vcategory=NULL
vvalues=NULL
for(t in levels(x.names)){
vt <- c(vt, t, t)
vcategory <- c(vcategory, categories)
vvalues<- c(vvalues, sum(Y[Y$time_g==t, "event"]==T), sum(Y[Y$time_g==t, "event"]==F))
}
dd <- data.frame(Time=vt, Category=vcategory, Values=vvalues)
dd
ggp_density <- ggplot(dd, aes(fill=Category, x=Time, y=Values)) +
#geom_bar(position="stack", stat="identity") +
geom_bar(stat = "identity") +
ylab("Number of patients") +
scale_y_continuous(n.breaks = 10) +
guides(fill=guide_legend(title="Event type"), color = "none")
ggp_density
Y$time
Y$time[1] = 0
Y$time
breaks = seq(min(Y$time), max(Y$time), by=roundTo)
breaks = round2any(breaks, 0.1)
breaks = c(breaks,max(breaks)+roundTo)
x.names <- cut(x = Y$time, breaks = breaks)
x.names <- droplevels(x.names)
Y$time_g <- x.names
Y$time_g
x.names
levels(x.names)[1]
levels(x.names)[1] <- gsub("(", "[",levels(x.names)[1])
gsub("(", "[",levels(x.names)[1])
levels(x.names)[1]
?gsub
gsub("(", "[",levels(x.names)[1], fixed = TRUE)
levels(x.names)[1] <- gsub("(", "[",levels(x.names)[1], fixed = TRUE)
x.names
if(any(is.na(x.names))){
x.names[is.na(x.names)] <- levels(x.names)[1]
}
x.names
?cut
x.names <- cut(x = Y$time, breaks = breaks, include.lowest = T)
x.names
Y$time_g <- x.names
Y$time_g
vt=NULL
vcategory=NULL
vvalues=NULL
for(t in levels(x.names)){
vt <- c(vt, t, t)
vcategory <- c(vcategory, categories)
vvalues<- c(vvalues, sum(Y[Y$time_g==t, "event"]==T), sum(Y[Y$time_g==t, "event"]==F))
}
dd <- data.frame(Time=vt, Category=vcategory, Values=vvalues)
ggp_density <- ggplot(dd, aes(fill=Category, x=Time, y=Values)) +
#geom_bar(position="stack", stat="identity") +
geom_bar(stat = "identity") +
ylab("Number of patients") +
scale_y_continuous(n.breaks = 10) +
guides(fill=guide_legend(title="Event type"), color = "none")
ggp_density
dd
dd$Time
dd$Time <- as.factor(dd)
dd$Time <- as.factor(dd$Time)
dd$Time
dd$Time <- as.factor(dd$Time, levels = levels(x.names))
levels(x.names)
dd <- data.frame(Time=vt, Category=vcategory, Values=vvalues)
dd$Time <- as.factor(dd$Time, levels = levels(x.names))
dd$Time <- factor(dd$Time, levels = levels(x.names))
dd$Time
ggp_density <- ggplot(dd, aes(fill=Category, x=Time, y=Values)) +
#geom_bar(position="stack", stat="identity") +
geom_bar(stat = "identity") +
ylab("Number of patients") +
scale_y_continuous(n.breaks = 10) +
guides(fill=guide_legend(title="Event type"), color = "none")
ggp_density
if(requireNamespace("RColorConesa", quietly = TRUE)){
ggp_density <- ggp_density + RColorConesa::scale_fill_conesa()
}
ggp_density
vcategory
categories
Y <- Y_small_data_E.MTAB.386
#DFCALLS
Category <- Time <- Values <- x.names <- breaks<- NULL
if(class(Y[,"event"])!="logical"){
message("Warning: Y matrix must has event column as TRUE, FALSE. as.logical() function has been used.")
Y$event <- as.logical(Y$event)
}
round
round = F
vt=NULL
vcategory=NULL
vvalues=NULL
t
levels(x.names)
dd
dd <- data.frame(Time=vt, Category=vcategory, Values=vvalues)
dd
roundTo
roundTo = 1
time_aux <- round2any(as.numeric(Y$time), roundTo)
time_aux
Y$time
load_all()
Y <- Y_small_data_E.MTAB.386
ggp_density.event <- plot_events(Y = Y, roundTo = 0.25, categories = c("Censored","Death")) #name for F and T
ggp_density.event
Y
Y[Y$time<0.4,]
load_all()
ggp_density.event <- plot_events(Y = Y, roundTo = 0.25, categories = c("Censored","Death")) #name for F and T
ggp_density.event$plot
ggp_density.event$df
load_all()
check()
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
# load HDcox
library(HDcox)
library(RColorConesa)
#theme_set(theme_colorConesa()) #under development
# load Tasic dataset
data("X_small_data_E.MTAB.386")
data("Y_small_data_E.MTAB.386")
X <- X_small_data_E.MTAB.386
Y <- Y_small_data_E.MTAB.386
rm(X_small_data_E.MTAB.386, Y_small_data_E.MTAB.386)
knitr::kable(X[1:5,1:5])
knitr::kable(Y[1:5,])
ggp_density.event <- plot_events(Y = Y, roundTo = 0.25, categories = c("Censored","Death")) #name for F and T
ggp_density.event$plot
set.seed(123)
index_train <- caret::createDataPartition(Y$event,
p = .7, #70% train
list = FALSE,
times = 1)
X_train <- X[index_train,] #1103
Y_train <- Y[index_train,]
X_test <- X[-index_train,] #472
Y_test <- Y[-index_train,]
EPV <- sum(Y_train$event==1) / ncol(X_train)
EPV
plsicox_model <- plsicox(X = X_train, Y = Y_train,
n.comp = 3, #n.comp = cv.plsicox_res$opt.comp
x.center = T, x.scale = F)
plsicox_model
splsdrcox_model <- splsdrcox(X = X_train, Y = Y_train,
n.comp = 2, eta = 0.25, #n.comp = cv.splsdrcox_res$opt.comp, eta = cv.splsdrcox_res$opt.eta
x.center = T, x.scale = F)
splsdrcox_model
plsdacox_model <- plsdacox_mixOmics(X = X_train, Y = Y_train,
n.comp = 3, #cv.plsdacox_res$opt.comp
x.center = T, x.scale = F)
plsdacox_model
lst_models <- list("PLS-ICOX" = plsicox_model,
"SPLS-DRCOX" = splsdrcox_model,
"PLS-DACOX" = plsdacox_model)
eval_results <- eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
pred.method = "cenROC",
pred.attr = "mean",
times = seq(1,4,0.5), max_time_points = 15,
PARALLEL = T)
# lst_evaluators <- c(cenROC = "cenROC",
#                     risksetROC = "risksetROC")
#
# eval_results <- purrr::map(lst_evaluators, ~eval_models4.0(lst_models = lst_models,
#                                                            X_test = X_test, Y_test = Y_test,
#                                                            pred.method = .,
#                                                            pred.attr = "mean",
#                                                            times = seq(1,4,0.5), max_time_points = 15,
#                                                            PARALLEL = T))
eval_results
#eval_results$cenROC
lst_eval_results <- plot_evaluation(eval_results)
#lst_eval_results <- plot_evaluation.list(eval_results)
lst_eval_results$lst_plots$lineplot.mean
lst_eval_results$lst_plot_comparisons$t.test
# lst_eval_results$cenROC$lst_plots$lineplot.mean
# lst_eval_results$cenROC$lst_plot_comparisons$t.test
lst_models_time <- list(plsicox_model,
splsdrcox_model,
plsdacox_model,
eval_results)
ggp_time <- plot_time.models(lst_models_time)
ggp_time
lst_forest_plot <- purrr::map(lst_models, ~survminer::ggforest(.$survival_model$fit,
data = .$survival_model$fit$model))
lst_forest_plot$`SPLS-DRCOX`
density.plots.lp <- plot_cox.event.list(lst_models, type = "lp")
density.plots.lp$`SPLS-DRCOX`$plot.density
density.plots.lp$`SPLS-DRCOX`$plot.histogram
lst_ph_ggplot <- plot_proportionalHazard.list(lst_models)
lst_ph_ggplot$`SPLS-DRCOX`
ggp.simulated_beta <- plot_pseudobeta.list(lst_models = lst_models,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, top = 20)
ggp.simulated_beta$`SPLS-DRCOX`$plot
LST_KM_RES_LP <- getAutoKM.list(type = "LP",
lst_models = lst_models,
comp = 1:4,
top = 10,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05)
LST_KM_RES_LP$`SPLS-DRCOX`$LST_PLOTS$LP
LST_KM_RES_COMP <- getAutoKM.list(type = "COMP",
lst_models = lst_models,
comp = 1:4,
top = 10,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05)
LST_KM_RES_COMP$`SPLS-DRCOX`$LST_PLOTS$comp_1
LST_KM_RES_COMP$`SPLS-DRCOX`$LST_PLOTS$comp_2
LST_KM_RES_VAR <- getAutoKM.list(type = "VAR",
lst_models = lst_models,
comp = 1:4,
top = 10,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05)
LST_KM_RES_VAR$`SPLS-DRCOX`$LST_PLOTS$POSTN
LST_KM_RES_VAR$`SPLS-DRCOX`$LST_PLOTS$SIRT5
new_pat <- X_test[1,,drop=F]
knitr::kable(Y_test[rownames(new_pat),])
ggp.simulated_beta_newPat <- plot_pseudobeta.newPatient.list(lst_models = lst_models,
new_pat = new_pat,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, show.betas = T, top = 20)
ggp.simulated_beta_newPat$`SPLS-DRCOX`$plot
pat_density <- plot_patient.eventDensity(patient = new_pat, time = NULL, model = lst_models$`SPLS-DRCOX`)
pat_density
pat_histogram <- plot_patient.eventHistogram(patient = new_pat, time = NULL, model = lst_models$`SPLS-DRCOX`)
pat_histogram
?plot_patient.eventDensity
pat_density <- plot_patient.eventDensity(patient = new_pat, time = NULL, model = lst_models$`SPLS-DRCOX`, type = "lp")
pat_density
?plot_divergent.biplot
