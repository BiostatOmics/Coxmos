MIN_EPV = 5, returnData = T, verbose = F)
plsicox_model <- plsicox(X = X_train, Y = Y_train,
n.comp = 2, #n.comp = cv.plsicox_res$opt.comp
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
tol = 500,
MIN_EPV = 5, returnData = T, verbose = F)
plsicox_model
plsicox_model <- plsicox(X = X_train, Y = Y_train,
n.comp = 2, #n.comp = cv.plsicox_res$opt.comp
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
tol = 500,
MIN_EPV = 5, returnData = T, verbose = F)
plsicox_model
plsicox_model <- plsicox(X = X_train, Y = Y_train,
n.comp = 2, #n.comp = cv.plsicox_res$opt.comp
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
tol = 1000,
MIN_EPV = 5, returnData = T, verbose = F)
plsicox_model
```{r}
plsicox_model <- plsicox(X = X_train, Y = Y_train,
n.comp = 2, #n.comp = cv.plsicox_res$opt.comp
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
tol = 1000,
MIN_EPV = 5, returnData = T, verbose = F)
coxph(formula = X_train$PLCG2 ~ event, data = cbind(X_train, Y_train))
coxph(formula = Surv(X_train$PLCG2 ~ event), data = cbind(X_train, Y_train))
Y_train$time
cox(X = X_train$KDM5C, Y = Y_train)
cox(X = X_train[,"KDM5C"], Y = Y_train)
head(Y_train)
cox(X = X_train[,"KDM5C"], Y = Y_train)
cox(X = X_train[,"KDM5C",drop=F], Y = Y_train)
X = X_train
Y = Y_train
n.comp = 2
x.center = T
x.scale = F
y.scale = F
y.center = F
remove_near_zero_variance = T
tol = 1000
t1 <- Sys.time()
#### Original data
X_original <- X
Y_original <- Y
time <- Y[,"time"]
event <- Y[,"event"]
#### REQUIREMENTS
lst_check <- checkXY.class(X, Y, verbose = verbose)
X <- lst_check$X
Y <- lst_check$Y
checkY.colnames(Y)
#### ZERO VARIANCE - ALWAYS
lst_dnz <- deleteZeroOrNearZeroVariance(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
#### SCALING
lst_scale <- XY.scale(X, Y, x.center, x.scale, y.center, y.scale)
Xh <- lst_scale$Xh
Yh <- lst_scale$Yh
xmeans <- lst_scale$xmeans
xsds <- lst_scale$xsds
ymeans <- lst_scale$ymeans
ysds <- lst_scale$ysds
X_norm <- Xh
####MAX PREDICTORS
n.comp <- check.maxPredictors(X, Y, MIN_EPV, n.comp)
#### INITIALISING VARIABLES
Ts <- NULL
W <- NULL
W_norm <- NULL
P <- NULL
E <- list(Xh)
XXNA <- is.na(Xh) #T is NA
YNA <- is.na(Yh) #T is NA
#Update NAs by 0s
Xh[XXNA] <- 0
stopped = F
for(h in 1:n.comp){
#residuals^2
residuals <- sqrt(colSums(Xh^2, na.rm=TRUE))
#break iteration
if(any(residuals<tol)){
bad_var <- paste0(names(residuals)[residuals < tol], collapse = ", ")
message(paste0(paste0("Individual COX model cannot be computed for variables (", bad_var, "). Stopped at component ", h, ".")))
stopped = T
break
}
#### ### ### ### ### ### ### ### ### ### ### #
#                                            #
#     Weight computation for each model      #
#                                            #
#### ### ### ### ### ### ### ### ### ### ### #
#### ### ### ##
##  PLS-COX  ##
#### ### ### ##
#2. wh <- individual cox regression vector
Xh[XXNA] <- NA
Xh[XXNA] <- 0
#Sometimes, fit can not be compute by NA at cox calculus, we cannot avoid printing the NAs matrix... !!!!
wh <- tryCatch(
# Specifying expression
expr = {
as.matrix(apply(Xh, 2, function(x){
eps = 1e-14
control <- survival::coxph.control(eps = eps, toler.chol = .Machine$double.eps^0.90,
iter.max = 220, toler.inf = sqrt(eps), outer.max = 100, timefix = TRUE)
fit <- survival::coxph(survival::Surv(time = time, event = event, type = "right") ~ ., as.data.frame(cbind(Ts,x)), control = control)
fit$coefficients["x"] #cause variable of study is called 'x' and we extract new coefficient taking into account components already computed
}))
},
# Specifying error message
error = function(e){
message(paste0("plsicox: ", e))
invisible(gc())
return(NA)
}
)
if(all(is.na(wh))){
message(paste0("Individual COX models cannot be computed for each variable. Stopped at component ", h, "."))
stopped = T
break
}
if(any(is.na(wh))){
message(paste0(paste0("Individual COX model cannot be computed for variables (", paste0(rownames(wh)[is.na(wh)], collapse = ", ") ,")."), " Stopped at component ", h, "."))
stopped = T
break
}
# if(h!=1){
#   wh <- wh[h,]
# }
wh <- wh[,1]
#3. wh <- wh / ||wh||
wh_norm <- wh/as.vector(sqrt(sum(wh^2))) #as.vector(sqrt(t(wh) %*% wh))
#4. t = Xh wh / wh'wh
#4. t = Xh wh_norm (solo si wh ya normalizado)
#normalization for NAs
Xh[XXNA] <- 0
th <- (Xh %*% wh_norm)/((!XXNA) %*% wh_norm^2)
#th <- t(lm(t(Xh)~0 + wh_norm)$coefficients)/((!XXNA)%*%(wh_norm^2))
#deberia ser...
#th <- t(lm(t(Xh)~0+wh)$coefficients)
#th <- th/as.vector(sqrt(sum(th^2)))
#5. p
#ph <- t(Xh) %*% th/as.vector(t(th) %*% th)
#normalization for NAs
ph <- t(t(th) %*% Xh) / (t((!XXNA)) %*% th^2)
# temppp <- rep(0,res$nc)
# for (jj in 1:(res$nc)) {
#   temppp[jj] <- crossprod(temptt,XXwotNA[,jj])/drop(crossprod((!XXNA)[,jj],temptt^2))
# }
#6. Residuals
#res$residXX <- XXwotNA-temptt%*%temppp #residuals to the new matrix to get next components
Xh <- Xh - th %*% t(ph)
Ts <- cbind(Ts, th)
colnames(Ts) <- paste0("comp_", 1:h)
P <- cbind(P, ph)
colnames(P) <- paste0("comp_", 1:h)
W <- cbind(W, wh)
colnames(W) <- paste0("comp_", 1:h)
W_norm <- cbind(W_norm, wh_norm)
colnames(W_norm) <- paste0("comp_", 1:h)
E[[h]] <- Xh
}
#residuals^2
residuals <- sqrt(colSums(Xh^2, na.rm=TRUE))
h
residuals
#break iteration
if(any(residuals<tol)){
bad_var <- paste0(names(residuals)[residuals < tol], collapse = ", ")
message(paste0(paste0("Individual COX model cannot be computed for variables (", bad_var, "). Stopped at component ", h, ".")))
stopped = T
break
}
any(residuals<tol)
Xh <- lst_scale$Xh
#Update NAs by 0s
Xh[XXNA] <- 0
stopped = F
#residuals^2
residuals <- sqrt(colSums(Xh^2, na.rm=TRUE))
any(residuals<tol)
bad_var <- paste0(names(residuals)[residuals < tol], collapse = ", ")
bad_var
residuals
#2. wh <- individual cox regression vector
Xh[XXNA] <- NA
Xh[XXNA] <- 0
#Sometimes, fit can not be compute by NA at cox calculus, we cannot avoid printing the NAs matrix... !!!!
wh <- tryCatch(
# Specifying expression
expr = {
as.matrix(apply(Xh, 2, function(x){
eps = 1e-14
control <- survival::coxph.control(eps = eps, toler.chol = .Machine$double.eps^0.90,
iter.max = 220, toler.inf = sqrt(eps), outer.max = 100, timefix = TRUE)
fit <- survival::coxph(survival::Surv(time = time, event = event, type = "right") ~ ., as.data.frame(cbind(Ts,x)), control = control)
fit$coefficients["x"] #cause variable of study is called 'x' and we extract new coefficient taking into account components already computed
}))
},
# Specifying error message
error = function(e){
message(paste0("plsicox: ", e))
invisible(gc())
return(NA)
}
)
wh
if(all(is.na(wh))){
message(paste0("Individual COX models cannot be computed for each variable. Stopped at component ", h, "."))
stopped = T
break
}
if(any(is.na(wh))){
message(paste0(paste0("Individual COX model cannot be computed for variables (", paste0(rownames(wh)[is.na(wh)], collapse = ", ") ,")."), " Stopped at component ", h, "."))
stopped = T
break
}
# if(h!=1){
#   wh <- wh[h,]
# }
wh <- wh[,1]
#3. wh <- wh / ||wh||
wh_norm <- wh/as.vector(sqrt(sum(wh^2))) #as.vector(sqrt(t(wh) %*% wh))
#4. t = Xh wh / wh'wh
#4. t = Xh wh_norm (solo si wh ya normalizado)
#normalization for NAs
Xh[XXNA] <- 0
th <- (Xh %*% wh_norm)/((!XXNA) %*% wh_norm^2)
#5. p
#ph <- t(Xh) %*% th/as.vector(t(th) %*% th)
#normalization for NAs
ph <- t(t(th) %*% Xh) / (t((!XXNA)) %*% th^2)
#6. Residuals
#res$residXX <- XXwotNA-temptt%*%temppp #residuals to the new matrix to get next components
Xh <- Xh - th %*% t(ph)
Ts <- cbind(Ts, th)
colnames(Ts) <- paste0("comp_", 1:h)
P <- cbind(P, ph)
colnames(P) <- paste0("comp_", 1:h)
W <- cbind(W, wh)
colnames(W) <- paste0("comp_", 1:h)
W_norm <- cbind(W_norm, wh_norm)
colnames(W_norm) <- paste0("comp_", 1:h)
E[[h]] <- Xh
h=2
#residuals^2
residuals <- sqrt(colSums(Xh^2, na.rm=TRUE))
residuals
#2. wh <- individual cox regression vector
Xh[XXNA] <- NA
Xh[XXNA] <- 0
#Sometimes, fit can not be compute by NA at cox calculus, we cannot avoid printing the NAs matrix... !!!!
wh <- tryCatch(
# Specifying expression
expr = {
as.matrix(apply(Xh, 2, function(x){
eps = 1e-14
control <- survival::coxph.control(eps = eps, toler.chol = .Machine$double.eps^0.90,
iter.max = 220, toler.inf = sqrt(eps), outer.max = 100, timefix = TRUE)
fit <- survival::coxph(survival::Surv(time = time, event = event, type = "right") ~ ., as.data.frame(cbind(Ts,x)), control = control)
fit$coefficients["x"] #cause variable of study is called 'x' and we extract new coefficient taking into account components already computed
}))
},
# Specifying error message
error = function(e){
message(paste0("plsicox: ", e))
invisible(gc())
return(NA)
}
)
if(all(is.na(wh))){
message(paste0("Individual COX models cannot be computed for each variable. Stopped at component ", h, "."))
stopped = T
break
}
if(any(is.na(wh))){
message(paste0(paste0("Individual COX model cannot be computed for variables (", paste0(rownames(wh)[is.na(wh)], collapse = ", ") ,")."), " Stopped at component ", h, "."))
stopped = T
break
}
# if(h!=1){
#   wh <- wh[h,]
# }
wh <- wh[,1]
#3. wh <- wh / ||wh||
wh_norm <- wh/as.vector(sqrt(sum(wh^2))) #as.vector(sqrt(t(wh) %*% wh))
#4. t = Xh wh / wh'wh
#4. t = Xh wh_norm (solo si wh ya normalizado)
#normalization for NAs
Xh[XXNA] <- 0
th <- (Xh %*% wh_norm)/((!XXNA) %*% wh_norm^2)
#5. p
#ph <- t(Xh) %*% th/as.vector(t(th) %*% th)
#normalization for NAs
ph <- t(t(th) %*% Xh) / (t((!XXNA)) %*% th^2)
#6. Residuals
#res$residXX <- XXwotNA-temptt%*%temppp #residuals to the new matrix to get next components
Xh <- Xh - th %*% t(ph)
Ts <- cbind(Ts, th)
colnames(Ts) <- paste0("comp_", 1:h)
P <- cbind(P, ph)
colnames(P) <- paste0("comp_", 1:h)
W <- cbind(W, wh)
colnames(W) <- paste0("comp_", 1:h)
W_norm <- cbind(W_norm, wh_norm)
colnames(W_norm) <- paste0("comp_", 1:h)
E[[h]] <- Xh
if(stopped & h==1){ #if it is the first component, no cox model has been computed
func_call <- match.call()
invisible(gc())
return(plsicox_class(list(X = list("data" = if(returnData) X_norm else NA, "loadings" = NULL, "weightings" = NULL, "weightings_norm" = NULL, "W.star" = NULL, "scores" = NULL, "E" = NULL, "x.mean" = xmeans, "x.sd" = xsds),
Y = list("data" = Yh, "y.mean" = ymeans, "y.sd" = ysds),
beta_matrix = NULL, #NEED TO BE COMPUTED
survival_model = NULL,
n.comp = n.comp,
call = func_call,
X_input = if(returnData) X_original else NA,
Y_input = if(returnData) Y_original else NA)))
}
cox_model = NULL
d <- as.data.frame(cbind(as.matrix(Ts)))
h <- ncol(Ts)
aux <- tryCatch(
# Specifying expression
expr = {
survival::coxph(formula = survival::Surv(time,event) ~ .,
data = d[,1:h,drop=F],
ties = "efron",
singular.ok = T,
robust = T,
nocenter = rep(1, ncol(d[,1:h,drop=F])),
model=T)
},
# Specifying error message
error = function(e){
message(e$message)
invisible(gc())
return(NA)
}
)
while(all(is.na(aux)) & h>0){
h <- h-1
aux <- tryCatch(
# Specifying expression
expr = {
survival::coxph(formula = survival::Surv(time,event) ~ .,
data = d[,1:h,drop=F],
ties = "efron",
singular.ok = T,
robust = T,
nocenter = rep(1, ncol(d[,1:h,drop=F])),
model=T)
},
# Specifying error message
error = function(e){
if(verbose){
message(e$message)
}
invisible(gc())
return(NA)
}
)
}
cox_model <- NULL
cox_model$fit <- aux
#we cannot compute all components
if(h != n.comp & !all(is.na(cox_model$fit))){
if(verbose){
message(paste0("Model cannot be computed for all components. Final model select ", h," components instead of ", n.comp,"."))
}
#update all values
W <- W[,1:h,drop=F]
W_norm = W_norm[,1:h,drop=F]
P = P[,1:h,drop=F]
Ts = Ts[,1:h,drop=F]
E = E[1:h]
n.comp = ncol(Ts)
}
survival_model = NULL
if(!length(cox_model$fit) == 1){
survival_model <- getInfoCoxModel(cox_model$fit)
}
if(is.null(P) | is.null(W)){
message("PLSCOX model cannot be computed. Returning NA.")
invisible(gc())
return(NA)
}
#W.star
W.star <- W %*% solve(t(P) %*% W) #solve by W or W_norm??
rownames(Ts) <- rownames(X)
rownames(P) <- rownames(W_norm) <- rownames(W) <-  rownames(W.star) <- colnames(Xh)
if(stopped){
colnames(Ts) <- colnames(P) <- colnames(W_norm) <- colnames(W) <-  colnames(W.star) <- paste0("comp_", 1:h)
}else{
colnames(Ts) <- colnames(P) <- colnames(W_norm) <- colnames(W) <-  colnames(W.star) <- paste0("comp_", 1:n.comp)
}
func_call <- match.call()
t2 <- Sys.time()
time <- difftime(t2,t1,units = "mins")
invisible(gc())
survival_model$fit
load_all()
# run cv.plsicox
cv.plsicox_res <- cv.plsicox(X = X_train, Y = Y_train,
max.ncomp =  10,
n_run = 2, k_folds = 10,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant_models = F, alpha = 0.05,
w_AIC = 0,  w_c.index = 0, w_AUC = 1, times = NULL,
MIN_AUC_INCREASE = 0.05, MIN_AUC = 0.8, MIN_COMP_TO_CHECK = 3,
pred.attr = "mean", pred.method = "cenROC", fast_mode = F,
MIN_EPV = 5, return_models = F,
PARALLEL = T, verbose = F, seed = 123)
cv.plsicox_res #1min 8s.
# plot cv.plsicox
cv.plsicox_res$plot_AUC
plsicox_model <- plsicox(X = X_train, Y = Y_train,
n.comp = 2, #n.comp = cv.plsicox_res$opt.comp
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
tol = 1000,
MIN_EPV = 5, returnData = T, verbose = F)
plsicox_model
cox(X = X_train[,"KDM5C",drop=F], Y = Y_train)
plsicox_model <- plsicox(X = X_train, Y = Y_train,
n.comp = 2, #n.comp = cv.plsicox_res$opt.comp
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
tol = 1000,
MIN_EPV = 5, returnData = T, verbose = F)
plsicox_model
plsicox_model <- plsicox(X = X_train, Y = Y_train,
n.comp = 2, #n.comp = cv.plsicox_res$opt.comp
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
tol = 500,
MIN_EPV = 5, returnData = T, verbose = F)
plsicox_model
cv.plsicox_res$time
# run cv.splsdrcox
cv.splsdrcox_res <- cv.splsdrcox(X = X_train, Y = Y_train,
max.ncomp = 10, eta.list = seq(0,0.5,0.25), #penalty
n_run = 2, k_folds = 10,
x.scale = Tx.center = T, x.scale = F,
# run cv.splsdrcox
cv.splsdrcox_res <- cv.splsdrcox(X = X_train, Y = Y_train,
max.ncomp = 10, eta.list = seq(0,0.5,0.25), #penalty
n_run = 2, k_folds = 10,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant_models = F, alpha = 0.05,
w_AIC = 0,  w_c.index = 0, w_AUC = 1, times = NULL,
MIN_AUC_INCREASE = 0.05, MIN_AUC = 0.8, MIN_COMP_TO_CHECK = 3,
pred.attr = "mean", pred.method = "cenROC", fast_mode = F,
MIN_EPV = 5, return_models = F,
PARALLEL = T, verbose = F, seed = 123)
cv.splsdrcox_res #2min 40s.
splsdrcox_model <- splsdrcox(X = X_train, Y = Y_train,
n.comp = 1, eta = 0, #n.comp = cv.splsdrcox_res$opt.comp, eta = cv.splsdrcox_res$opt.eta
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
MIN_EPV = 5, returnData = T, verbose = F)
splsdrcox_model
# run cv.splsdrcox
cv.splsdrcox_mo_res <- cv.splsdrcox_mixOmics(X = X_train, Y = Y_train,
max.ncomp = 10, vector = NULL,
n_run = 2, k_folds = 10,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant_models = F, alpha = 0.05,
w_AIC = 0,  w_c.index = 0, w_AUC = 1, times = NULL,
MIN_AUC_INCREASE = 0.05, MIN_AUC = 0.8, MIN_COMP_TO_CHECK = 3,
pred.attr = "mean", pred.method = "cenROC", fast_mode = F,
MIN_EPV = 5, return_models = F,
PARALLEL = T, verbose = F, seed = 123)
load_all()
# run cv.splsdrcox
cv.splsdrcox_mo_res <- cv.splsdrcox_mixOmics(X = X_train, Y = Y_train,
max.ncomp = 10, vector = NULL,
n_run = 2, k_folds = 10,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant_models = F, alpha = 0.05,
w_AIC = 0,  w_c.index = 0, w_AUC = 1, times = NULL,
MIN_AUC_INCREASE = 0.05, MIN_AUC = 0.8, MIN_COMP_TO_CHECK = 3,
pred.attr = "mean", pred.method = "cenROC", fast_mode = F,
MIN_EPV = 5, return_models = F,
PARALLEL = T, verbose = F, seed = 123)
