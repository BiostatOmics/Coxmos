mybiotypes <- rep("miRNA", nrow(df_filtered))
names(mybiotypes) <- rownames(df_filtered)
factors = data.frame(Condition = f_condition)
rownames(factors) <- colnames(df_filtered)
mydata <- NOISeq::readData(data = df_filtered, factors = factors, biotype = mybiotypes)
##########
# SAMPLE #
##########
#distribution
mycountsbio = dat(mydata, factor = NULL, type = "countsbio", norm = T)
explo.plot(mycountsbio, toplot = "miRNA", samples = NULL, plottype = "boxplot")
#fasta miRNAs
mature <- read.table(paste0(project_path,"counts_2023/","hsa.fa"), quote="\"", comment.char="", stringsAsFactors=FALSE)
names_mature <- mature[apply(mature, 1, startsWith, ">"),]
names_mature <- unlist(lapply(names_mature, function(x){strsplit(x,">")[[1]][2]}))
mature <- mature[!apply(mature, 1, startsWith, ">"),]
mature <- as.data.frame(toupper(mature))
rownames(mature) <- names_mature
colnames(mature) <- "FASTA"
GC <- apply(mature, 1, function(x){
table <- table(strsplit(x, split = ""))
sum(table[names(table) %in% c("G", "C")] / sum(table))
})
GCcont <- cbind(mature, GC)
### Bias detection [NEW PATIENTS]
mymiRNA = intersect(rownames(df_filtered), rownames(GCcont))
GCcont = GCcont[mymiRNA,]
GCcont$length <- unlist(lapply(GCcont[,1], nchar))
factor <- as.data.frame(f_condition)
rownames(factor) <- names(f_condition)
mydata.data = readData(df_filtered[mymiRNA,], factors = factor, gc = GCcont[,"GC",drop=F])
# myplot2 = dat(mydata.data, type = "GCbias", norm = FALSE)
#
# par(mfrow = c(3, 2))
# explo.plot(myplot2, samples = 1:11)
### PCA %GC - CONDITION
myPCA.data = dat(mydata.data, type = "PCA", logtransf = F, norm=T)
plot.scores.gg.cont(myPCA = myPCA.data, comp = c(1,2), title = "PCA raw data")
plot.loadings.gg(myPCA = myPCA.data, comp = c(1,2), title = "PCA raw data", color = GCcont)
df_filtered[df_filtered==0] = 0.001
norm.rpkm <- NOISeq::rpkm(df_filtered)
norm.tmm <- NOISeq::tmm(df_filtered)
norm.uqua <- NOISeq::uqua(df_filtered)
library(limma)
norm.limma <- limma::normalizeQuantiles(df_filtered, ties=TRUE)
library(cqn)
norm.cqn.pre <- cqn(counts = df_filtered,
x = GCcont$GC,
lengths = 1, #GCcont$length,#mantener contastante!!!!
verbose = TRUE, lengthMethod = "fixed")
norm.cqn.ln <- norm.cqn.pre$y + norm.cqn.pre$offset
#log
norm.rpkm.ln <- log2(norm.rpkm)
norm.tmm.ln <- log2(norm.tmm)
norm.uqua.ln <- log2(norm.uqua)
norm.limma.ln <- log2(norm.limma)
norm.cqn.ln <- norm.cqn.ln #already in log2
lst_norm <- list("RPKM" = norm.rpkm.ln,
"TMM" = norm.tmm.ln,
"UQUA" = norm.uqua.ln,
"LIMMA" = norm.limma.ln,
"CQN" = norm.cqn.ln)
ncomp = 9
logTransformation = F
lst_pcas <- purrr::map(lst_norm, ~ropls::opls(t(.), scaleC = "center", algoC = "default", log10L = logTransformation, predI = ncomp))
d.factors <- data.frame("Condition" = f_condition)
lst_best_components <- purrr::map(lst_pcas, ~getBestFactorExplanationPCA(., d.factors))
lst_best_components_sorted <- purrr::map(lst_best_components, ~.[order(.[,2]),])
#plot 1vs2
lst_ggp_pca_1vs2 <- purrr::map2(.x = lst_pcas, .y = names(lst_best_components),
~plotOPLS(.x,
comp = c(1,2),
factor = f_condition,
legend.title = .y,
allNames = T))
#plot best variance
lst_ggp_pca_auto <- purrr::map2(.x = lst_pcas, .y = names(lst_pcas),
~plotOPLS(.x,
comp = lst_best_components_sorted[[.y]]$Component[1:2],,
factor =  f_condition,
legend.title = .y,
allNames = T))
# Transformar la matriz en un formato largo
lst_long_data <- purrr::map(lst_norm, ~tidyr::gather(data = as.data.frame(.),
key = "observation",
value = "value"))
lst_long_data <- purrr::map(lst_long_data, ~cbind(., "condition" = f_condition_version[.$observation]))
lst_histogram <- purrr::map(lst_long_data, ~ggplot(data = ., aes(x = observation, y = value, fill = condition)) + geom_boxplot())
d.factors <- data.frame("Condition" = f_condition)
lst_best_components <- purrr::map(lst_pcas, ~getBestFactorExplanationPCA(., d.factors))
lst_best_components_sorted <- purrr::map(lst_best_components, ~.[order(.[,2]),])
#plot 1vs2
lst_ggp_pca_1vs2 <- purrr::map2(.x = lst_pcas, .y = names(lst_best_components),
~plotOPLS(.x,
comp = c(1,2),
factor = f_condition,
legend.title = .y,
allNames = T))
#plot best variance
lst_ggp_pca_auto <- purrr::map2(.x = lst_pcas, .y = names(lst_pcas),
~plotOPLS(.x,
comp = lst_best_components_sorted[[.y]]$Component[1:2],,
factor =  f_condition,
legend.title = .y,
allNames = T))
# Transformar la matriz en un formato largo
lst_long_data <- purrr::map(lst_norm, ~tidyr::gather(data = as.data.frame(.),
key = "observation",
value = "value"))
lst_long_data <- purrr::map(lst_long_data, ~cbind(., "condition" = f_condition_version[.$observation]))
lst_histogram <- purrr::map(lst_long_data, ~ggplot(data = ., aes(x = observation, y = value, fill = condition)) + geom_boxplot())
folder_ggp <- paste0(project_path, folder_results, "v3_vesicula_plot_1vs2/")
dir.create(file.path(folder_ggp), showWarnings = FALSE)
save_ggplot_lst.svg(lst_plots = lst_ggp_pca_1vs2, folder = folder_ggp, object_name = "plot")
folder_ggp <- paste0(project_path, folder_results, "v3_vesicula_plot_auto/")
dir.create(file.path(folder_ggp), showWarnings = FALSE)
save_ggplot_lst.svg(lst_plots = lst_ggp_pca_auto, folder = folder_ggp, object_name = "plot")
folder_ggp <- paste0(project_path, folder_results, "v3_vesicula_plot_histogram/")
dir.create(file.path(folder_ggp), showWarnings = FALSE)
save_ggplot_lst.svg(lst_plots = lst_histogram, folder = folder_ggp)
lst_histogram$RPKM
condition
lst_long_data
f_condition
# Transformar la matriz en un formato largo
lst_long_data <- purrr::map(lst_norm, ~tidyr::gather(data = as.data.frame(.),
key = "observation",
value = "value"))
lst_long_data <- purrr::map(lst_long_data, ~cbind(., "condition" = f_condition[.$observation]))
lst_histogram <- purrr::map(lst_long_data, ~ggplot(data = ., aes(x = observation, y = value, fill = condition)) + geom_boxplot())
lst_histogram
folder_ggp <- paste0(project_path, folder_results, "v3_vesicula_plot_1vs2/")
dir.create(file.path(folder_ggp), showWarnings = FALSE)
save_ggplot_lst.svg(lst_plots = lst_ggp_pca_1vs2, folder = folder_ggp, object_name = "plot")
folder_ggp <- paste0(project_path, folder_results, "v3_vesicula_plot_auto/")
dir.create(file.path(folder_ggp), showWarnings = FALSE)
save_ggplot_lst.svg(lst_plots = lst_ggp_pca_auto, folder = folder_ggp, object_name = "plot")
folder_ggp <- paste0(project_path, folder_results, "v3_vesicula_plot_histogram/")
dir.create(file.path(folder_ggp), showWarnings = FALSE)
save_ggplot_lst.svg(lst_plots = lst_histogram, folder = folder_ggp)
save.image(file = paste0(project_path, folder_results, "miRNA_data_filtered_norm_v3_vesicula.RData"))
#load(file = paste0(project_path, "miRNA-data.RData"))
factorToBinary <- function(d.cualFiltered, all=F, sep = "_", except = ""){
if(nrow(d.cualFiltered)==0 | is.null(d.cualFiltered)){
return(d.cualFiltered)
}
binaryMatrix <- NULL
options(na.action='na.pass')
for(cn in colnames(d.cualFiltered)){
if(cn %in% except)
next
variable <- d.cualFiltered[, cn, drop=F]
colnames(variable) <- cn
if(all){
form <- as.formula(paste0("~ ", cn, " + 0"))
binaryVariable <- model.matrix(form, data=variable)[,1:length(levels(variable[,1])), drop=F]
colnames(binaryVariable) <- paste0(cn, sep, levels(variable[,1]))
}else{
form <- as.formula(paste0("~ ", cn))
binaryVariable <- model.matrix(form, data=variable)[,2:length(levels(variable[,1])), drop=F]
colnames(binaryVariable) <- paste0(cn, sep, levels(variable[,1])[2:length(levels(variable[,1]))])
}
binaryMatrix <- cbind(binaryMatrix, binaryVariable)
}
colnames(binaryMatrix) <- sapply(colnames(binaryMatrix), function(x){gsub(" ", "", x)}) #colnames with these simbols has problems in coxSW
colnames(binaryMatrix) <- sapply(colnames(binaryMatrix), function(x){gsub("/", "_", x)})
colnames(binaryMatrix) <- sapply(colnames(binaryMatrix), function(x){gsub("-", "_", x)})
binaryMatrix <- as.data.frame(binaryMatrix)
#trasnform to factors
# for(cn in colnames(binaryMatrix)){
#   binaryMatrix[,cn] <- as.factor(binaryMatrix[,cn])
# }
return(binaryMatrix)
}
df <- data.frame(CLASE = fatcor(c("A1","A1","A2","A2","A3","A3","A2","A1","A3","A4","A5","A4")))
df <- data.frame(CLASE = factor(c("A1","A1","A2","A2","A3","A3","A2","A1","A3","A4","A5","A4")))
df
df$CLASE
factorToBinary <- function(d.cualFiltered)
res <- factorToBinary(d.cualFiltered)
factorToBinary <- function(df)
res <- factorToBinary(df)
res
res <- factorToBinary(df, all = T)
res
?survminer::ggforest
devtools::load_all(".")
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
library(RColorConesa)
#theme_set(theme_colorConesa()) #under development
# load Tasic dataset
data("X_miRNA_glioblastoma")
data("Y_miRNA_glioblastoma")
X <- X_miRNA_glioblastoma
Y <- Y_miRNA_glioblastoma
rm(X_miRNA_glioblastoma, Y_miRNA_glioblastoma)
knitr::kable(X[1:5,1:5])
knitr::kable(Y[1:5,])
knitr::kable(dim(X), col.names = "X")
knitr::kable(dim(Y), col.names = "Y")
ggp_density.event <- plot_events(Y = Y,
categories = c("Censored","Death"), #name for FALSE/0 (Censored) and TRUE/1 (Event)
y.text = "Number of observations",
roundTo = 0.5,
max.breaks = 15)
ggp_density.event$plot
set.seed(321)
index_train <- caret::createDataPartition(Y$event,
p = .8, # 80% train
list = FALSE,
times = 1)
X_train <- X[index_train,] #443x534
Y_train <- Y[index_train,]
X_test <- X[-index_train,] #109x534
Y_test <- Y[-index_train,]
EPV <- getEPV(X_train, Y_train)
EPV
coxen_model <- coxEN(X = X_train, Y = Y_train,
EN.alpha = 0, #cv.coxen_res$opt.EN.alpha
max.variables = 47, #cv.coxen_res$opt.nvar
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 5, returnData = T, verbose = F)
coxen_model
coxen_model <- coxEN(X = X_train, Y = Y_train,
EN.alpha = 0, #cv.coxen_res$opt.EN.alpha
max.variables = 47, #cv.coxen_res$opt.nvar
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = T, alpha = 0.05,
MIN_EPV = 5, returnData = T, verbose = F)
coxen_model
plsicox_model <- plsicox(X = X_train, Y = Y_train,
n.comp = 3, #n.comp = cv.plsicox_res$opt.comp
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
MIN_EPV = 5, returnData = T, verbose = F)
plsicox_model
splsdrcox_model <- splsdrcox(X = X_train, Y = Y_train,
n.comp = 1, eta = 0.75, #n.comp = cv.splsdrcox_res$opt.comp, eta = cv.splsdrcox_res$opt.eta
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
MIN_EPV = 5, returnData = T, verbose = F)
splsdrcox_model
splsdrcox_mo_model <- splsdrcox_mixOmics(X = X_train, Y = Y_train,
n.comp = 2, vector = 534,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
MIN_NVAR = 10, MAX_NVAR = 1000, n.cut_points = 5,
MIN_AUC_INCREASE = 0.01,
EVAL_METHOD = "AUC", pred.method = "cenROC", max.iter = 200,
MIN_EPV = 5, returnData = T, verbose = F)
splsdrcox_mo_model <- splsdrcox_dynamic(X = X_train, Y = Y_train,
n.comp = 2, vector = 534,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
MIN_NVAR = 10, MAX_NVAR = 1000, n.cut_points = 5,
MIN_AUC_INCREASE = 0.01,
EVAL_METHOD = "AUC", pred.method = "cenROC", max.iter = 200,
MIN_EPV = 5, returnData = T, verbose = F)
splsdrcox_mo_model
# run cv.splsdrcox
cv.splsdacox_res <- cv.splsdacox_dynamic(X = X_train, Y = Y_train,
max.ncomp = 10,  vector = NULL,
MIN_NVAR = 10, MAX_NVAR = 1000, n.cut_points = 10, EVAL_METHOD = "cenROC",
n_run = 2, k_folds = 10,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant_models = F, alpha = 0.05,
w_AIC = 0,  w_c.index = 0, w_AUC = 1, times = NULL,
MIN_AUC_INCREASE = 0.05, MIN_AUC = 0.8, MIN_COMP_TO_CHECK = 3,
pred.attr = "mean", pred.method = "cenROC", fast_mode = F,
MIN_EPV = 5, return_models = F,
PARALLEL = T, verbose = F, seed = 123)
# run cv.splsdrcox
cv.splsdacox_res <- cv.splsdacox_dynamic(X = X_train, Y = Y_train,
max.ncomp = 10,  vector = NULL,
MIN_NVAR = 10, MAX_NVAR = 1000, n.cut_points = 10, EVAL_METHOD = "cenROC",
n_run = 2, k_folds = 10,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant_models = F, alpha = 0.05,
w_AIC = 0,  w_c.index = 0, w_AUC = 1, times = NULL,
MIN_AUC_INCREASE = 0.05, MIN_AUC = 0.8, MIN_COMP_TO_CHECK = 3,
pred.attr = "mean", pred.method = "cenROC", fast_mode = F,
MIN_EPV = 5, return_models = F,
PARALLEL = F, verbose = F, seed = 123)
cv.splsdacox_res #4min
splsdacox_mo_model <- splsdacox_dynamic(X = X_train, Y = Y_train,
n.comp = 6, vector = 184,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
MIN_NVAR = 10, MAX_NVAR = 1000, n.cut_points = 5,
MIN_AUC_INCREASE = 0.01,
EVAL_METHOD = "AUC", pred.method = "cenROC", max.iter = 200,
MIN_EPV = 5, returnData = T, verbose = F)
splsdacox_mo_model
lst_models <- list("COX-EN" = coxen_model,
"PLS-ICOX" = plsicox_model,
"sPLS-DRCOX" = splsdrcox_model,
"sPLS-DRCOX-Dynamic" = splsdrcox_mo_model,
"sPLS-DACOX-Dynamic" = splsdacox_mo_model)
eval_results <- eval_HDcox_models(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
pred.method = "cenROC",
pred.attr = "mean",
times = NULL, max_time_points = 15,
PARALLEL = F)
Y_test
rn_X <- rownames(X_test)
if(!all(rn_X %in% rownames(Y_test))){
stop("Rownames of X_test must be in Y_test")
}
sub_Y <- Y_test[rn_X,,drop=F]
sub_Y
sum(sub_Y[,"event"])
devtools::load_all(".")
eval_results <- eval_HDcox_models(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
pred.method = "cenROC",
pred.attr = "mean",
times = NULL, max_time_points = 15,
PARALLEL = F)
eval_results <- eval_HDcox_models(lst_models = lst_models[1],
X_test = X_test, Y_test = Y_test,
pred.method = "cenROC",
pred.attr = "mean",
times = NULL, max_time_points = 15,
PARALLEL = F)
eval_results <- eval_HDcox_models(lst_models = lst_models[2],
X_test = X_test, Y_test = Y_test,
pred.method = "cenROC",
pred.attr = "mean",
times = NULL, max_time_points = 15,
PARALLEL = F)
eval_results <- eval_HDcox_models(lst_models = lst_models[3],
X_test = X_test, Y_test = Y_test,
pred.method = "cenROC",
pred.attr = "mean",
times = NULL, max_time_points = 15,
PARALLEL = F)
eval_results <- eval_HDcox_models(lst_models = lst_models[4],
X_test = X_test, Y_test = Y_test,
pred.method = "cenROC",
pred.attr = "mean",
times = NULL, max_time_points = 15,
PARALLEL = F)
lst_models = lst_models
pred.method = "cenROC"
pred.attr = "mean"
times = NULL
PARALLEL = F
max_time_points = 15
#Check at least two events in total
checkAtLeastTwoEvents(X_test, Y_test)
#Check at least two events in total
checkAtLeastTwoEvents(X_test, Y_test)
devtools::load_all(".")
if(!is.list(X_test)){
rn_X <- rownames(X_test)
if(!all(rn_X %in% rownames(Y_test))){
stop("Rownames of X_test must be in Y_test")
}
sub_Y <- Y_test[rn_X,,drop=F]
if(sum(sub_Y[,"event"])<2){
stop("To evaluate a model, at least two events are mandatory in TEST data set.")
}
}else{ # MULTIOMIC APPROACH
for(block in names(X_test)){
rn_X <- rownames(X_test[[block]])
if(!all(rn_X %in% rownames(Y_test))){
stop(paste0("Rownames of X_test and block ", block," must be in Y_test"))
}
sub_Y <- Y_test[rn_X,,drop=F]
if(sum(sub_Y[,"event"])<2){
stop("To evaluate a model, at least two events are mandatory in TEST data set.")
}
!is.list(X_test)
X_test
class(X_test)
is.list(X_test)
devtools::load_all(".")
class(X_test)
is.list(X_test)
head(X_test)
X_test[1:5,1:5]
df <- as.data.frame(matrix(0,3))
df
df <- as.data.frame(matrix(0,3,3))
df
class(df)
is.list(df)
?is.list
?pairlist
isa(df, "list")
devtools::load_all(".")
eval_results <- eval_HDcox_models(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
pred.method = "cenROC",
pred.attr = "mean",
times = NULL, max_time_points = 15,
PARALLEL = F)
eval_results$df
eval_results$lst_AUC$`COX-EN`$AUC
eval_results
#eval_results$cenROC
lst_eval_results <- plot_evaluation(eval_results)
#lst_eval_results <- plot_evaluation.list(eval_results)
lst_eval_results$lst_plots$lineplot
lst_eval_results$lst_plot_comparisons$anova
# lst_eval_results$cenROC$lst_plots$lineplot.mean
# lst_eval_results$cenROC$lst_plot_comparisons$t.test
lst_models_time <- list(coxen_model,
plsicox_model,
splsdrcox_model,
splsdrcox_mo_model,
splsdacox_mo_model)
ggp_time <- plot_time.list(lst_models_time)
ggp_time
check()
library(devtools)
check()
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
library(RColorConesa)
#theme_set(theme_colorConesa()) #under development
# load Tasic dataset
data("X_miRNA_glioblastoma")
data("Y_miRNA_glioblastoma")
X <- X_miRNA_glioblastoma
Y <- Y_miRNA_glioblastoma
rm(X_miRNA_glioblastoma, Y_miRNA_glioblastoma)
knitr::kable(X[1:5,1:5])
knitr::kable(Y[1:5,])
dim(X)[1]
dim(X)[2]
dim(Y)[1]
dim(Y)[2]
# load Tasic dataset
data("X_miRNA_glioblastoma")
data("Y_miRNA_glioblastoma")
X <- X_miRNA_glioblastoma
Y <- Y_miRNA_glioblastoma
rm(X_miRNA_glioblastoma, Y_miRNA_glioblastoma)
knitr::kable(X[1:5,1:5])
knitr::kable(Y[1:5,])
devtools::load_all(".")
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
library(RColorConesa)
#theme_set(theme_colorConesa()) #under development
# load Tasic dataset
data("X_miRNA_glioblastoma")
data("Y_miRNA_glioblastoma")
X <- X_miRNA_glioblastoma
Y <- Y_miRNA_glioblastoma
#rm(X_miRNA_glioblastoma, Y_miRNA_glioblastoma)
knitr::kable(X[1:5,1:5])
knitr::kable(Y[1:5,])
dim(X)[1]
dim(X)[2]
library(devtools)
devtools::load_all(".")
check()
check(vignettes = F)
