model <- comp_model_lst[[comp]][[r]][[f]]
if(all(is.null(model$survival_model))){
pb$tick()
next
}
cox <- model$survival_model$fit
# exception - EN no model
if(all(is.null(cox)) || all(is.na(cox))){
pb$tick()
df_results_evals <- rbind(df_results_evals, cbind(max.ncomp[[comp]], r, f, 0, NA, NA))
next
}
if(attr(model, "model") %in% c(pkg.env$mb.splsdrcox, pkg.env$mb.splsdacox)){
n_var <- unlist(purrr::map(model$n.varX, ~length(.[[1]])))
n_var <- paste0(n_var, collapse = "_")
}else if(attr(model, "model") == pkg.env$sb.plsicox){
n_var <- purrr::map(model$list_pls_models, ~nrow(.$X$loadings))
n_var <- paste0(n_var, collapse = "_") #VAR FOR SB.spls IS THE MAX NUMBER OF VARIABLES (PER BLOCK)
}else if(attr(model, "model") == pkg.env$sb.splsdrcox){
n_var <- purrr::map(model$list_spls_models, ~sum(rowSums(.$X$weightings!=0)>0)) #this have to be checked !!!
n_var <- paste0(n_var, collapse = "_")
}else if(attr(model, "model") %in% c(pkg.env$splsdrcox_mixomics, pkg.env$splsdacox_mixomics)){
n_var <- unique(apply(model$X$weightings, 2, function(x){sum(x!=0)}))
#n_var <- paste0(n_var, collapse = "_")
}else if(attr(model, "model") %in% pkg.env$plsicox){
n_var <- nrow(model$X$loadings)
}else if(attr(model, "model") %in% pkg.env$classical_methods){
n_var <- length(model$survival_model$coef) #COX, COXSW and COXEN
}
df <- as.data.frame(summary(cox)[[7]])
#delete models with non-significant components
if(remove_non_significant_models == T){
if(any(df$`Pr(>|z|)`>alpha)){
pb$tick()
if(verbose){
message(paste0("\nModel - Comp: ", comp ,", Run: ",r,", Fold: ",f," - Is a non-significant model"))
}
next
}
aic <- stats::extractAIC(cox, k=2)[2] #k=2 <- AIC, [2] AIC Value
c_index <- survival::concordance(cox)$concordance
df_results_evals <- rbind(df_results_evals, cbind(max.ncomp[[comp]], r, f, n_var, aic, c_index))
pb$tick()
}#fold
}#run
}#component
if(!is.null(df_results_evals)){
colnames(df_results_evals) <- c("n.comps", "runs", "fold", "n.var", "AIC", "c_index")
df_results_evals <- as.data.frame(df_results_evals)
}
}else{
for(comp in 1:length(max.ncomp)){
for(e in 1:length(eta.list)){
for(r in 1:n_run){
for(f in 1:k_folds){
model <- comp_model_lst[[comp]][[e]][[r]][[f]]
if(all(is.null(model$survival_model))){
pb$tick()
next
}
cox <- model$survival_model$fit
#exception
if(all(is.null(cox)) || all(is.na(cox))){
pb$tick()
next
}
eta <- model$eta
if(attr(model, "model") == pkg.env$sb.splsdrcox){
n_var <- purrr::map(model$list_spls_models, ~length(unique(unlist(.$var_by_component))))
n_var <- paste0(n_var, collapse = "_") #VAR FOR SB.spls IS THE MAX NUMBER OF VARIABLES (PER BLOCK)
}else{
n_var <- nrow(model$X$loadings)
}
df <- as.data.frame(summary(cox)[[7]])
#delete models with non-significant components
if(remove_non_significant_models == T){
if(any(df$`Pr(>|z|)`>alpha)){
pb$tick()
next
}
aic <- stats::extractAIC(cox, k=2)[2] #k=2 <- AIC, [2] AIC Value
c_index <- survival::concordance(cox)$concordance
df_results_evals <- rbind(df_results_evals, cbind(max.ncomp[[comp]], eta.list[[e]], r, f, n_var, aic, c_index))
pb$tick()
}#fold
}#run
}#eta
}#component
if(!all(is.null(df_results_evals))){
colnames(df_results_evals) <- c("n.comps", "eta","runs", "fold", "n.var", "AIC", "c_index")
df_results_evals <- as.data.frame(df_results_evals)
}
comp
e
r
f
model <- comp_model_lst[[comp]][[e]][[r]][[f]]
e
eta.list
model <- comp_model_lst[[comp]][[r]][[f]]
model
all(is.null(model$survival_model))
model
is.na(model) || all(is.null(model$survival_model))
devtools::load_all(".")
df_results_evals <- get_COX_evaluation_AIC_CINDEX(comp_model_lst = comp_model_lst, alpha = alpha,
max.ncomp = max.ncomp, eta.list = NULL, n_run = n_run, k_folds = k_folds,
total_models = total_models, remove_non_significant_models = remove_non_significant_models, verbose = verbose)
df_results_evals
if(all(is.null(df_results_evals))){
message(paste0("Best model could NOT be obtained. All models computed present problems."))
t2 <- Sys.time()
time <- difftime(t2,t1,units = "mins")
if(return_models){
return(cv.splsdrcox_mixOmics_class(list(best_model_info = NULL, df_results_folds = NULL, df_results_runs = NULL, df_results_comps = NULL, lst_models = comp_model_lst, pred.method = pred.method, opt.comp = NULL, opt.nvar = NULL, plot_AUC = NULL, plot_c_index = NULL, plot_AIC = NULL, class = pkg.env$cv.splsdrcox_mixomics, time = time)))
}else{
return(cv.splsdrcox_mixOmics_class(list(best_model_info = NULL, df_results_folds = NULL, df_results_runs = NULL, df_results_comps = NULL, lst_models = NULL, pred.method = pred.method, opt.comp = NULL, opt.nvar = NULL, plot_AUC = NULL, plot_c_index = NULL, plot_AIC = NULL, class = pkg.env$cv.splsdrcox_mixomics, time = time)))
}
df_results_evals_comp <- NULL
df_results_evals_run <- NULL
df_results_evals_fold <- NULL
optimal_component <- NULL
optimal_component_flag <- NULL
if(w_AUC!=0){
#total_models <- ifelse(!fast_mode, n_run * max.ncomp, k_folds * n_run * max.ncomp) #inside get_COX_evaluation_AUC
#As we are measuring just one evaluator and one method - PARALLEL=F
lst_df <- get_COX_evaluation_AUC(comp_model_lst = comp_model_lst,
lst_X_test = lst_X_test, lst_Y_test = lst_Y_test,
df_results_evals = df_results_evals, times = times,
fast_mode = fast_mode, pred.method = pred.method, pred.attr = pred.attr,
max.ncomp = max.ncomp, n_run = n_run, k_folds = k_folds,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
w_AUC = w_AUC, #total_models = total_models,
method.train = pkg.env$splsdrcox_mixomics, PARALLEL = F)
df_results_evals_comp <- lst_df$df_results_evals_comp
df_results_evals_run <- lst_df$df_results_evals_run
df_results_evals_fold <- lst_df$df_results_evals_fold
optimal_comp_index <- lst_df$optimal_comp_index
optimal_comp_flag <- lst_df$optimal_comp_flag
}else{
df_results_evals_fold <- df_results_evals
}
df_results_evals_comp <- cv.getScoreFromWeight(df_results_evals_comp, w_AIC, w_c.index, w_AUC,
colname_AIC = "AIC", colname_c_index = "c_index", colname_AUC = "AUC")
df_results_evals_comp
df_results_evals_run
comp_model_lst$comp_1$run_1$fold_1$X$data
comp_model_lst$comp_1$run_1$fold_1$X$weightings
comp_model_lst$comp_1$run_1$fold_1$X$scores
rownames(comp_model_lst$comp_1$run_1$fold_1$X$scores)
rownames(comp_model_lst$comp_2$run_1$fold_1$X$scores)
devtools::load_all(".")
cv.splsdrcox_mixOmics_res <- cv.splsdrcox_mixOmics(X = X_train, Y = Y_train,
max.ncomp = max.ncomp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points, EVAL_METHOD = EVAL_METHOD,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
remove_non_significant_models = remove_non_significant_models,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL, tol = tol,
verbose = verbose)
devtools::load_all(".")
load("D:/Pedro/Mega/Doctorado/Otros proyectos/data_GSE49997_clinical.RData")
set.seed(123)
index_train <- caret::createDataPartition(Y$event,
p = .7, #70% train
list = FALSE,
times = 1)
X_train <- X[index_train,]
Y_train <- Y[index_train,]
X_test <- X[-index_train,]
Y_test <- Y[-index_train,]
cv.splsdrcox_mixOmics_res <- cv.splsdrcox_mixOmics(X = X_train, Y = Y_train,
max.ncomp = max.ncomp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points, EVAL_METHOD = EVAL_METHOD,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
remove_non_significant_models = remove_non_significant_models,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL, tol = tol,
verbose = verbose)
max.ncomp
max.ncomp = 6
cv.splsdrcox_mixOmics_res <- cv.splsdrcox_mixOmics(X = X_train, Y = Y_train,
max.ncomp = max.ncomp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points, EVAL_METHOD = EVAL_METHOD,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
remove_non_significant_models = remove_non_significant_models,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL, tol = tol,
verbose = verbose)
vector
remove_non_significant_models
n.cut_points
X = X_train
Y = Y_train
t1 <- Sys.time()
#### ### ###
# WARNINGS #
#### ### ###
#Check evaluator installed:
checkLibraryEvaluator(pred.method)
pb_text <- "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated remaining time: :eta]"
#### REQUIREMENTS
checkY.colnames(Y)
check.cv.weights(c(w_AIC, w_c.index, w_AUC))
max.ncomp <- check.ncomp(X, max.ncomp)
# if(!pred.method %in% c("risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I")){
#   stop_quietly(paste0("pred.method must be one of the following: ", paste0(c("risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I"), collapse = ", ")))
# }
if(!pred.method %in% pkg.env$AUC_evaluators){
stop_quietly(paste0("pred.method must be one of the following: ", paste0(pkg.env$AUC_evaluators, collapse = ", ")))
}
#### MAX PREDICTORS
max.ncomp <- check.maxPredictors(X, Y, MIN_EPV, max.ncomp, verbose = verbose)
#### REQUIREMENTS
lst_dnz <- deleteZeroOrNearZeroVariance(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
#### #
# CV #
#### #
set.seed(seed)
lst_data <- splitData_Iterations_Folds(X, Y, n_run = n_run, k_folds = k_folds) #FOR TEST
lst_X_train <- lst_data$lst_X_train
lst_Y_train <- lst_data$lst_Y_train
lst_X_test <- lst_data$lst_X_test
lst_Y_test <- lst_data$lst_Y_test
#### ### ### ###
# TRAIN MODELS #
#### ### ### ###
total_models <- 1 * k_folds * n_run
comp_model_lst  <- get_HDCOX_models2.0(method = pkg.env$splsdrcox_mixomics,
lst_X_train = lst_X_train, lst_Y_train = lst_Y_train,
max.ncomp = max.ncomp, eta.list = NULL, EN.alpha.list = NULL, n_run = n_run, k_folds = k_folds,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD,
x.center = x.center, x.scale = x.scale, y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = F, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = remove_non_significant,
total_models = total_models, PARALLEL = PARALLEL, verbose = verbose)
comp_model_lst  <- get_HDCOX_models2.0(method = pkg.env$splsdrcox_mixomics,
lst_X_train = lst_X_train, lst_Y_train = lst_Y_train,
max.ncomp = max.ncomp, eta.list = NULL, EN.alpha.list = NULL, n_run = n_run, k_folds = k_folds,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD,
x.center = x.center, x.scale = x.scale, y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = F, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = remove_non_significant, tol = tol,
total_models = total_models, PARALLEL = PARALLEL, verbose = verbose)
tol
tol = 1e-20
comp_model_lst  <- get_HDCOX_models2.0(method = pkg.env$splsdrcox_mixomics,
lst_X_train = lst_X_train, lst_Y_train = lst_Y_train,
max.ncomp = max.ncomp, eta.list = NULL, EN.alpha.list = NULL, n_run = n_run, k_folds = k_folds,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD,
x.center = x.center, x.scale = x.scale, y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = F, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = remove_non_significant, tol = tol,
total_models = total_models, PARALLEL = PARALLEL, verbose = verbose)
total_models
method = pkg.env$splsdrcox_mixomics
eta.list = NULL
EN.alpha.list = NULL
toKeep.zv = NULL
remove_zero_variance = F
remove_near_zero_variance = F
comp_model_lst <- list()
fold_list <- list()
run_list <- list()
eta_model_lst <- NULL
info <- NULL # for sPLS
## CHECK METHOD
if(is.null(eta.list) & is.null(EN.alpha.list) & !method %in% c(pkg.env$plsicox, pkg.env$splsdacox_mixomics, pkg.env$splsdrcox_mixomics, pkg.env$sb.plsicox, pkg.env$mb.splsdrcox, pkg.env$mb.splsdacox)){
stop_quietly("Method must be one of 'PLS-ICOX', 'sPLS-DACOX-MixOmics', 'MB.sPLS-DACOX' or 'sPLS-DRCOX-MixOmics' if 'eta.list' and 'EN.alpha.list' is NULL.")
}else if(!is.null(eta.list) & is.null(EN.alpha.list)  & !method %in% c(pkg.env$splsdrcox, pkg.env$sb.splsdrcox)){
stop_quietly("Method must be 'sPLS-DRCOX' if 'eta.list' is not NULL.")
}else if(!is.null(EN.alpha.list) & !method %in% c(pkg.env$coxEN)){
stop_quietly("Method must be 'coxEN' if 'EN.alpha.list' is not NULL.")
}
pb_text <- "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated remaining time: :eta]"
pb <- progress::progress_bar$new(format = pb_text,
total = total_models,
complete = "=",   # Caracteres de las iteraciones finalizadas
incomplete = "-", # Caracteres de las iteraciones no finalizadas
current = ">",    # Caracter actual
clear = FALSE,    # Si TRUE, borra la barra cuando termine
width = 100)      # Ancho de la barra de progreso
message(paste0("Training all possible models for ", method, "..."))
pb$tick(0)
#### ### ### ### ### ### #
# UPDATING GLOBALS SIZE #
#### ### ### ### ### ### #
MB = 4000
bytes = MB*1024^2
options(future.globals.maxSize = bytes)
#function to compute all models at the same time - just last component
lst_inputs <- list()
cont = 1
lst_names = NULL
for(i in max.ncomp){
for(r in 1:n_run){
for(f in 1:k_folds){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$comp = i
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(i, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
lst_all_models <- purrr::map(lst_inputs, ~splsdrcox_mixOmics(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD, tol = tol, alpha = alpha,
MIN_EPV = MIN_EPV, returnData = F))
method
method %in% c(pkg.env$plsicox, pkg.env$splsdacox_mixomics, pkg.env$splsdrcox_mixomics, pkg.env$sb.plsicox, pkg.env$mb.splsdrcox, pkg.env$mb.splsdacox)
#function to compute all models at the same time - just last component
lst_inputs <- list()
cont = 1
lst_names = NULL
for(i in max.ncomp){
for(r in 1:n_run){
for(f in 1:k_folds){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$comp = i
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(i, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
if(PARALLEL){
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
if(method==pkg.env$plsicox){
lst_all_models <- furrr::future_map(lst_inputs, ~plsicox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant, tol = tol, alpha = alpha,
MIN_EPV = MIN_EPV, returnData = F, verbose = verbose), .options = furrr_options(seed = 123))
}else if(method==pkg.env$splsdacox_mixomics){
lst_all_models <- furrr::future_map(lst_inputs, ~splsdacox_mixOmics(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD, tol = tol, alpha = alpha,
MIN_EPV = MIN_EPV, returnData = F, verbose = verbose), .options = furrr_options(seed = 123))
}else if(method==pkg.env$splsdrcox_mixomics){
lst_all_models <- furrr::future_map(lst_inputs, ~splsdrcox_mixOmics(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD, tol = tol, alpha = alpha,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}else if(method==pkg.env$sb.plsicox){
lst_all_models <- furrr::future_map(lst_inputs, ~sb.plsicox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant, tol = tol, alpha = alpha,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}else if(method==pkg.env$mb.splsdacox){
lst_all_models <- furrr::future_map(lst_inputs, ~mb.splsdacox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, MIN_AUC_INCREASE = MIN_AUC_INCREASE,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,  tol = tol,  alpha = alpha, max.iter = max.iter,
MIN_EPV = MIN_EPV, returnData = F, verbose = verbose), .options = furrr_options(seed = 123))
}else if(method==pkg.env$mb.splsdrcox){
lst_all_models <- furrr::future_map(lst_inputs, ~mb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, MIN_AUC_INCREASE = MIN_AUC_INCREASE,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant, tol = tol, alpha = alpha,
MIN_EPV = MIN_EPV, returnData = F, verbose = verbose), .options = furrr_options(seed = 123))
}
future::plan("sequential")
}else{
if(method==pkg.env$plsicox){
lst_all_models <- purrr::map(lst_inputs, ~plsicox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
MIN_EPV = MIN_EPV, remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant, tol = tol, alpha = alpha,
returnData = F))
}else if(method==pkg.env$splsdacox_mixomics){
lst_all_models <- purrr::map(lst_inputs, ~splsdacox_mixOmics(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
MIN_EPV = MIN_EPV, remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD, tol = tol, alpha = alpha,
returnData = F))
}else if(method==pkg.env$splsdrcox_mixomics){
lst_all_models <- purrr::map(lst_inputs, ~splsdrcox_mixOmics(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD, tol = tol, alpha = alpha,
MIN_EPV = MIN_EPV, returnData = F))
}else if(method==pkg.env$sb.plsicox){
lst_all_models <- purrr::map(lst_inputs, ~sb.plsicox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant, tol = tol,
MIN_EPV = MIN_EPV, returnData = F), .options = furrr_options(seed = 123))
}else if(method==pkg.env$mb.splsdacox){
lst_all_models <- purrr::map(lst_inputs, ~mb.splsdacox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, MIN_AUC_INCREASE = MIN_AUC_INCREASE,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,  tol = tol,  alpha = alpha, max.iter = max.iter,
MIN_EPV = MIN_EPV, returnData = F, verbose = F))
}else if(method==pkg.env$mb.splsdrcox){
lst_all_models <- purrr::map(lst_inputs, ~mb.splsdrcox(X = lst_X_train[[.$run]][[.$fold]],
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, MIN_AUC_INCREASE = MIN_AUC_INCREASE,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant, tol = tol, alpha = alpha,
MIN_EPV = MIN_EPV, returnData = F))
}
