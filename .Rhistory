load_all()
cv.coxen_res$opt.EN.alpha
cv.coxen_res$best_model_info$n.var
load_all()
# run cv.plsicox
cv.coxen_res <- cv.coxEN(X = X_train, Y = Y_train,
EN.alpha.list = seq(0,0.9,0.1),
max.variables = ncol(X_train),
n_run = 1, k_folds = 2,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
w_AIC = 0,  w_c.index = 0, w_AUC = 1, times = NULL,
MIN_AUC_INCREASE = 0.05, MIN_AUC = 0.8, MIN_COMP_TO_CHECK = 3,
pred.attr = "mean", pred.method = "cenROC", fast_mode = F,
MIN_EPV = 5, return_models = F,
PARALLEL = T, verbose = T, seed = 123)
load_all()
# run cv.plsicox
cv.coxen_res <- cv.coxEN(X = X_train, Y = Y_train,
EN.alpha.list = seq(0,0.9,0.1),
max.variables = ncol(X_train),
n_run = 1, k_folds = 2,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
w_AIC = 0,  w_c.index = 0, w_AUC = 1, times = NULL,
MIN_AUC_INCREASE = 0.05, MIN_AUC = 0.8, MIN_COMP_TO_CHECK = 3,
pred.attr = "mean", pred.method = "cenROC", fast_mode = F,
MIN_EPV = 5, return_models = F,
PARALLEL = T, verbose = T, seed = 123)
X = X_train
Y = Y_train
EN.alpha.list = seq(0,0.9,0.1)
max.variables = ncol(X_train)
k_folds = 2
n_run = 1
x.center = T
x.scale = F
y.scale = F
y.center = F
remove_near_zero_variance = T
remove_zero_variance = F
toKeep.zv = NULL
alpha = 0.05
remove_non_significant = F
w_AIC = 0
w_c.index = 0
w_AUC = 1
times = NULL
MIN_COMP_TO_CHECK = 3
MIN_AUC = 0.8
MIN_AUC_INCREASE = 0.05
pred.attr = "mean"
pred.method = "cenROC"
fast_mode = F
return_models = F
MIN_EPV = 5
PARALLEL = T
verbose = T
seed = 123
t1 <- Sys.time()
############
# WARNINGS #
############
#Check evaluator installed:
checkLibraryEvaluator(pred.method)
#### REQUIREMENTS
checkY.colnames(Y)
check.cv.weights(c(w_AIC, w_c.index, w_AUC))
max.variables <- check.ncomp(X, max.variables)
# if(!pred.method %in% c("risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I")){
#   stop_quietly(paste0("pred.method must be one of the following: ", paste0(c("risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I"), collapse = ", ")))
# }
if(!pred.method %in% pkg.env$AUC_evaluators){
stop_quietly(paste0("pred.method must be one of the following: ", paste0(pkg.env$AUC_evaluators, collapse = ", ")))
}
#### MAX PREDICTORS
max.variables <- check.maxPredictors(X, Y, MIN_EPV, max.variables, verbose = verbose)
#### REQUIREMENTS
lst_dnz <- deleteZeroOrNearZeroVariance(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
######
# CV #
######
set.seed(seed)
lst_data <- splitData_Iterations_Folds(X, Y, n_run = n_run, k_folds = k_folds) #FOR TEST
lst_X_train <- lst_data$lst_X_train
lst_Y_train <- lst_data$lst_Y_train
lst_X_test <- lst_data$lst_X_test
lst_Y_test <- lst_data$lst_Y_test
################
# TRAIN MODELS #
################
total_models <- k_folds * n_run * length(EN.alpha.list)
comp_model_lst <- get_HDCOX_models2.0(method = pkg.env$coxEN,
lst_X_train = lst_X_train, lst_Y_train = lst_Y_train,
eta.list = NULL, max.ncomp = NULL, max.variables = max.variables,
EN.alpha.list = EN.alpha.list, n_run = n_run, k_folds = k_folds,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = F, remove_zero_variance = F, toKeep.zv = NULL,
alpha = alpha,
total_models = total_models, MIN_EPV = MIN_EPV,
PARALLEL = PARALLEL, verbose = verbose)
method = pkg.env$coxEN
eta.list = NULL
max.ncomp = NULL
max.variables
remove_near_zero_variance = F
remove_zero_variance = F
toKeep.zv = NULL
comp_model_lst <- list()
fold_list <- list()
run_list <- list()
eta_model_lst <- NULL
info <- NULL # for sPLS
## CHECK METHOD
if(is.null(eta.list) & is.null(EN.alpha.list) & !method %in% c(pkg.env$plsicox, pkg.env$splsdacox_mixomics, pkg.env$splsdrcox_mixomics, pkg.env$sb.plsicox, pkg.env$mb.splsdrcox, pkg.env$mb.splsdacox)){
stop_quietly("Method must be one of 'PLS-ICOX', 'sPLS-DACOX-MixOmics', 'MB.sPLS-DACOX' or 'sPLS-DRCOX-MixOmics' if 'eta.list' and 'EN.alpha.list' is NULL.")
}else if(!is.null(eta.list) & is.null(EN.alpha.list)  & !method %in% c(pkg.env$splsdrcox, pkg.env$sb.splsdrcox)){
stop_quietly("Method must be 'sPLS-DRCOX' if 'eta.list' is not NULL.")
}else if(!is.null(EN.alpha.list) & !method %in% c(pkg.env$coxEN)){
stop_quietly("Method must be 'coxEN' if 'EN.alpha.list' is not NULL.")
}
# if(method==pkg.env$splsdrcox){
#   if(is.null(n_run.mixOmics)){
#     stop_quietly("For method 'sPLS-DRCOX-MixOmics', parameter 'n_run.mixOmics' cannot be NULL.")
#   }
#   if(is.null(k_folds.mixOmics)){
#     stop_quietly("For method 'sPLS-DRCOX-MixOmics', parameter 'k_folds.mixOmics' cannot be NULL.")
#   }
#   if(is.null(test.keepX)){
#     stop_quietly("For method 'sPLS-DRCOX-MixOmics', parameter 'test.keepX' cannot be NULL.")
#   }
# }
pb_text <- "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated remaining time: :eta]"
pb <- progress::progress_bar$new(format = pb_text,
total = total_models,
complete = "=",   # Caracteres de las iteraciones finalizadas
incomplete = "-", # Caracteres de las iteraciones no finalizadas
current = ">",    # Caracter actual
clear = FALSE,    # Si TRUE, borra la barra cuando termine
width = 100)      # Ancho de la barra de progreso
message(paste0("Training all possible models for ", method, "..."))
pb$tick(0)
method %in% c(pkg.env$coxEN)
lst_inputs <- list()
lst_names = NULL
cont = 1
for(i in 1:length(EN.alpha.list)){
for(r in 1:n_run){
for(f in 1:k_folds){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$alpha_index = i
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(i, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
PARALLEL
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F), .options = furrr_options(seed = 123))
coxEN
coxEN(X = data.matrix(lst_X_train$run1$Fold1),
Y = data.matrix(lst_Y_train$run1$Fold1),
EN.alpha = EN.alpha.list[[1]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F)
alpha_index
lst_inputs$`1_1_1`$alpha_index
lst_inputs$`10_1_2`
EN.alpha.list
coxEN(X = data.matrix(lst_X_train$run1$Fold2),
Y = data.matrix(lst_Y_train$run1$Fold2),
EN.alpha = EN.alpha.list[[1]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F)
coxEN(X = data.matrix(lst_X_train$run2$Fold2),
Y = data.matrix(lst_Y_train$run2$Fold2),
EN.alpha = EN.alpha.list[[1]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F)
coxEN(X = data.matrix(lst_X_train$run1$Fold2),
Y = data.matrix(lst_Y_train$run1$Fold2),
EN.alpha = EN.alpha.list[[1]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F)
coxEN(X = data.matrix(lst_X_train$run1$Fold2),
Y = data.matrix(lst_Y_train$run1$Fold2),
EN.alpha = EN.alpha.list[[2]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F)
coxEN(X = data.matrix(lst_X_train$run1$Fold2),
Y = data.matrix(lst_Y_train$run1$Fold2),
EN.alpha = EN.alpha.list[[9]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F)
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F), .options = furrr_options(seed = 123))
lst_inputs[[1]]$alpha_index
#test with for:
for(i in lst_inputs){
coxEN(X = data.matrix(lst_X_train[[lst_inputs[[1]]$run]][[lst_inputs[[1]]$fold]]),
Y = data.matrix(lst_Y_train[[lst_inputs[[1]]$run]][[lst_inputs[[1]]$fold]]),
EN.alpha = EN.alpha.list[[lst_inputs[[1]]$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F)
}
lst_all_models <- purrr::map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F))
lst_all_models$`1_1_1`$n.var
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F))
furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F))
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F), .options = furrr_options(seed = 123))
lst_all_models$`1_1_1`$EN.alpha
load_all()
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F), .options = furrr_options(seed = 123))
#test with for:
for(i in lst_inputs){
coxEN(X = data.matrix(lst_X_train[[lst_inputs[[1]]$run]][[lst_inputs[[1]]$fold]]),
Y = data.matrix(lst_Y_train[[lst_inputs[[1]]$run]][[lst_inputs[[1]]$fold]]),
EN.alpha = EN.alpha.list[[lst_inputs[[1]]$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F)
}
max.variables
check(n_cores)
n_cores
coxEN
check()
comp_model_lst <- get_HDCOX_models2.0(method = pkg.env$coxEN,
lst_X_train = lst_X_train, lst_Y_train = lst_Y_train,
eta.list = NULL, max.ncomp = NULL, max.variables = max.variables,
EN.alpha.list = EN.alpha.list, n_run = n_run, k_folds = k_folds,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = F, remove_zero_variance = F, toKeep.zv = NULL,
alpha = alpha,
total_models = total_models, MIN_EPV = MIN_EPV,
PARALLEL = PARALLEL, verbose = verbose)
PARALLEL
PARALLEL = F
comp_model_lst <- get_HDCOX_models2.0(method = pkg.env$coxEN,
lst_X_train = lst_X_train, lst_Y_train = lst_Y_train,
eta.list = NULL, max.ncomp = NULL, max.variables = max.variables,
EN.alpha.list = EN.alpha.list, n_run = n_run, k_folds = k_folds,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = F, remove_zero_variance = F, toKeep.zv = NULL,
alpha = alpha,
total_models = total_models, MIN_EPV = MIN_EPV,
PARALLEL = PARALLEL, verbose = verbose)
PARALLEL = T
comp_model_lst <- get_HDCOX_models2.0(method = pkg.env$coxEN,
lst_X_train = lst_X_train, lst_Y_train = lst_Y_train,
eta.list = NULL, max.ncomp = NULL, max.variables = max.variables,
EN.alpha.list = EN.alpha.list, n_run = n_run, k_folds = k_folds,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = F, remove_zero_variance = F, toKeep.zv = NULL,
alpha = alpha,
total_models = total_models, MIN_EPV = MIN_EPV,
PARALLEL = PARALLEL, verbose = verbose)
install.packages("furrr")
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F), .options = furrr_options(seed = 123))
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F), .options = furrr_options(seed = 123))
warnings()
lst_all_models <- purrr::map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F))
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F), .options = furrr_options(seed = 123))
workers
n_cores
n_cores = 1
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
if(method==pkg.env$coxEN){
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F), .options = furrr_options(seed = 123))
#test with for:
# for(i in lst_inputs){
#   coxEN(X = data.matrix(lst_X_train[[lst_inputs[[1]]$run]][[lst_inputs[[1]]$fold]]),
#         Y = data.matrix(lst_Y_train[[lst_inputs[[1]]$run]][[lst_inputs[[1]]$fold]]),
#         EN.alpha = EN.alpha.list[[lst_inputs[[1]]$alpha_index]],
#         max.variables = max.variables,
#         x.center = x.center, x.scale = x.scale,
#         y.center = y.center, y.scale = y.scale,
#         remove_non_significant = remove_non_significant,
#         remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
#         alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
#         returnData = F)
# }
}
n_cores = 2
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
if(method==pkg.env$coxEN){
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F), .options = furrr_options(seed = 123))
#test with for:
# for(i in lst_inputs){
#   coxEN(X = data.matrix(lst_X_train[[lst_inputs[[1]]$run]][[lst_inputs[[1]]$fold]]),
#         Y = data.matrix(lst_Y_train[[lst_inputs[[1]]$run]][[lst_inputs[[1]]$fold]]),
#         EN.alpha = EN.alpha.list[[lst_inputs[[1]]$alpha_index]],
#         max.variables = max.variables,
#         x.center = x.center, x.scale = x.scale,
#         y.center = y.center, y.scale = y.scale,
#         remove_non_significant = remove_non_significant,
#         remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
#         alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
#         returnData = F)
# }
}
load_all()
if(method==pkg.env$coxEN){
lst_all_models <- furrr::future_map(lst_inputs, ~coxEN(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
EN.alpha = EN.alpha.list[[.$alpha_index]],
max.variables = max.variables,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
returnData = F), .options = furrr_options(seed = 123))
#test with for:
# for(i in lst_inputs){
#   coxEN(X = data.matrix(lst_X_train[[lst_inputs[[1]]$run]][[lst_inputs[[1]]$fold]]),
#         Y = data.matrix(lst_Y_train[[lst_inputs[[1]]$run]][[lst_inputs[[1]]$fold]]),
#         EN.alpha = EN.alpha.list[[lst_inputs[[1]]$alpha_index]],
#         max.variables = max.variables,
#         x.center = x.center, x.scale = x.scale,
#         y.center = y.center, y.scale = y.scale,
#         remove_non_significant = remove_non_significant,
#         remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
#         alpha = alpha, MIN_EPV = MIN_EPV, verbose = verbose,
#         returnData = F)
# }
}
