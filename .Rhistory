lst_models$`sPLS-DRCOX`$survival_model$fit
lst_models = lst_models
Y_test = Y_test
times
pred.method
#Check at least two events in total
checkAtLeastTwoEvents(X_test, Y_test)
#Check evaluator installed:
checkLibraryEvaluator(pred.method)
if(all(is.null(lst_models))){
stop("List of model is NULL")
}
if(!pred.attr %in% c("mean", "median")){
stop("pred.attr parameter must be one of: 'mean' or 'median'")
}
t1 <- Sys.time()
if(verbose){
message(paste0("\nEvaluating with ", pred.method, "...\n"))
}
#TEST DATA
if(is.null(times)){
times <- getTimesVector(Y_test, max_time_points)
}
#MULTIBLOCK
if(isa(X_test, "list")){
X_test_ori  <- purrr::map(X_test, ~data.matrix(.))
Y_test  <- Y_test
}else{
X_test_ori  <- data.matrix(X_test)
Y_test  <- Y_test
}
times
#MULTIBLOCK
if(isa(X_test, "list")){
X_test_ori  <- purrr::map(X_test, ~data.matrix(.))
Y_test  <- Y_test
}else{
X_test_ori  <- data.matrix(X_test)
Y_test  <- Y_test
}
#models not NAs
names_lst_models <- unlist(lapply(lst_models, function(x){!all(is.na(x))}))
names_lst_models <- names(names_lst_models)[names_lst_models==T]
lst_models <- lst_models[names_lst_models]
if(progress_bar){
total_models <- length(lst_models)
pb_text <- "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated remaining time: :eta]"
pb <- progress::progress_bar$new(format = pb_text,
total = total_models,
complete = "=",   # Caracteres de las iteraciones finalizadas
incomplete = "-", # Caracteres de las iteraciones no finalizadas
current = ">",    # Caracter actual
clear = FALSE,    # Si TRUE, borra la barra cuando termine
width = 100)      # Ancho de la barra de progreso
pb$tick(0)
}
progress_bar = T
if(progress_bar){
total_models <- length(lst_models)
pb_text <- "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated remaining time: :eta]"
pb <- progress::progress_bar$new(format = pb_text,
total = total_models,
complete = "=",   # Caracteres de las iteraciones finalizadas
incomplete = "-", # Caracteres de las iteraciones no finalizadas
current = ">",    # Caracter actual
clear = FALSE,    # Si TRUE, borra la barra cuando termine
width = 100)      # Ancho de la barra de progreso
pb$tick(0)
}
lst_eval <- list()
#For smoothROC parallel per method
if(PARALLEL & pred.method %in% c(pkg.env$AUC_smoothROCtime_C, pkg.env$AUC_smoothROCtime_I, pkg.env$AUC_survivalROC, pkg.env$AUC_nsROC)){
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_models), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_models), n_cores))
}
lst_eval <- furrr::future_map(lst_models, ~evaluation_list_HDcox(model = ., X_test = X_test, Y_test = Y_test, pred.method = pred.method, pred.attr = pred.attr, times = times, PARALLEL = F, verbose = verbose, progress_bar = progress_bar))
future::plan("sequential")
}else{
lst_eval <- purrr::map(lst_models, ~evaluation_list_HDcox(model = ., X_test = X_test, Y_test = Y_test, pred.method = pred.method, pred.attr = pred.attr, times = times, PARALLEL = F, verbose = verbose, progress_bar = progress_bar))
}
Y
t = 2.81
Y
Y_test
Y_test$time < t
Y_test[Y_test$time < t,]
Y_test[Y_test$time > t,]
Y_test[Y_test$time > times[2],]
Y_test[Y_test$time < times[2],]
Y_test[Y_test$time < times[4],]
Y_test[Y_test$time A times[4],]
Y_test[Y_test$time > times[4],]
model = lst_models$coxEN
PARALLEL = F
t3 <- Sys.time()
#atomic vector
if(all(is.na(model))){
return(list(model_time = NA, comp.time = NA, aic.cox = NA, c_index.cox = NA, lst_AUC_values = NA))
}
#NULL in HDcox object (NA no anymore)
if(all(is.null(model$survival_model))){
return(list(model_time = NA, comp.time = NA, aic.cox = NA, c_index.cox = NA, lst_AUC_values = NA))
}
cox <- model$survival_model$fit
aic.cox <- stats::extractAIC(cox, k=2)[2] #k=2 <- AIC, [2] AIC Value
c_index.cox <- survival::concordance(cox)$concordance
#linear predictors
if(isa(X_test, "list") & !attr(model, "model") %in% pkg.env$multiblock_methods){ #mix between multiblock and all PLS - Special case
which_block = purrr::map(names(X_test), ~length(grep(., m, fixed = F))>0)
names(which_block) <- names(X_test)
X_test_mod <- predict.HDcox(object = model, newdata = X_test[[names(which_block)[which_block==T]]])
}else{
X_test_mod <- predict.HDcox(object = model, newdata = X_test) #all multiblock or all PLS - Ok
}
lp <- getLinealPredictors(cox = cox, data = X_test_mod)
lst_AUC_values <- getAUC_from_LP_2.0(linear.predictors = lp, Y = Y_test, times = times, bestModel = NULL, eval = pred.attr, method = pred.method, PARALLEL = PARALLEL, verbose = verbose)
linear.predictors = lp
Y = Y_test
bestModel = NULL
eval = pred.attr
method = pred.method
# if(!method %in% c("risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I")){
#   stop_quietly(paste0("Method must be one of the following: ", paste0(c("risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I"), collapse = ", ")))
# }
if(!method %in% pkg.env$AUC_evaluators){
stop_quietly(paste0("Method must be one of the following: ", paste0(pkg.env$AUC_evaluators, collapse = ", ")))
}
if(!all(c("time", "event") %in% colnames(Y))){
stop_quietly("Data.frame Y must contain the columns time and event for COX model.")
}
#### TIMES SHOULD BE SOMETHING NOW; BUT IN CASE WILL BE NULL...
if(is.null(times)){
max_time_points = 15
times <- getTimesVector(Y, max_time_points)
}
if(is.null(linear.predictors)){
return(NA)
}else if(!isa(linear.predictors, "list")){
aux = linear.predictors
linear.predictors = NULL
linear.predictors$fit = aux
}else if(!"fit" %in% names(linear.predictors)){
stop_quietly("fit must be a list inside linea predictors object.")
}
#order Y
ids <- names(linear.predictors$fit)[names(linear.predictors$fit) %in% rownames(Y)]
Y <- Y[ids,]
if(method %in% c(pkg.env$AUC_nsROC, pkg.env$AUC_cenROC)){
Y <- data.matrix(Y)
}
AUC = NULL #area under the curve for each timepoint
out = NULL
method == pkg.env$AUC_cenROC
#https://cran.r-project.org/web/packages/cenROC/
#needs at least 2 events per time and time can not be day 0
#Y is a matrix
times.vector <- timesAsumption_AUC_Eval(Y, times, method = method)
times.vector
times_run <- times.aux
times.aux <- times #times[times.vector]
times_run <- times.aux
out <- purrr::map(times_run, ~cenROC_tryCatch(Y = Y[,"time"], censor = Y[,"event"], M = linear.predictors$fit,
t = ., method = "tra", ktype  ="normal", alpha = 0.05, plot = F, verbose = verbose)) #problems in simulated data
Y[,"time"]
M = linear.predictors$fit
M
method = "tra"
ktype  ="normal"
alpha = 0.05
plot = F
Y
times_run
Y = Y[,"time"]
censor = Y[,"event"]
Y_test
Y
censor = Y_test$event
M = linear.predictors$fit
plot = F
alpha = 0.05
ktype  ="normal"
method = "tra"
times
cenROC(Y = Y, censor = censor, M = M,
t = 0, method = method, ktype = ktype, alpha = alpha, plot = plot)
cenROC(Y = Y, censor = censor, M = M,
t = times[1], method = method, ktype = ktype, alpha = alpha, plot = plot)
invisible(utils::capture.output(out <- tryCatch(
# Specifying expression
expr = {
# cenROC::cenROC(Y = Y, censor = censor, M = M,
#                t = t, method = method, ktype = ktype, alpha = alpha, plot = plot)
#our function #extracted from GitHub
cenROC(Y = Y, censor = censor, M = M,
t = t, method = method, ktype = ktype, alpha = alpha, plot = plot)
},
# Specifying error message
error = function(e){
message(paste0(e$message, " for time ", t, " and method '",pkg.env$AUC_cenROC,"'"))
NA
},
# warning
warning = function(w){
# message(paste0("Problem in time: ", t))
# message(paste0("Message: ", w$message))
NA
}
)))
cenROC(Y = Y, censor = censor, M = M,
t = t, method = method, ktype = ktype, alpha = alpha, plot = plot)
?bw.SJ
Y
M
table(M)
linear.predictors
cox
invisible(utils::capture.output(out <- tryCatch(
# Specifying expression
expr = {
# cenROC::cenROC(Y = Y, censor = censor, M = M,
#                t = t, method = method, ktype = ktype, alpha = alpha, plot = plot)
#our function #extracted from GitHub
cenROC(Y = Y, censor = censor, M = M,
t = t, method = method, ktype = ktype, alpha = alpha, plot = plot)
},
# Specifying error message
error = function(e){
message(paste0(e$message, " for time ", t, " and method '",pkg.env$AUC_cenROC,"'"))
NA
},
# warning
warning = function(w){
# message(paste0("Problem in time: ", t))
# message(paste0("Message: ", w$message))
NA
}
)))
eval_results <- purrr::map(lst_evaluations, ~eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test, pred.method = .,
pred.attr = pred.attr, verbose = verbose,
times = times, max_time_points = max_time_points, PARALLEL = PARALLEL))
warnings()
eval_results$cenROC$df
tail(eval_results$cenROC$df)
#Check at least two events in total
checkAtLeastTwoEvents(X_test, Y_test)
#Check evaluator installed:
checkLibraryEvaluator(pred.method)
if(all(is.null(lst_models))){
stop("List of model is NULL")
}
if(!pred.attr %in% c("mean", "median")){
stop("pred.attr parameter must be one of: 'mean' or 'median'")
}
t1 <- Sys.time()
if(verbose){
message(paste0("\nEvaluating with ", pred.method, "...\n"))
}
#TEST DATA
if(is.null(times)){
times <- getTimesVector(Y_test, max_time_points)
}
#MULTIBLOCK
if(isa(X_test, "list")){
X_test_ori  <- purrr::map(X_test, ~data.matrix(.))
Y_test  <- Y_test
}else{
X_test_ori  <- data.matrix(X_test)
Y_test  <- Y_test
}
#models not NAs
names_lst_models <- unlist(lapply(lst_models, function(x){!all(is.na(x))}))
names_lst_models <- names(names_lst_models)[names_lst_models==T]
lst_models <- lst_models[names_lst_models]
if(progress_bar){
total_models <- length(lst_models)
pb_text <- "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated remaining time: :eta]"
pb <- progress::progress_bar$new(format = pb_text,
total = total_models,
complete = "=",   # Caracteres de las iteraciones finalizadas
incomplete = "-", # Caracteres de las iteraciones no finalizadas
current = ">",    # Caracter actual
clear = FALSE,    # Si TRUE, borra la barra cuando termine
width = 100)      # Ancho de la barra de progreso
pb$tick(0)
}
lst_eval <- list()
#For smoothROC parallel per method
if(PARALLEL & pred.method %in% c(pkg.env$AUC_smoothROCtime_C, pkg.env$AUC_smoothROCtime_I, pkg.env$AUC_survivalROC, pkg.env$AUC_nsROC)){
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_models), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_models), n_cores))
}
lst_eval <- furrr::future_map(lst_models, ~evaluation_list_HDcox(model = ., X_test = X_test, Y_test = Y_test, pred.method = pred.method, pred.attr = pred.attr, times = times, PARALLEL = F, verbose = verbose, progress_bar = progress_bar))
future::plan("sequential")
}else{
lst_eval <- purrr::map(lst_models, ~evaluation_list_HDcox(model = ., X_test = X_test, Y_test = Y_test, pred.method = pred.method, pred.attr = pred.attr, times = times, PARALLEL = F, verbose = verbose, progress_bar = progress_bar))
}
names(lst_eval) <- names(lst_models)
lst_AUC <- list()
df <- NULL
names(lst_eval)
m = "cox"
lst_AUC[[m]] <- lst_eval[[m]]$lst_AUC_values
lst_AUC[[m]]
#if AUC_values is NA, we cannot access to lst_AUC_values$AUC.vector
if(!all(is.na(lst_eval[[m]]$lst_AUC_values))){
df <- rbind(df, c(m, lst_eval[[m]]$model_time, lst_eval[[m]]$comp.time, lst_eval[[m]]$aic.cox, lst_eval[[m]]$c_index.cox, lst_eval[[m]]$lst_AUC_values$AUC.vector))
}else{
df <- rbind(df, c(m, lst_eval[[m]]$model_time, lst_eval[[m]]$comp.time, lst_eval[[m]]$aic.cox, lst_eval[[m]]$c_index.cox, rep(NA, length(times))))
}
df <- as.data.frame(df)
df
lst_AUC <- list()
df <- NULL
for(m in names(lst_eval)){
lst_AUC[[m]] <- lst_eval[[m]]$lst_AUC_values
#if AUC_values is NA, we cannot access to lst_AUC_values$AUC.vector
if(!all(is.na(lst_eval[[m]]$lst_AUC_values))){
df <- rbind(df, c(m, lst_eval[[m]]$model_time, lst_eval[[m]]$comp.time, lst_eval[[m]]$aic.cox, lst_eval[[m]]$c_index.cox, lst_eval[[m]]$lst_AUC_values$AUC.vector))
}else{
df <- rbind(df, c(m, lst_eval[[m]]$model_time, lst_eval[[m]]$comp.time, lst_eval[[m]]$aic.cox, lst_eval[[m]]$c_index.cox, rep(NA, length(times))))
}
df <- as.data.frame(df)
}
df
final_times <- times #all the same
if(is.null(df) || (ncol(df) != 5+length(final_times) & all(is.na(df[,2])))){
df <- as.data.frame(matrix(data = NA, nrow = length(names_lst_models), ncol = 5+length(final_times)))
df[,1] <- names_lst_models
}
if(all(is.na(df[,2])) & ncol(df) < (5+length(final_times))){
colnames(df) <- c("method", "training.time","evaluating.time", "AIC", "c.index", "AUC")
df <- as.data.frame(df)
new_df <- tidyr::pivot_longer(df, cols = starts_with("time_"), names_to = "time", values_to = "AUC",)
new_df$time <- factor(new_df$time, levels = unique(new_df$time))
}else{
colnames(df) <- c("method", "training.time","evaluating.time", "AIC", "c.index", paste0("time_",final_times))
df <- as.data.frame(df)
df$method <- factor(df$method, levels = unique(df$method))
df[,!colnames(df) %in% "method"] <- apply(df[,!colnames(df) %in% "method"], 2, as.numeric)
new_df <- tidyr::pivot_longer(df, cols = starts_with("time_"), names_to = "time", values_to = "AUC",)
new_df$time <- factor(new_df$time, levels = unique(new_df$time))
}
t2 <- Sys.time()
time <- difftime(t2,t1,units = "mins")
new_df
metho
method
#Look for problems
#Could be cause by "sample is too sparse to find TD for time 3.25 and method 'cenROC'"
#Means SAMPLE have only two values for linear predictors (only one variable and its binary), so AUC cannot be compute for that model.
for(m in unique(new_df$method)){
if(all(is.na(new_df[new_df$method==m,]$AUC))){
message(paste0("Problems computing AUC metric for ", pred.method, " and model ", m))
}
#Look for problems
#Could be cause by "sample is too sparse to find TD for time 3.25 and method 'cenROC'"
#Means SAMPLE have only two values for linear predictors (only one variable and its binary), so AUC cannot be compute for that model.
for(m in unique(new_df$method)){
if(all(is.na(new_df[new_df$method==m,]$AUC))){
message(paste0("Problems computing AUC metric for '", pred.method, "' evaluator and model '", m, "'"))
}
devtools::load_all(".")
eval_results <- purrr::map(lst_evaluations, ~eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test, pred.method = .,
pred.attr = pred.attr, verbose = verbose,
times = times, max_time_points = max_time_points, PARALLEL = PARALLEL))
devtools::load_all(".")
eval_results <- purrr::map(lst_evaluations, ~eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test, pred.method = .,
pred.attr = pred.attr, verbose = verbose,
times = times, max_time_points = max_time_points, PARALLEL = PARALLEL))
verbose
devtools::load_all(".")
eval_results <- purrr::map(lst_evaluations, ~eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test, pred.method = .,
pred.attr = pred.attr, verbose = verbose,
times = times, max_time_points = max_time_points, PARALLEL = PARALLEL))
devtools::load_all(".")
eval_results <- purrr::map(lst_evaluations, ~eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test, pred.method = .,
pred.attr = pred.attr, verbose = verbose,
times = times, max_time_points = max_time_points, PARALLEL = PARALLEL))
verbose
verbose = F
eval_results <- purrr::map(lst_evaluations, ~eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test, pred.method = .,
pred.attr = pred.attr, verbose = verbose,
times = times, max_time_points = max_time_points, PARALLEL = PARALLEL))
warnings()
#### ### ## #
# EVALPLOTS #
#### ### ## #
evaluation_folder = paste0(folder, "evaluation_plot/")
dir.create(evaluation_folder)
lst_ggp <- plot_evaluation.list(eval_results)
lst_ggp
lst_ggp$cenROC$lst_plots$lineplot.mean
time_folder = paste0(folder, "time_plot/")
dir.create(time_folder)
ggp_time <- plot_time.list(lst_models_full)
save_ggplot.svg(ggp_time, folder = time_folder, name = "time.svg", wide = T)
gc()
## ## ## ## ## ##
## FOREST PLOTS #
## ## ## ## ## ##
forest_folder = paste0(folder, "forest_plot/")
dir.create(forest_folder)
lst_forest_plot <- plot_forest.list(lst_models = lst_models)
save_ggplot_lst.svg(lst_plots = lst_forest_plot, folder = forest_folder, wide = T, prefix = "forest_")
gc()
## ## ## ## ## ## ## ## #
# PH - DIAGNOSTIC PLOTS #
## ## ## ## ## ## ## ## #
ph_folder = paste0(folder, "ph_plot/")
dir.create(ph_folder)
lst_ph_ggplot <- plot_proportionalHazard.list(lst_models = lst_models)
save_ggplot_lst.svg(lst_plots = lst_ph_ggplot, folder = ph_folder, wide = T, prefix = "ph_")
gc()
## ## ## ## ## ##
# DENSITY PLOTS #
## ## ## ## ## ##
density_folder = paste0(folder, "density_plot/")
dir.create(density_folder)
density.plots.lp <- plot_cox.event.list(lst_models, type = "lp")
density.plots.risk <- plot_cox.event.list(lst_models, type = "risk")
density.plots.expected <- plot_cox.event.list(lst_models, type = "expected")
density.plots.survival <- plot_cox.event.list(lst_models, type = "survival")
for(cn in names(density.plots.lp)){
if(is.null(density.plots.lp[[cn]])){
next
}
if(cn %in% names(density.plots.lp) && !is.na(density.plots.lp[[cn]])){
save_ggplot.svg(plot = density.plots.lp[[cn]]$plot.density, folder = density_folder, name = paste0("pred.lp_density_",cn))
save_ggplot.svg(plot = density.plots.lp[[cn]]$plot.histogram, folder = density_folder, name = paste0("pred.lp_histogram_",cn))
}
if(cn %in% names(density.plots.risk) && !is.na(density.plots.risk[[cn]])){
save_ggplot.svg(plot = density.plots.risk[[cn]]$plot.density, folder = density_folder, name = paste0("pred.risk_density_",cn))
save_ggplot.svg(plot = density.plots.risk[[cn]]$plot.histogram, folder = density_folder, name = paste0("pred.risk_histogram_",cn))
}
if(cn %in% names(density.plots.expected) && !is.na(density.plots.expected[[cn]])){
save_ggplot.svg(plot = density.plots.expected[[cn]]$plot.density, folder = density_folder, name = paste0("pred.expected_density_",cn))
save_ggplot.svg(plot = density.plots.expected[[cn]]$plot.histogram, folder = density_folder, name = paste0("pred.expected_histogram_",cn))
}
if(cn %in% names(density.plots.survival) && !is.na(density.plots.survival[[cn]])){
save_ggplot.svg(plot = density.plots.survival[[cn]]$plot.density, folder = density_folder, name = paste0("pred.expected_density_",cn))
save_ggplot.svg(plot = density.plots.survival[[cn]]$plot.histogram, folder = density_folder, name = paste0("pred.expected_histogram_",cn))
}
psbeta_folder = paste0(folder, "pbetacox_plot/")
dir.create(psbeta_folder)
ggp.simulated_beta <- plot_pseudobeta.list(lst_models = lst_models_pls,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, top = 20,
show_percentage = T, size_percentage = 3, verbose = F)
save_ggplot_lst.svg(lst_plots = ggp.simulated_beta, object_name = "plot", folder = psbeta_folder, wide = T, prefix = "pbetacox_")
ggp.simulated_beta$`sPLS-DRCOX`$plot
km_folder = paste0(folder, "km_train_plot/")
dir.create(km_folder)
LST_KM_RES_LP <- getAutoKM.list(type = "LP",
lst_models = lst_models,
comp = 1:10,
top = 20,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05)
LST_KM_RES_COMP <- getAutoKM.list(type = "COMP",
lst_models = lst_models,
comp = 1:10,
top = 20,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05)
LST_KM_RES_VAR <- getAutoKM.list(type = "VAR",
lst_models = lst_models,
comp = 1:10,
top = 20,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05)
km_folder = paste0(folder, "km_test_plot/")
dir.create(km_folder)
lst_cutoff <- getCutoffAutoKM.list(LST_KM_RES_LP)
LST_KM_TEST_LP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "LP",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
lst_cutoff <- getCutoffAutoKM.list(LST_KM_RES_COMP)
LST_KM_TEST_COMP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "COMP",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
lst_cutoff <- getCutoffAutoKM.list(LST_KM_RES_VAR)
LST_KM_TEST_VAR <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "VAR",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
LST_KM_TEST_VAR$`sPLS-DRCOX`$age_at_initial_pathologic_diagnosis
devtools::load_all(".")
check()
library(devtools)
check()
devtools::load_all(".")
remove.packages("HDcox")
