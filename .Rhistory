df <- NULL
lst_AUC <- list()
df <- NULL
for(m in names(lst_eval)){
lst_AUC[[m]] <- lst_eval[[m]]$lst_AUC_values
#if AUC_values is NA, we cannot access to lst_AUC_values$AUC.vector
if(!all(is.na(lst_eval[[m]]$lst_AUC_values))){
df <- rbind(df, c(m, lst_eval[[m]]$model_time, lst_eval[[m]]$comp.time, lst_eval[[m]]$aic.cox, lst_eval[[m]]$c_index.cox, lst_eval[[m]]$lst_AUC_values$AUC.vector))
}else{
df <- rbind(df, c(m, lst_eval[[m]]$model_time, lst_eval[[m]]$comp.time, lst_eval[[m]]$aic.cox, lst_eval[[m]]$c_index.cox, rep(NA, length(times))))
}
df <- as.data.frame(df)
}
final_times <- times #all the same
if(is.null(df) || (ncol(df) != 5+length(final_times) & all(is.na(df[,2])))){
df <- as.data.frame(matrix(data = NA, nrow = length(names_lst_models), ncol = 5+length(final_times)))
df[,1] <- names_lst_models
}
if(all(is.na(df[,2])) & ncol(df) < (5+length(final_times))){
colnames(df) <- c("method", "training.time","evaluating.time", "AIC", "c.index", "AUC")
df <- as.data.frame(df)
new_df <- tidyr::pivot_longer(df, cols = starts_with("time_"), names_to = "time", values_to = "AUC",)
new_df$time <- factor(new_df$time, levels = unique(new_df$time))
}else{
colnames(df) <- c("method", "training.time","evaluating.time", "AIC", "c.index", paste0("time_",final_times))
df <- as.data.frame(df)
df$method <- factor(df$method, levels = unique(df$method))
df[,!colnames(df) %in% "method"] <- apply(df[,!colnames(df) %in% "method"], 2, as.numeric)
new_df <- tidyr::pivot_longer(df, cols = starts_with("time_"), names_to = "time", values_to = "AUC",)
new_df$time <- factor(new_df$time, levels = unique(new_df$time))
}
t2 <- Sys.time()
time <- difftime(t2,t1,units = "mins")
if(verbose){
message(paste0("\nTime for ", pred.method, ": ", as.character(round(time, 5))))
}
devtools::load_all(".")
lst_evaluations
PARALLEL
PARALLEL = T
lst_evaluations = "cenROC"
lst_evaluations
names(lst_evaluations) <- "cenROC"
eval_results <- purrr::map(lst_evaluations, ~eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test, pred.method = .,
pred.attr = pred.attr, verbose = verbose,
times = times, max_time_points = max_time_points, PARALLEL = PARALLEL))
eval_results$cenROC$df
lst_ggp <- plot_evaluation.list(eval_results)
lst_ggp$cenROC$lst_plots$lineplot.mean
names(lst_ggp)
eval_name = "cenROC"
getwd()
openxlsx::write.xlsx(x = lst_ggp[[eval_name]]$df, file = paste0("results_", eval_name, ".xlsx"))
write.csv(x = lst_ggp[[eval_name]]$df, file = paste0("results_", eval_name, ".csv"), row.names = FALSE, quote = F)
names(lst_ggp[[eval_name]]$lst_plot_comparisons
)
evaluation_folder
folder
save_ggplot_lst.svg(lst_plots = lst_ggp, object_name = "lineplot.mean", wide = T, prefix = "eval_")
purrr::map(lst_ggp, ~save_ggplot_lst.svg(lst_plots = .$lst_plots, object_name = "lineplot.mean", folder = evaluation_folder, wide = T, prefix = "eval_"))
purrr::map(lst_ggp, ~save_ggplot_lst.svg(lst_plots = .$lst_plots, object_name = "lineplot.mean", wide = T, prefix = "eval_"))
lst_ggp$cenROC$lst_plots$lineplot
purrr::map(lst_ggp, ~save_ggplot_lst.svg(lst_plots = ., object_name = "lst_plots", wide = T, prefix = "eval_"))
eval_name
names(lst_ggp[[eval_name]]$lst_plots)
eval_name
comp_name
comp_name = names(lst_ggp[[eval_name]]$lst_plots)[1]
comp_name
#save_ggplot.svg(plot = lst_ggp[[eval_name]]$comparisons[[comp_name]], name = paste0("comparison_", eval_name, "_", comp_name), folder = evaluation_folder, wide = T)
save_ggplot.svg(plot = lst_ggp[[eval_name]]$lst_plots[[comp_name]], name = paste0(eval_name, "_", comp_name), wide = T)
LST_KM_RES_LP <- getAutoKM.list(type = "LP",
lst_models = lst_models,
comp = 1:10,
top = 20,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05)
LST_KM_RES_LP$cox$LST_PLOTS $LP
lst_cutoff <- getCutoffAutoKM.list(LST_KM_RES_LP)
lst_cutoff
LST_KM_TEST_LP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "LP",
BREAKTIME = NULL, n.breaks = 20,
lst_cutoff = lst_cutoff)
LST_KM_TEST_LP$cox
LST_KM_TEST_LP$`sPLS-DRCOX-MixOmics`
LST_KM_TEST_LP$cox
m = "cox"
save_ggplot.svg(lst_plots = LST_KM_TEST_LP[[m]], object_name = NULL, wide = T, prefix = paste0("km_test_", m, "_"))
save_ggplot.svg(lst_plots = LST_KM_TEST_LP[[m]], wide = T, prefix = paste0("km_test_", m, "_"))
save_ggplot.svg(plot = LST_KM_TEST_LP[[m]], wide = T, name = paste0("km_test_", m))
plot = LST_KM_TEST_LP[[m]]
class(plot)
wide = T
name = paste0("km_test_", m)
name
class(plot[1]) %in% "ggsurvplot"
class(plot)[1] %in% "ggsurvplot"
devtools::load_all(".")
save_ggplot.svg(plot = LST_KM_TEST_LP[[m]], wide = T, name = paste0("km_test_", m))
devtools::load_all(".")
LST_KM_TEST_LP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "LP",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
LST_KM_TEST_LP$cox
lst_cutoff <- getCutoffAutoKM.list(LST_KM_RES_COMP)
LST_KM_TEST_LP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "COMP",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
LST_KM_TEST_LP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "LP",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
lst_cutoff <- getCutoffAutoKM.list(LST_KM_RES_LP)
LST_KM_TEST_LP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "LP",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
lst_cutoff <- getCutoffAutoKM.list(LST_KM_RES_COMP)
LST_KM_TEST_COMP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "COMP",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
LST_KM_TEST_COMP$`PLS-ICOX`$comp_1
LST_KM_TEST_COMP$`sPLS-DRCOX-MixOmics`$comp_2
names(LST_KM_TEST_COMP)
m = "sPLS-DRCOX-MixOmics"
save_ggplot_lst.svg(lst_plots = LST_KM_TEST_COMP[[m]]$LST_PLOTS, object_name = NULL, wide = T, prefix = paste0("km_", m, "_"))
m %in% names(LST_KM_TEST_COMP)
save_ggplot_lst.svg(lst_plots = LST_KM_TEST_COMP[[m]], object_name = NULL, wide = T, prefix = paste0("km_", m, "_"))
lst_cutoff <- getCutoffAutoKM.list(LST_KM_RES_VAR)
lst_cutoff
LST_KM_TEST_VAR <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "VAR",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
LST_KM_TEST_VAR$`PLS-ICOX`$nodes
LST_KM_TEST_VAR$`PLS-ICOX`$age
LST_KM_TEST_VAR$`PLS-ICOX`$grade
LST_KM_TEST_VAR$`PLS-ICOX`$pgr
LST_KM_TEST_VAR$`PLS-ICOX`$year
save_ggplot_lst.svg(lst_plots = LST_KM_TEST_VAR[[m]], object_name = NULL, wide = T, prefix = paste0("km_", m, "_"))
library(RColorConesa) #from GitHub #devtools #usethis and get install.packages('hrbrthemes', repos='http://cran.us.r-project.org')
#Load ggplot theme
loadGgplotTheme <- function(path){
file <- paste0(path,"ggplot_theme.R")
source(file, echo = F)
}
path <- "D:/Pedro/Mega/Doctorado/Otros proyectos/"
loadGgplotTheme(path)
load("D:/Pedro/Mega/Doctorado/Otros proyectos/data_GSE49997_clinical.RData")
NAME = "GSE49997_CLINICAL_"
# METHODS
lst_evaluations <- c("survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I", "risksetROC")
names(lst_evaluations) <- lst_evaluations
# Classical
FLAG_COX = T
FLAG_COXSW = T
# hd
FLAG_COXEN = T
FLAG_PLSICOX = T
FLAG_sPLSDRCOX = T
FLAG_sPLSDRCOX_MO = T
FLAG_sPLSDACOX_MO = T
# mo
FLAG_SB.PLSICOX = F
FLAG_FAST.SB.PLSICOX = F
FLAG_SB.sPLSDRCOX = F
FLAG_FAST.SB.sPLSDRCOX = F
FLAG_MB.sPLSDRCOX = F
FLAG_MB.sPLSDACOX = F
# Scale Parameters
x.center = T
x.scale = T
y.center = F
y.scale = F
# Survival Parameters
MIN_EPV = 5
pred.attr = "mean"
# Algorithm Parameters
remove_non_significant = T
remove_non_significant_models = F
remove_near_zero_variance = T
remove_zero_variance = F
toKeep.zv = NULL
alpha = 0.05
returnData = T
verbose = T
PARALLEL = T
# cox
FORCE = T
# SW
boostDeletion = F
BACKWARDS = T
initialModel = "NULL"
toKeep.sw = NULL
alpha_ENT = 0.1
alpha_OUT = 0.15
alpha_PH  = 0.05
check_PH = F
# coxEN
EN.alpha.list = seq(0,1,0.1)
# PLS
max.ncomp = 10
max.iter = 500
# Cross Validation Parameters
times = NULL
return_models = F
seed = 123
# Weights Parameters
w_AIC = 0
w_c.index = 0
w_AUC = 1
# sPLS-DR-cox
eta.list = seq(0,0.9,0.25)
# mixOmics
vector = NULL
MIN_NVAR = 10
MAX_NVAR = 1000
n.cut_points = 5
EVAL_METHOD = "cenROC"
# Eval stop detection
MIN_AUC_INCREASE = 0.01 # 1%
MIN_AUC = 0.75 # 75%
MIN_COMP_TO_CHECK = 3
# Model Lists
lst_models_full <- NULL
lst_models <- NULL
lst_models_pls <- NULL
# Evaluation multiple models
max_time_points = 15
#### ### ### #### ### ### ###
#Cross Validation Parameters #
#### ### ### ### ### #### ###
n_run = 5
k_folds = 10
fast_mode = F
pred.method = "cenROC"
todaydate <- format(Sys.time(), '%Y-%m-%d')
txt_folder <- paste0(NAME,ifelse(fast_mode, "FAST_", "COMPLETE_"), pred.method, "_runs_", n_run, "_folds_", k_folds)
folder <- paste0(txt_folder,"_",todaydate,"/")
#setwd("D:/Pedro/Mega/Doctorado/Otros proyectos/plsicox/results")
dir.create(folder)
#### ### ### ### ###
#Set Train and Test#
#### ### ### ### ###
set.seed(123)
index_train <- caret::createDataPartition(Y$event,
p = .7, #70% train
list = FALSE,
times = 1)
X_train <- X[index_train,]
Y_train <- Y[index_train,]
X_test <- X[-index_train,]
Y_test <- Y[-index_train,]
### ###
# COX #
### ###
if(FLAG_COX){
aux_folder = paste0(folder, "cox_plot/")
dir.create(aux_folder)
best_cox <- cox(X = X_train, Y = Y_train,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha,
MIN_EPV = MIN_EPV,
FORCE = FORCE,
returnData = returnData,
verbose = verbose)
save(list = c("best_cox"), file = paste0(aux_folder, "cox.RData"))
gc()
lst_models_full[[best_cox$class]] = best_cox
lst_models[[best_cox$class]] = best_cox
}
aux_folder = paste0(folder, "plsicox_plot/")
dir.create(aux_folder)
cv.plsicox_res <- cv.plsicox(X = X_train, Y = Y_train,
max.ncomp = max.ncomp,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL,
verbose = verbose)
devtools::load_all(".")
cv.plsicox_res <- cv.plsicox(X = X_train, Y = Y_train,
max.ncomp = max.ncomp,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL,
verbose = verbose)
X = X_train
Y = Y_train
t1 <- Sys.time()
#### ### ###
# WARNINGS #
#### ### ###
#Check evaluator installed:
checkLibraryEvaluator(pred.method)
#### REQUIREMENTS
checkY.colnames(Y)
check.cv.weights(c(w_AIC, w_c.index, w_AUC))
max.ncomp <- check.ncomp(X, max.ncomp)
# if(!pred.method %in% c("risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I")){
#   stop_quietly(paste0("pred.method must be one of the following: ", paste0(c("risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I"), collapse = ", ")))
# }
if(!pred.method %in% pkg.env$AUC_evaluators){
stop_quietly(paste0("pred.method must be one of the following: ", paste0(pkg.env$AUC_evaluators, collapse = ", ")))
}
#### MAX PREDICTORS
max.ncomp <- check.maxPredictors(X, Y, MIN_EPV, max.ncomp)
#### REQUIREMENTS
lst_dnz <- deleteZeroOrNearZeroVariance(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
#### #
# CV #
#### #
set.seed(seed)
lst_data <- splitData_Iterations_Folds(X, Y, n_run = n_run, k_folds = k_folds) #FOR TEST
lst_X_train <- lst_data$lst_X_train
lst_Y_train <- lst_data$lst_Y_train
lst_X_test <- lst_data$lst_X_test
lst_Y_test <- lst_data$lst_Y_test
#### ### ### ###
# TRAIN MODELS #
#### ### ### ###
total_models <- 1 * k_folds * n_run #with greatest component we have all of them
comp_model_lst <- get_HDCOX_models2.0(method = pkg.env$plsicox,
lst_X_train = lst_X_train, lst_Y_train = lst_Y_train,
max.ncomp = max.ncomp, eta.list = NULL, EN.alpha.list = NULL, n_run = n_run, k_folds = k_folds,
x.center = x.center, x.scale = x.scale, y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = F, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = remove_non_significant,
total_models = total_models, tol = tol, PARALLEL = PARALLEL, verbose = verbose)
tol
tol = 1e-15
comp_model_lst <- get_HDCOX_models2.0(method = pkg.env$plsicox,
lst_X_train = lst_X_train, lst_Y_train = lst_Y_train,
max.ncomp = max.ncomp, eta.list = NULL, EN.alpha.list = NULL, n_run = n_run, k_folds = k_folds,
x.center = x.center, x.scale = x.scale, y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = F, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = remove_non_significant,
total_models = total_models, tol = tol, PARALLEL = PARALLEL, verbose = verbose)
method = pkg.env$plsicox
eta.list = NULL
EN.alpha.list = NULL
toKeep.zv = NULL
remove_zero_variance = F
remove_near_zero_variance = F
comp_model_lst <- list()
fold_list <- list()
run_list <- list()
eta_model_lst <- NULL
info <- NULL # for sPLS
## CHECK METHOD
if(is.null(eta.list) & is.null(EN.alpha.list) & !method %in% c(pkg.env$plsicox, pkg.env$splsdacox_mixomics, pkg.env$splsdrcox_mixomics, pkg.env$sb.plsicox, pkg.env$mb.splsdrcox, pkg.env$mb.splsdacox)){
stop_quietly("Method must be one of 'PLS-ICOX', 'sPLS-DACOX-MixOmics', 'MB.sPLS-DACOX' or 'sPLS-DRCOX-MixOmics' if 'eta.list' and 'EN.alpha.list' is NULL.")
}else if(!is.null(eta.list) & is.null(EN.alpha.list)  & !method %in% c(pkg.env$splsdrcox, pkg.env$sb.splsdrcox)){
stop_quietly("Method must be 'sPLS-DRCOX' if 'eta.list' is not NULL.")
}else if(!is.null(EN.alpha.list) & !method %in% c(pkg.env$coxEN)){
stop_quietly("Method must be 'coxEN' if 'EN.alpha.list' is not NULL.")
}
# if(method==pkg.env$splsdrcox){
#   if(is.null(n_run.mixOmics)){
#     stop_quietly("For method 'sPLS-DRCOX-MixOmics', parameter 'n_run.mixOmics' cannot be NULL.")
#   }
#   if(is.null(k_folds.mixOmics)){
#     stop_quietly("For method 'sPLS-DRCOX-MixOmics', parameter 'k_folds.mixOmics' cannot be NULL.")
#   }
#   if(is.null(test.keepX)){
#     stop_quietly("For method 'sPLS-DRCOX-MixOmics', parameter 'test.keepX' cannot be NULL.")
#   }
# }
pb_text <- "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated remaining time: :eta]"
pb <- progress::progress_bar$new(format = pb_text,
total = total_models,
complete = "=",   # Caracteres de las iteraciones finalizadas
incomplete = "-", # Caracteres de las iteraciones no finalizadas
current = ">",    # Caracter actual
clear = FALSE,    # Si TRUE, borra la barra cuando termine
width = 100)      # Ancho de la barra de progreso
message(paste0("Training all possible models for ", method, "..."))
pb$tick(0)
#function to compute all models at the same time - just last component
lst_inputs <- list()
cont = 1
lst_names = NULL
for(i in max.ncomp){
for(r in 1:n_run){
for(f in 1:k_folds){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$comp = i
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(i, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
n_cores <- max(future::availableCores() - 1, 1)
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(lst_inputs), n_cores))
}else{
future::plan("multisession", workers = min(length(lst_inputs), n_cores))
}
lst_all_models <- furrr::future_map(lst_inputs, ~plsicox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant, tol = tol,
MIN_EPV = MIN_EPV, returnData = F, verbose = verbose), .options = furrr_options(seed = 123))
lst_all_models <- purrr::map(lst_inputs, ~plsicox(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
MIN_EPV = MIN_EPV, remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant, tol = tol,
returnData = F))
lst_all_models$6_5_10
names(lst_all_models)
## We need to return a list of lists: COMP->REP->FOLDS
comp_model_lst <- list()
for(c in max.ncomp){
run_model_lst <- list()
for(r in 1:n_run){
fold_model_lst <- list()
for(f in 1:k_folds){
name <- paste0(c, "_", r, "_", f)
fold_model_lst[[f]] = lst_all_models[[name]]
}
names(fold_model_lst) <- paste0("fold_",1:k_folds)
run_model_lst[[r]] <- fold_model_lst
}
names(run_model_lst) <- paste0("run_",1:n_run)
comp_model_lst[[c]] <- run_model_lst
}
names(comp_model_lst) <- paste0("comp_",1:max.ncomp)
## We need to fill models from 1:max.ncomp (it uses max.ncomp to fill the others, if it is NULL, method fail!!!)
pb_text <- "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated remaining time: :eta]"
pb <- progress::progress_bar$new(format = pb_text,
total = (max.ncomp-1) * n_run * k_folds,
complete = "=",   # Caracteres de las iteraciones finalizadas
incomplete = "-", # Caracteres de las iteraciones no finalizadas
current = ">",    # Caracter actual
clear = FALSE,    # Si TRUE, borra la barra cuando termine
width = 100)      # Ancho de la barra de progreso
message(paste0("Creating sub-models for ", method, "..."))
pb$tick(0)
for(comp in 1:(max.ncomp-1)){
run_model_lst <- list()
for(r in 1:n_run){
fold_model_lst <- list()
for(f in 1:k_folds){
if(method %in% c(pkg.env$sb.plsicox, pkg.env$mb.splsdrcox, pkg.env$mb.splsdacox)){
fold_model <- getSubModel.mb(model = comp_model_lst[[max.ncomp]][[r]][[f]], comp = comp, remove_non_significant = remove_non_significant)
}else{
fold_model <- getSubModel(model = comp_model_lst[[max.ncomp]][[r]][[f]], comp = comp, remove_non_significant = remove_non_significant)
}
fold_model_lst[[f]] <- fold_model
pb$tick()
}
names(fold_model_lst) <- paste0("fold_",1:k_folds)
run_model_lst[[r]] <- fold_model_lst
}
names(run_model_lst) <- paste0("run_",1:n_run)
comp_model_lst[[comp]] <- run_model_lst
}
comp_model_lst$comp_6$run_5$fold_1$survival_model$fit
devtools::load_all(".")
comp_model_lst <- get_HDCOX_models2.0(method = pkg.env$plsicox,
lst_X_train = lst_X_train, lst_Y_train = lst_Y_train,
max.ncomp = max.ncomp, eta.list = NULL, EN.alpha.list = NULL, n_run = n_run, k_folds = k_folds,
x.center = x.center, x.scale = x.scale, y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = F, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = remove_non_significant,
total_models = total_models, tol = tol, PARALLEL = PARALLEL, verbose = verbose)
