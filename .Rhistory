ggp.simulated_beta_newPat <- plot_pseudobeta_newPatient.list(lst_models = lst_models,
new_observation = new_observation,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, show.betas = T, top = 20)
ggp.simulated_beta_newPat <- plot_pseudobeta_newPatient.list(lst_models = lst_models,
new_observation = new_pat,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, show.betas = T, top = 20)
ggp.simulated_beta_newPat <- plot_pseudobeta_newPatient(model = lst_models[[1]],
new_observation = new_pat,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, show.betas = T, top = 20)
ggp.simulated_beta_newPat <- plot_pseudobeta_newPatient(model = lst_models[[2]],
new_observation = new_pat,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, show.betas = T, top = 20)
ggp.simulated_beta_newPat
ggp.simulated_beta_newPat <- plot_pseudobeta_newPatient(model = lst_models[[3]],
new_observation = new_pat,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, show.betas = T, top = 20)
ggp.simulated_beta_newPat <- plot_pseudobeta_newPatient(model = lst_models[[4]],
new_observation = new_pat,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, show.betas = T, top = 20)
ggp.simulated_beta_newPat <- plot_pseudobeta_newPatient(model = lst_models[[5]],
new_observation = new_pat,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, show.betas = T, top = 20)
model = lst_models[[5]]
model
model = lst_models[[5]]
new_observation = new_pat
error.bar = T
onlySig = T
alpha = 0.05
top = 20
show.betas = T
auto.limits = T
zero.rm = T
if(attr(model, "model") %in% pkg.env$pls_methods){
plot_pseudobeta.newPatient(model = model,
new_observation = new_observation,
error.bar = error.bar,
onlySig = onlySig, alpha = alpha,
zero.rm = zero.rm, top = top,
auto.limits = auto.limits, show.betas = show.betas)
}else if(attr(model, "model") %in% pkg.env$multiblock_methods){
plot_MB.pseudobeta.newPatient(model = model,
new_observation = new_observation,
error.bar = error.bar,
onlySig = onlySig, alpha = alpha,
zero.rm = zero.rm, top = top,
auto.limits = auto.limits, show.betas = show.betas)
}else{
stop("Model not belong to any PLS or MB HDcox methods.")
}
attr(model, "model") %in% pkg.env$pls_methods
auto.limits
#DFCALLS
lp <- lp.min <- lp.max <- NULL
#plot
ggp.simulated_beta <- plot_pseudobeta(model = model, error.bar = error.bar, onlySig = onlySig,
alpha = alpha, zero.rm = zero.rm, auto.limits = auto.limits, top = top)
coefficients <- ggp.simulated_beta$beta
coeff.min <- NULL
coeff.max <- NULL
if(error.bar){
coeff.min <- ggp.simulated_beta$sd.min
coeff.max <- ggp.simulated_beta$sd.max
}
#norm patient
new_observation <- new_observation[,names(model$X$x.mean),drop=F]
if(!is.null(model$X$x.mean) & !is.null(model$X$x.sd)){
norm_patient <- scale(new_observation, center = model$X$x.mean, scale = model$X$x.sd)
}else if(!is.null(model$X$x.mean)){
norm_patient <- scale(new_observation, center = model$X$x.mean, scale = F)
}else if(!is.null(model$X$x.sd)){
norm_patient <- scale(new_observation, center = F, scale = model$X$x.sd)
}else{
norm_patient <- new_observation
}
#lp.new_observation_manual <- norm_patient[,rownames(coefficients)] %*% coefficients #predict lp
lp.new_observation_variable <- as.data.frame(norm_patient[,rownames(coefficients)] * coefficients$value) #predict terms
coefficients
norm_patient
coefficients
onlySig
onlySig = F
#plot
ggp.simulated_beta <- plot_pseudobeta(model = model, error.bar = error.bar, onlySig = onlySig,
alpha = alpha, zero.rm = zero.rm, auto.limits = auto.limits, top = top)
coefficients <- ggp.simulated_beta$beta
coefficients
onlySig = T
coefficients <- ggp.simulated_beta$beta
coefficients
#plot
ggp.simulated_beta <- plot_pseudobeta(model = model, error.bar = error.bar, onlySig = onlySig,
alpha = alpha, zero.rm = zero.rm, auto.limits = auto.limits, top = top)
coefficients <- ggp.simulated_beta$beta
coefficients
all(coefficients==0)
devtools::load_all(".")
ggp.simulated_beta_newPat <- plot_pseudobeta_newPatient(model = lst_models[[5]],
new_observation = new_pat,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, show.betas = T, top = 20)
ggp.simulated_beta_newPat <- plot_pseudobeta_newPatient.list(lst_models = lst_models,
new_observation = new_pat,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, show.betas = T, top = 20)
ggp.simulated_beta_newPat$`sPLS-DRCOX-Dynamic`
ggp.simulated_beta_newPat$`sPLS-ICOX`
ggp.simulated_beta_newPat$`sPLS-DRCOX`$plot
ggp.simulated_beta_newPat$`sPLS-DRCOX-Dynamic`$plot
pat_density <- plot_patient.eventDensity(patient = new_pat,
time = NULL,
model = lst_models$`sPLS-DRCOX-Dynamic`,
type = "lp")
pat_density
pat_histogram <- plot_patient.eventHistogram(patient = new_pat,
time = NULL,
model = lst_models$`sPLS-DRCOX-Dynamic`,
type = "lp")
pat_histogram
knitr::kable(Y_test[1:5,])
lst_cox.comparison <- plot_LP.multiplePatients.list(lst_models = lst_models,
df.pat = X_test[1:5,],
error.bar = T, zero.rm = T, onlySig = T, alpha = 0.05, top = 5)
lst_cox.comparison <- plot_LP.multiplePatients.list(lst_models = lst_models,
new_data = X_test[1:5,],
error.bar = T, zero.rm = T, onlySig = T, alpha = 0.05, top = 5)
new_data = X_test[1:5,]
devtools::load_all(".")
lst_cox.comparison <- plot_LP.multiplePatients.list(lst_models = lst_models,
new_data = X_test[1:5,],
error.bar = T, zero.rm = T, onlySig = T, alpha = 0.05, top = 5)
lst_cox.comparison$`sPLS-DRCOX-Dynamic`$plot
devtools::load_all(".")
devtools::check(vignettes = F)
# classical approach
cox_model <- cox(X = X_train, Y = Y_train,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = T, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 0, FORCE = F, returnData = T, verbose = F)
MIN_EPV
max_n_predictors <- getMaxNPredictors(n.var = ncol(X), Y, MIN_EPV)
max_n_predictors
# classical approach
cox_model <- cox(X = X_train, Y = Y_train,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = T, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 0, FORCE = F, returnData = T, verbose = F)
X = X_train
Y = Y_train
x.scale = F
x.center = T
t1 <- Sys.time()
#### Original data
X_original <- X
Y_original <- Y
time <- Y[,"time"]
event <- Y[,"event"]
#### REQUIREMENTS
lst_check <- checkXY.class(X, Y, verbose = verbose)
X <- lst_check$X
Y <- lst_check$Y
#### ZERO VARIANCE - ALWAYS
lst_dnz <- deleteZeroOrNearZeroVariance(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
#colnames Y
checkY.colnames(Y)
#### MAX PREDICTORS
check.maxPredictors.cox(X, Y, MIN_EPV, FORCE)
FORCE  = F
#### MAX PREDICTORS
check.maxPredictors.cox(X, Y, MIN_EPV, FORCE)
MIN_EPV
max_n_predictors <- getMaxNPredictors(n.var = ncol(X), Y, MIN_EPV)
max_n_predictors
dim(X)
MIN_EPV
n_events <- NULL
n.var = ncol(X)
n.var
n_events <- NULL
if(is.numeric(Y[,"event"])){
n_events <- sum(Y[,"event"]==1)
}else if(is.logical(Y[,"event"])){
n_events <- sum(Y[,"event"]==T)
}
n_events
EPV <-  floor(n_events / 1:n.var) #EPV
EPV
n_events <- NULL
if(is.numeric(Y[,"event"])){
n_events <- sum(Y[,"event"]==1)
}else if(is.logical(Y[,"event"])){
n_events <- sum(Y[,"event"]==T)
}
EPV <-  floor(n_events / 1:n.var) #EPV
max_n_predictors <- n.var
if(any(EPV > MIN_EPV)){
max_n_predictors <- max(which(EPV>MIN_EPV))
}else{
cat("Minimum EPV not reached. You should be less strict or increse the number of events.\n")
return(0) #Treatment in the function that calls this one
}
max_n_predictors
MIN_EPV
n.var
devtools::load_all(".")
# classical approach
cox_model <- cox(X = X_train, Y = Y_train,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = T, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 0, FORCE = F, returnData = T, verbose = F)
cox_model
# classical approach
cox_model <- cox(X = X_train, Y = Y_train,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = T, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 5, FORCE = F, returnData = T, verbose = F)
devtools::load_all(".")
# classical approach
cox_model <- cox(X = X_train, Y = Y_train,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = T, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 5, FORCE = F, returnData = T, verbose = F)
# classical approach
cox_model <- cox(X = X_train, Y = Y_train,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = T, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 5, FORCE = F, returnData = T, verbose = F)
devtools::load_all(".")
# classical approach
cox_model <- cox(X = X_train, Y = Y_train,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = T, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 5, FORCE = F, returnData = T, verbose = F)
# classical approach
cox_model <- cox(X = X_train, Y = Y_train,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = T, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 5, FORCE = F, returnData = T, verbose = F)
check.maxPredictors.cox(X, Y, MIN_EPV, FORCE)
devtools::load_all(".")
check.maxPredictors.cox(X, Y, MIN_EPV, FORCE)
MIN_EPV
MIN_EPV = 5
#### MAX PREDICTORS
if(!check.maxPredictors.cox(X, Y, MIN_EPV, FORCE)){
return(NA)
}
# classical approach
cox_model <- cox(X = X_train, Y = Y_train,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = T, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 5, FORCE = F, returnData = T, verbose = F)
cox_model
# classical approach
cox_model <- cox(X = X_train, Y = Y_train,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = T, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 0, FORCE = F, returnData = T, verbose = F)
cox_model$class
coxen_model$n.var
coxen_model$selected_variables
coxen_model$removed_variables_cox
selected_variables
coxen_model$selected_variables
coxen_model <- coxEN(X = X_train, Y = Y_train,
EN.alpha = 0, #cv.coxen_res$opt.EN.alpha
max.variables = 47, #cv.coxen_res$opt.nvar
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = T, alpha = 0.05,
MIN_EPV = 5, returnData = T, verbose = F)
coxen_model$selected_variables
coxen_model$removed_variables_cox
X = X_train
Y = Y_train
EN.alpha = 0
max.variables = 47
x.scale = F
max.variables = 8
x.center = T
y.center = F
remove_near_zero_variance = T
remove_zero_variance = F
toKeep.zv = NULL
alpha = 0.05
t1 <- Sys.time()
#### Original data
X_original <- X
Y_original <- Y
time <- Y[,"time"]
event <- Y[,"event"]
#### REQUIREMENTS
lst_check <- checkXY.class(X, Y, verbose = verbose)
X <- lst_check$X
Y <- lst_check$Y
#### ZERO VARIANCE - ALWAYS
lst_dnz <- deleteZeroOrNearZeroVariance(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
checkY.colnames(Y)
#### SCALING
lst_scale <- XY.scale(X, Y, x.center, x.scale, y.center, y.scale)
Xh <- lst_scale$Xh
Yh <- lst_scale$Yh
xmeans <- lst_scale$xmeans
xsds <- lst_scale$xsds
ymeans <- lst_scale$ymeans
ysds <- lst_scale$ysds
X_norm <- Xh
#### MAX PREDICTORS
max.variables <- check.ncomp(X, max.variables)
max.variables <- check.maxPredictors(X, Y, MIN_EPV, max.variables, verbose = verbose)
#### REMOVING event in time 0 patients
if(any(Yh[,"time"]==0)){
if(verbose){
message("Some patients get the event at time 0. Those patients will be removed for the analysis")
}
pat_names <- rownames(Yh)[Yh[,"time"]==0]
Yh <- Yh[!rownames(Yh) %in% pat_names,]
Xh <- Xh[rownames(Xh) %in% rownames(Yh),]
}
#### INITIALISING VARIABLES
best_cox <- NULL
best_lambda <- NULL
selected_variables <- NULL
problem <- FALSE #convergence issues
#A small detail in the Cox model: if death times are tied with censored times, we assume the censored times occurred
#just before the death times in computing the Breslow approximation; if users prefer the usual convention of after,
#they can add a small number to all censoring times to achieve this effect.
for(t in unique(Yh[,"time"])){
set_pat <- Yh[Yh[,"time"]==t,,drop=F]
if(nrow(set_pat)>1 & length(unique(set_pat[,"event"]))>1){
names_censored <- names(which(set_pat[,"event"]==0))
Yh[names_censored,"time"] <- Yh[names_censored,"time"] + 0.0001
}
# BEST lambda
#I cannot add the limit for maximum number of variables bc it fails
# cvfit <- cv.glmnet(x = Xh, y = survival::Surv(time = Yh[,"time"], event = Yh[,"event"]),
#                    family = "cox", type.measure = "C",
#                    alpha = EN.alpha, dfmax = max.variables,
#                    standardize = F, nlambda=200)
#I cannot add the limit for maximum number of variables bc it fails
#pmax = max.variables
EN_cox <- tryCatch(
# Specifying expression
expr = {
glmnet::glmnet(x = Xh, y = survival::Surv(time = Yh[,"time"], event = Yh[,"event"]),
family = "cox", alpha = EN.alpha, standardize = F, nlambda=300, pmax = max.variables)
},
# Specifying error message
error = function(e){
message(paste0("coxEN: ", e))
invisible(gc())
return(NA)
},
warning = function(e){
if(verbose){
message("Model probably has a convergence issue...\n")
}
suppressWarnings(
res <- glmnet::glmnet(x = Xh, y = survival::Surv(time = Yh[,"time"], event = Yh[,"event"]),
family = "cox", EN.alpha = EN.alpha, standardize = F, pmax = max.variables, nlambda=300)
)
list(res = res, problem = T)
}
)
#only if problems
if(all(isa(EN_cox, "list"))){
problem = EN_cox$problem
EN_cox = EN_cox$res
}
all(class(EN_cox) %in% c("coxnet", "glmnet"))
if(all(class(EN_cox) %in% c("coxnet", "glmnet"))){
best_lambda <- EN_cox$lambda[which.max(EN_cox$dev.ratio)]
coef.matrix <- as.matrix(coef(EN_cox, s = best_lambda))
selected_variables <- rownames(coef.matrix)[which(coef.matrix != 0)]
d <- as.data.frame(cbind(Xh[,selected_variables,drop=F], Yh)) #data
best_cox <- tryCatch(
# Specifying expression
expr = {
survival::coxph(formula = survival::Surv(time,event) ~ .,
data = d,
ties = "efron",
singular.ok = T,
robust = T,
nocenter = rep(1, ncol(Xh)),
model=T, x = T)
},
# Specifying error message
error = function(e){
message(paste0("COX: ", e))
invisible(gc())
return(NA)
}
)
# best_cox <- tryCatch(
#   expr = {
#   # Specifying expression
#   d <- as.data.frame(Xh[,selected_variables,drop=F]) #data
#   cox(X = d, Y = Yh, FORCE = T,
#       x.center = x.center, x.scale = x.scale,
#       y.center = y.center, y.scale = y.scale)
#   },
#   # Specifying error message
#   error = function(e){
#     message(paste0("COX: ", e))
#     invisible(gc())
#     return(NA)
#   }
# )
}
selected_variables
all(is.na(best_cox)) || (problem & all(best_cox$linear.predictors==0))
if(all(is.na(best_cox)) || (problem & all(best_cox$linear.predictors==0))){
best_cox = NA
best_lambda = NA
selected_variables = NA
func_call <- match.call()
t2 <- Sys.time()
time <- difftime(t2,t1,units = "mins")
survival_model <- NULL
removed_variables <- NULL
invisible(gc())
return(coxEN_class(list(X = list("data" = if(returnData) Xh else NA, "x.mean" = xmeans, "x.sd" = xsds),
Y = list("data" = Yh, "y.mean" = ymeans, "y.sd" = ysds),
survival_model = survival_model,
EN.alpha = EN.alpha,
n.var = max.variables,
#alpha = alpha,
call = func_call,
X_input = if(returnData) X_original else NA,
Y_input = if(returnData) Y_original else NA,
nzv = variablesDeleted,
selected_variables = selected_variables,
removed_variables = removed_variables,
opt.lambda = best_lambda,
convergence_issue = problem,
class = pkg.env$coxEN,
time = time)))
}
#RETURN a MODEL with ALL significant Variables from complete, deleting one by one in backward method
removed_variables <- NULL
if(all(c("time", "event") %in% colnames(d))){
lst_rnsc <- removeNonSignificativeCox(cox = best_cox, alpha = alpha, cox_input = d, time.value = NULL, event.value = NULL)
}else{
lst_rnsc <- removeNonSignificativeCox(cox = best_cox, alpha = alpha, cox_input = cbind(d, Yh), time.value = NULL, event.value = NULL)
}
best_cox <- lst_rnsc$cox
removed_variables <- lst_rnsc$removed_variables
lst_rnsc$removed_variables
selected_variables
selected_variables[!selected_variables %in% lst_rnsc$removed_variables]
coxen_model$convergence_issue
coxen_model$alpha
coxen_model$nzv
splsicox_model$X$loadings
splsicox_model$var_by_component
splsdrcox_model$Y$loadings
splsdrcox_model$Y$ratio
splsdrcox_model$Y$y.sd
splsdrcox_model$Y$y.mean
splsdrcox_model$eta
splsdrcox_dynamic_model$time
splsdacox_dynamic_model <- splsdacox_mo_model
cv.splsdacox_dynamic_res <- cv.splsdacox_res
splsdacox_dynamic_model$plot_accuracyPerVariable
names(cv.coxen_res)
class(cv.coxen_res$best_model_info)
class(cv.coxen_res$df_results_comps)
cv.coxen_res$df_results_comps
cv.coxen_res$df_results_runs
cv.splsdacox_res$lst_test_indexes$run1$Fold01
check(vignettes = F)
devtools::check(vignettes = F)
