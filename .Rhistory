if(all(is.null(df_results_evals))){
message(paste0("Best model could NOT be obtained. All models computed present problems."))
t2 <- Sys.time()
time <- difftime(t2,t1,units = "mins")
if(return_models){
return(cv.plsicox_class(list(best_model_info = NULL, df_results_folds = NULL, df_results_runs = NULL, df_results_comps = NULL, lst_models = comp_model_lst, pred.method = pred.method, opt.comp = NULL, plot_AUC = NULL, plot_c_index = NULL, plot_AIC = NULL, class = pkg.env$cv.plsicox, time = time)))
}else{
return(cv.plsicox_class(list(best_model_info = NULL, df_results_folds = NULL, df_results_runs = NULL, df_results_comps = NULL, lst_models = NULL, pred.method = pred.method, opt.comp = NULL, plot_AUC = NULL, plot_c_index = NULL, plot_AIC = NULL, class = pkg.env$cv.plsicox, time = time)))
}
#### ### ### ### #
# EVALUATING AUC #
#### ### ### ### #
df_results_evals_comp <- NULL
df_results_evals_run <- NULL
df_results_evals_fold <- NULL
optimal_comp_index <- NULL
optimal_comp_flag <- NULL
if(w_AUC!=0){
#total_models <- ifelse(!fast_mode, n_run * max.ncomp, k_folds * n_run * max.ncomp)#inside get_COX_evaluation_AUC
#As we are measuring just one evaluator and one method - PARALLEL=F
lst_df <- get_COX_evaluation_AUC(comp_model_lst = comp_model_lst,
lst_X_test = lst_X_test, lst_Y_test = lst_Y_test,
df_results_evals = df_results_evals, times = times,
fast_mode = fast_mode, pred.method = pred.method, pred.attr = pred.attr,
max.ncomp = max.ncomp, n_run = n_run, k_folds = k_folds,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
w_AUC = w_AUC, #total_models = total_models,
method.train = pkg.env$plsicox, PARALLEL = F)
df_results_evals_comp <- lst_df$df_results_evals_comp
df_results_evals_run <- lst_df$df_results_evals_run
df_results_evals_fold <- lst_df$df_results_evals_fold
optimal_comp_index <- lst_df$optimal_comp_index
optimal_comp_flag <- lst_df$optimal_comp_flag
}else{
df_results_evals_fold <- df_results_evals
}
#### ### ### #
# BEST MODEL #
#### ### ### #
df_results_evals_comp <- cv.getScoreFromWeight(df_results_evals_comp, w_AIC, w_c.index, w_AUC, colname_AIC = "AIC", colname_c_index = "c_index", colname_AUC = "AUC")
if(optimal_comp_flag){
best_model_info <- df_results_evals_comp[optimal_comp_index,, drop=F][1,]
best_model_info <- as.data.frame(best_model_info)
}else{
best_model_info <- df_results_evals_comp[which(df_results_evals_comp[,"score"] == max(df_results_evals_comp[,"score"], na.rm = T)),, drop=F][1,]
best_model_info <- as.data.frame(best_model_info)
}
#### ###
# PLOTS #
#### ###
lst_EVAL_PLOTS <- get_EVAL_PLOTS(fast_mode = fast_mode, best_model_info = best_model_info, w_AUC = w_AUC, max.ncomp = max.ncomp,
df_results_evals_fold = df_results_evals_fold, df_results_evals_run = df_results_evals_run, df_results_evals_comp = df_results_evals_comp,
colname_AIC = "AIC", colname_c_index = "c_index", colname_AUC = "AUC", x.text = "Component")
df_results_evals_comp <- lst_EVAL_PLOTS$df_results_evals_comp
ggp_AUC <- lst_EVAL_PLOTS$ggp_AUC
ggp_c_index <- lst_EVAL_PLOTS$ggp_c_index
ggp_AIC <- lst_EVAL_PLOTS$ggp_AIC
message(paste0("Best model obtained."))
lst_EVAL_PLOTS$ggp_AUC
best_model_info
df_results_evals_comp
df_results_evals_run
df_results_evals_fold
optimal_comp_index
optimal_comp_flag
library(devtools)
library(RColorConesa) #from GitHub #devtools #usethis and gert install.packages('hrbrthemes', repos='http://cran.us.r-project.org')
loadGgplotTheme <- function(path){
file <- paste0(path,"ggplot_theme.R")
source(file, echo = F)
}
path <- "D:/Pedro/Mega/Doctorado/Otros proyectos/"
loadGgplotTheme(path)
load("D:/Pedro/Mega/Doctorado/Otros proyectos/data_GBM.mo.RData")
X <- X.clinical
Y <- Y.clinical
NAME = "TCGA_clinical_"
# METHODS
lst_evaluations <- c("survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I", "risksetROC")
names(lst_evaluations) <- lst_evaluations
# Classical
FLAG_COX = T
FLAG_COXSW = T
# hd
FLAG_COXEN = T
FLAG_PLSICOX = T
FLAG_sPLSDRCOX = T
FLAG_sPLSDRCOX_MO = T
FLAG_sPLSDACOX_MO = T
# mo
FLAG_SB.PLSICOX = F
FLAG_FAST.SB.PLSICOX = F
FLAG_SB.sPLSDRCOX = F
FLAG_FAST.SB.sPLSDRCOX = F
FLAG_MB.sPLSDRCOX = F
FLAG_MB.sPLSDACOX = F
# Scale Parameters
x.center = T
x.scale = T
y.center = F
y.scale = F
# Survival Parameters
MIN_EPV = 5
pred.attr = "mean"
# Algorithm Parameters
remove_non_significant = T
remove_non_significant_models = F
remove_near_zero_variance = T
remove_zero_variance = F
toKeep.zv = NULL
alpha = 0.05
returnData = T
verbose = T
PARALLEL = T
# cox
FORCE = T
# SW
boostDeletion = F
BACKWARDS = T
initialModel = "NULL"
toKeep.sw = NULL
alpha_ENT = 0.1
alpha_OUT = 0.15
alpha_PH  = 0.05
check_PH = F
# coxEN
EN.alpha.list = seq(0,1,0.1)
# PLS
max.ncomp = 10
max.iter = 500
# Cross Validation Parameters
times = NULL
return_models = F
seed = 123
# Weights Parameters
w_AIC = 0
w_c.index = 0
w_AUC = 1
# sPLS-DR-cox
eta.list = seq(0,0.9,0.25)
# mixOmics
vector = NULL
MIN_NVAR = 10
MAX_NVAR = 1000
n.cut_points = 5
EVAL_METHOD = "cenROC"
# Eval stop detection
MIN_AUC_INCREASE = 0.01 # 1%
MIN_AUC = 0.75 # 75%
MIN_COMP_TO_CHECK = 3
# Model Lists
lst_models_full <- NULL
lst_models <- NULL
lst_models_pls <- NULL
# Evaluation multiple models
max_time_points = 15
#### ### ### #### ### ### ###
#Cross Validation Parameters #
#### ### ### ### ### #### ###
n_run = 5
k_folds = 10
fast_mode = F
pred.method = "cenROC"
max.ncomp = 3
n_run = 3
k_folds = 4
fast_mode = F
pred.method = "cenROC"
set.seed(123)
index_train <- caret::createDataPartition(Y$event,
p = .7, #70% train
list = FALSE,
times = 1)
X_train <- X[index_train,]
Y_train <- Y[index_train,]
X_test <- X[-index_train,]
Y_test <- Y[-index_train,]
cv.coxEN_res <- HDcox::cv.coxEN(X = X_train, Y = Y_train,
EN.alpha.list = EN.alpha.list, #EN penalization
max.variables = ncol(X_train),
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL,
verbose = verbose)
best_coxEN <- HDcox::coxEN(X = X_train, Y = Y_train,
EN.alpha = cv.coxEN_res$opt.EN.alpha,
max.variables = cv.coxEN_res$opt.nvar,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha,
MIN_EPV = MIN_EPV,
returnData = returnData,
verbose = verbose)
cv.coxEN_res$plot_AUC
cv.plsicox_res <- HDcox::cv.plsicox(X = X_train, Y = Y_train,
max.ncomp = max.ncomp,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL,
verbose = verbose)
PARALLEL = F
cv.plsicox_res <- HDcox::cv.plsicox(X = X_train, Y = Y_train,
max.ncomp = max.ncomp,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL,
verbose = verbose)
cv.plsicox_res <- cv.plsicox(X = X_train, Y = Y_train,
max.ncomp = max.ncomp,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL,
verbose = verbose)
devtools::load_all(".")
cv.plsicox_res <- cv.plsicox(X = X_train, Y = Y_train,
max.ncomp = max.ncomp,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL,
verbose = verbose)
cv.plsicox_res
cv.plsicox_res$plot_AUC
cv.plsicox_res$class
PARALLEL = T
cv.plsicox_res <- cv.plsicox(X = X_train, Y = Y_train,
max.ncomp = max.ncomp,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL,
verbose = verbose)
PARALLEL = F
cv.plsicox_res <- cv.plsicox(X = X_train, Y = Y_train,
max.ncomp = max.ncomp,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL,
verbose = verbose)
best_plsicox <- HDcox::plsicox(X = X_train, Y = Y_train,
n.comp = cv.plsicox_res$opt.comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha,
MIN_EPV = MIN_EPV,
returnData = returnData,
verbose = verbose)
cv.splsdrcox_res <- cv.splsdrcox(X = X_train, Y = Y_train,
max.ncomp = max.ncomp, eta.list = eta.list,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL,
verbose = verbose)
cv.splsdrcox_res$time
cv.splsdrcox_res$plot_AUC
best_splsdrcox <- splsdrcox(X = X_train, Y = Y_train,
n.comp = cv.splsdrcox_res$opt.comp,
eta = cv.splsdrcox_res$opt.eta,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha,
MIN_EPV = MIN_EPV,
returnData = returnData,
verbose = verbose)
cv.splsdrcox_mixOmics_res <- cv.splsdrcox_mixOmics(X = X_train, Y = Y_train,
max.ncomp = max.ncomp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points, EVAL_METHOD = EVAL_METHOD,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
remove_non_significant_models = remove_non_significant_models,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL,
verbose = verbose)
Y_train[Y_train$time>3040,]
Y_train[Y_train$time>3000,]
best_splsdrcox_mixOmics <- splsdrcox_mixOmics(X = X_train, Y = Y_train,
n.comp = cv.splsdrcox_mixOmics_res$opt.comp,
vector = cv.splsdrcox_mixOmics_res$opt.nvar,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha,
MIN_EPV = MIN_EPV,
returnData = returnData,
verbose = verbose)
cv.splsdacox_mixOmics_res <- cv.splsdacox_mixOmics(X = X_train, Y = Y_train,
max.ncomp = max.ncomp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points, EVAL_METHOD = EVAL_METHOD,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
remove_non_significant_models = remove_non_significant_models,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL,
verbose = verbose)
cv.splsdacox_mixOmics_res$plot_AUC
cv.splsdacox_mixOmics_res
best_splsdacox_mixOmics <- HDcox::splsdacox_mixOmics(X_train, Y_train,
n.comp = cv.splsdacox_mixOmics_res$opt.comp,
vector = cv.splsdacox_mixOmics_res$opt.nvar,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha,
MIN_EPV = MIN_EPV,
returnData = returnData,
verbose = verbose)
best_splsdacox_mixOmics$nzv
lst_models_full[[cv.splsdacox_mixOmics_res$class]] = cv.splsdacox_mixOmics_res
lst_models_full[[best_splsdacox_mixOmics$class]] = best_splsdacox_mixOmics
lst_models[[best_splsdacox_mixOmics$class]] = best_splsdacox_mixOmics
lst_models_pls[[best_splsdacox_mixOmics$class]] = best_splsdacox_mixOmics
lst_models_full[[cv.splsdrcox_mixOmics_res$class]] = cv.splsdrcox_mixOmics_res
lst_models_full[[best_splsdrcox_mixOmics$class]] = best_splsdrcox_mixOmics
lst_models[[best_splsdrcox_mixOmics$class]] = best_splsdrcox_mixOmics
lst_models_pls[[best_splsdrcox_mixOmics$class]] = best_splsdrcox_mixOmics
lst_models_full[[cv.splsdrcox_res$class]] = cv.splsdrcox_res
lst_models_full[[best_splsdrcox$class]] = best_splsdrcox
lst_models[[best_splsdrcox$class]] = best_splsdrcox
lst_models_pls[[best_splsdrcox$class]] = best_splsdrcox
lst_models_full[[cv.plsicox_res$class]] = cv.plsicox_res
lst_models_full[[best_plsicox$class]] = best_plsicox
lst_models[[best_plsicox$class]] = best_plsicox
lst_models_pls[[best_plsicox$class]] = best_plsicox
lst_models_full[[cv.coxEN_res$class]] = cv.coxEN_res
lst_models_full[[best_coxEN$class]] = best_coxEN
lst_models[[best_coxEN$class]] = best_coxEN
lst_models_full[[best_coxSW$class]] = best_coxSW
lst_models[[best_coxSW$class]] = best_coxSW
best_coxSW <- HDcox::coxSW(X = X_train, Y = Y_train,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
initialModel = initialModel, toKeep.sw = toKeep.sw,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
max.variables = ncol(X_train),
boostDeletion = boostDeletion,
alpha = alpha, alpha_ENT = alpha_ENT, alpha_OUT = alpha_OUT, alpha_PH  = alpha_PH, check_PH = check_PH,
MIN_EPV = MIN_EPV,
BACKWARDS = BACKWARDS, verbose = verbose)
lst_models_full[[best_coxSW$class]] = best_coxSW
lst_models[[best_coxSW$class]] = best_coxSW
lst_models_full[[best_cox$class]] = best_cox
lst_models[[best_cox$class]] = best_cox
best_cox <- HDcox::cox(X = X_train, Y = Y_train,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha,
MIN_EPV = MIN_EPV,
FORCE = FORCE,
returnData = returnData,
verbose = verbose)
lst_models_full[[best_cox$class]] = best_cox
lst_models[[best_cox$class]] = best_cox
eval_results <- purrr::map(lst_evaluations, ~eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test, pred.method = .,
pred.attr = pred.attr, verbose = verbose,
times = times, max_time_points = max_time_points, PARALLEL = PARALLEL))
lst_evaluations <- "cenROC"
eval_results <- purrr::map(lst_evaluations, ~eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test, pred.method = .,
pred.attr = pred.attr, verbose = verbose,
times = times, max_time_points = max_time_points, PARALLEL = PARALLEL))
lst_ggp <- plot_evaluation.list(eval_results)
lst_ggp
eval_results
lst_evaluations
names(lst_evaluations) <- "cenROC"
eval_results <- purrr::map(lst_evaluations, ~eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test, pred.method = .,
pred.attr = pred.attr, verbose = verbose,
times = times, max_time_points = max_time_points, PARALLEL = PARALLEL))
lst_ggp <- plot_evaluation.list(eval_results)
lst_ggp$cenROC$lst_plots$lineplot
ggp_time <- plot_time.list(lst_models_full)
ggp_time
lst_forest_plot <- plot_forest.list(lst_models = lst_models)
lst_forest_plot$`sPLS-DRCOX-MixOmics`
lst_ph_ggplot <- plot_proportionalHazard.list(lst_models = lst_models)
lst_ph_ggplot$`sPLS-DACOX-MixOmics`
density.plots.lp <- plot_cox.event.list(lst_models, type = "lp")
density.plots.risk <- plot_cox.event.list(lst_models, type = "risk")
density.plots.expected <- plot_cox.event.list(lst_models, type = "expected")
density.plots.survival <- plot_cox.event.list(lst_models, type = "survival")
density.plots.lp$`sPLS-DACOX-MixOmics`$plot.density
ggp_density.event <- plot_events(Y = Y,
categories = c("Censored","Death"), #name for FALSE/0 (Censored) and TRUE/1 (Event)
y.text = "Number of observations",
roundTo = 0.5,
max.breaks = 15)
ggp_density.event
ggp.simulated_beta <- plot_pseudobeta.list(lst_models = lst_models_pls,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, top = 20,
show_percentage = T, size_percentage = 3, verbose = F)
ggp.simulated_beta$`sPLS-DACOX-MixOmics`
LST_KM_RES_LP <- getAutoKM.list(type = "LP",
lst_models = lst_models,
comp = 1:10,
top = 20,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05)
LST_KM_RES_LP$`sPLS-DACOX-MixOmics`
LST_KM_RES_LP$cox$LST_PLOTS$LP
devtools::load_all(".")
check()
remove.packages("HDcox")
load_all()
install()
library(devtools)
devtools::load_all(".")
install()
