font.x = 10,
font.y = 10,
font.tickslab = 8,
font.legend = 8,
title = title)
kmplot$table <- kmplot$table + labs(title = "Patients at risk") +
theme(axis.text = element_text(size = 8)) + theme(axis.title = element_text(size = 10))
lst_splots[["HazardCurve"]] <- kmplot
kmplot <- survminer::ggsurvplot(fit = kmsurvival, censor.shape = "|", color = colors, fun = "cumhaz",
conf.int = TRUE, ggtheme = theme_bw(),
conf.int.style = "ribbon",
conf.int.alpha = 0.25,
xlim = c(0, round_any(max(sdata$time), 5, ceiling)),
pval = T,
surv.median.line = "hv", # Add medians survival
risk.table = TRUE,
xlab = "Time (Days)",
ylab = "Cumulative Hazard",
title = "Cumulative Hazard",
legend = "none",
break.time.by = BREAKTIME,
font.caption = 8,
font.x = 10,
font.y = 10,
font.tickslab = 8,
font.legend = 8,
title = title)
kmplot$table <- kmplot$table + labs(title = "Patients at risk") +
theme(axis.text = element_text(size = 8)) + theme(axis.title = element_text(size = 10))
lst_splots[["CumulativeHazard"]] <- kmplot
}
return(lst_splots)
}
load_all()
LST_KM_RES_VAR <- purrr::map(lst_models, ~getAutoKM(type = "VAR",
model = .,
comp = 1:max.ncomp,
top = 10,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05))
load_all()
plot.survival_plot.qual <- function(data, sdata, cn_variables, name_data = NULL, BREAKTIME = 5, title = NULL){
lst_splots <- list()
if(!length(cn_variables)==0){
for(cn in cn_variables){
if(is.null(name_data)){
if(!cn %in% colnames(data)){
message(paste0("Variable ", cn, " not found in data."))
next
}else{
aux <- cbind(sdata, data[,cn])
}
}else{
if(!cn %in% colnames(data[[name_data]])){
message(paste0("Variable ", cn, " not found in data."))
next
}else{
aux <- cbind(sdata, data[[name_data]][,cn])
}
#delete NAs
aux <- aux[!is.na(aux[,3]),]
colnames(aux)[3] <- cn
f = as.formula(paste0("Surv(time = time, event = event) ~ ", cn))
kmsurvival <- tryCatch(
# Specifying expression
expr = {
survminer::surv_fit(formula = f, data = aux)
},
# Specifying error message
error = function(e){
message(paste0("Problems at variable ", cn, ".\n",e$message),". Try to change the name of the variable.")
NA
}
)
if(all(is.na(kmsurvival))){
next
}
if(requireNamespace("RColorConesa", quietly = TRUE)){
colors <- RColorConesa::colorConesa(length(levels(data[,cn])))
names(colors) <- NULL
}else{
colors <- NULL
}
#GGSURVPLOT DOES NOT PRINT INTERVALS IF ALL DATA IS NOT SELECTED FOR RIBBON STYLE
#IF PROBLEMS CHANGE TO STEP STYLE
kmplot <- survminer::ggsurvplot(fit = kmsurvival, censor.shape = "|", palette = colors,
conf.int = TRUE, ggtheme = theme_bw(), legend.labs = levels(aux[,cn]),
conf.int.style = "ribbon",
conf.int.alpha = 0.25,
xlim = c(0, round_any(max(aux$time), 5, ceiling)),
pval = T,
surv.median.line = "hv", # Add medians survival
risk.table = TRUE,
legend.title = cn,
break.time.by = BREAKTIME,
font.caption = 8,
font.x = 10,
font.y = 10,
font.tickslab = 8,
font.legend = 8,
title = title)
kmplot$table <- kmplot$table + labs(title = "Patients at risk") +
theme(axis.text = element_text(size = 8)) + theme(axis.title = element_text(size = 10))
lst_splots[[cn]] <- kmplot
}
}else{
f = as.formula("Surv(time = time, event = event) ~ 1")
kmsurvival <- survminer::surv_fit(formula = f, data = sdata)
if(requireNamespace("RColorConesa", quietly = TRUE)){
colors <- RColorConesa::colorConesa(1)
names(colors) <- NULL
} else {
colors <- NULL
}
kmplot <- survminer::ggsurvplot(fit = kmsurvival, censor.shape = "|", color = colors,
conf.int = TRUE, ggtheme = theme_bw(),
conf.int.style = "ribbon",
conf.int.alpha = 0.25,
xlim = c(0, round_any(max(sdata$time), 5, ceiling)),
pval = T,
surv.median.line = "hv", # Add medians survival
risk.table = TRUE,
title = "Survival Function",
legend = "none",
break.time.by = BREAKTIME,
font.caption = 8,
font.x = 10,
font.y = 10,
font.tickslab = 8,
font.legend = 8,
title = title)
kmplot$table <- kmplot$table + labs(title = "Patients at risk") +
theme(axis.text = element_text(size = 8)) + theme(axis.title = element_text(size = 10))
lst_splots[["SurvivalFunction"]] <- kmplot
kmplot <- survminer::ggsurvplot(fit = kmsurvival, censor.shape = "|", color = colors, fun = "event",
conf.int = TRUE, ggtheme = theme_bw(),
conf.int.style = "ribbon",
conf.int.alpha = 0.25,
xlim = c(0, round_any(max(sdata$time), 5, ceiling)),
pval = T,
surv.median.line = "hv", # Add medians survival
risk.table = TRUE,
title = "Hazard Curve",
legend = "none",
break.time.by = BREAKTIME,
font.caption = 8,
font.x = 10,
font.y = 10,
font.tickslab = 8,
font.legend = 8,
title = title)
kmplot$table <- kmplot$table + labs(title = "Patients at risk") +
theme(axis.text = element_text(size = 8)) + theme(axis.title = element_text(size = 10))
lst_splots[["HazardCurve"]] <- kmplot
kmplot <- survminer::ggsurvplot(fit = kmsurvival, censor.shape = "|", color = colors, fun = "cumhaz",
conf.int = TRUE, ggtheme = theme_bw(),
conf.int.style = "ribbon",
conf.int.alpha = 0.25,
xlim = c(0, round_any(max(sdata$time), 5, ceiling)),
pval = T,
surv.median.line = "hv", # Add medians survival
risk.table = TRUE,
xlab = "Time (Days)",
ylab = "Cumulative Hazard",
title = "Cumulative Hazard",
legend = "none",
break.time.by = BREAKTIME,
font.caption = 8,
font.x = 10,
font.y = 10,
font.tickslab = 8,
font.legend = 8,
title = title)
kmplot$table <- kmplot$table + labs(title = "Patients at risk") +
theme(axis.text = element_text(size = 8)) + theme(axis.title = element_text(size = 10))
lst_splots[["CumulativeHazard"]] <- kmplot
}
return(lst_splots)
}
LST_KM_RES_VAR <- purrr::map(lst_models, ~getAutoKM(type = "VAR",
model = .,
comp = 1:max.ncomp,
top = 10,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05))
LST_KM_RES_VAR$best_plsdacox_mixOmics$LST_PLOTS$SIRT5
LST_KM_RES_LP$best_plsdacox_mixOmics$LST_PLOTS$LP
load_all()
check()
load_all()
check()
pkg.env$sb.splsdrcox
pkg.env <- new.env(parent = emptyenv())
assign(x = 'model_class', value = "HDcox", pkg.env)
assign(x = 'eval_class', value = "evaluation", pkg.env)
assign(x = 'cox', value = c("cox"), pkg.env)
assign(x = 'coxSW', value = c("coxSW"), pkg.env)
assign(x = 'coxEN', value = c("coxEN"), pkg.env)
assign(x = 'classical_methods', value = c("cox", "coxSW", "coxEN"), pkg.env)
assign(x = 'plsicox', value = c("PLS-ICOX"), pkg.env)
assign(x = 'splsdrcox', value = c("sPLS-DRCOX"), pkg.env)
assign(x = 'splsdrcox_mixomics', value = c("sPLS-DRCOX-MixOmics"), pkg.env)
assign(x = 'plsdacox_mixomics', value = c("PLS-DACOX-MixOmics"), pkg.env)
assign(x = 'pls_methods', value = c("PLS-ICOX", "sPLS-DRCOX", "sPLS-DRCOX-MixOmics", "PLS-DACOX-MixOmics"), pkg.env)
assign(x = 'sb.plsicox', value = c("SB.PLS-ICOX"), pkg.env)
assign(x = 'sb.splsdrcox', value = c("SB.sPLS-DRCOX"), pkg.env)
assign(x = 'mb.splsdrcox', value = c("MB.sPLS-DRCOX"), pkg.env)
assign(x = 'mb.splsdacox', value = c("MB.sPLS-DACOX"), pkg.env)
assign(x = 'multiblock_methods', value = c("SB.PLS-ICOX", "SB.sPLS-DRCOX", "MB.sPLS-DRCOX", "MB.sPLS-DACOX"), pkg.env)
assign(x = 'all_methods', value = c(pkg.env$classical_methods, pkg.env$pls_methods, pkg.env$multiblock_methods), pkg.env)
assign(x = 'classical_cv', value = c("cv.coxEN"), pkg.env)
assign(x = 'pls_cv', value = c("cv.PLS-ICOX", "cv.sPLS-DRCOX", "cv.sPLS-DRCOX-MixOmics", "cv.PLS-DACOX-MixOmics"), pkg.env)
assign(x = 'multiblock_cv', value = c("cv.SB.PLS-ICOX", "cv.SB.sPLS-DRCOX", "cv.MB.sPLS-DRCOX", "cv.MB.sPLS-DACOX"), pkg.env)
assign(x = 'all_cv', value = c(pkg.env$classical_cv, pkg.env$pls_cv, pkg.env$multiblock_cv), pkg.env)
assign(x = 'AUC_survivalROC', value = c("survivalROC"), pkg.env)
assign(x = 'AUC_cenROC', value = c("cenROC"), pkg.env)
assign(x = 'AUC_nsROC', value = c("nsROC"), pkg.env)
assign(x = 'AUC_smoothROCtime_C', value = c("smoothROCtime_C"), pkg.env)
assign(x = 'AUC_smoothROCtime_I', value = c("smoothROCtime_I"), pkg.env)
assign(x = 'AUC_risksetROC', value = c("risksetROC"), pkg.env)
assign(x = 'AUC_evaluators', value = c("survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I", "risksetROC"), pkg.env)
pkg.env$pls_methods
pkg.env$all_methods
assign(x = 'cv.coxEN', value = c("cv.coxEN"), pkg.env)
assign(x = 'cv.plsicox', value = c("cv.PLS-ICOX"), pkg.env)
assign(x = 'cv.splsdrcox', value = c("cv.sPLS-DRCOX"), pkg.env)
assign(x = 'cv.splsdrcox_mixomics', value = c("cv.sPLS-DRCOX-MixOmics"), pkg.env)
assign(x = 'cv.plsdacox_mixomics', value = c("cv.PLS-DACOX-MixOmics"), pkg.env)
assign(x = 'cv.sb.plsicox', value = c("cv.SB.PLS-ICOX"), pkg.env)
assign(x = 'cv.sb.splsdrcox', value = c("cv.SB.sPLS-DRCOX"), pkg.env)
assign(x = 'cv.mb.splsdrcox', value = c("cv.MB.sPLS-DRCOX"), pkg.env)
assign(x = 'cv.mb.splsdacox', value = c("cv.MB.sPLS-DACOX"), pkg.env)
pkg.env <- new.env(parent = emptyenv())
assign(x = 'model_class', value = "HDcox", pkg.env)
assign(x = 'eval_class', value = "evaluation", pkg.env)
assign(x = 'cox', value = c("cox"), pkg.env)
assign(x = 'coxSW', value = c("coxSW"), pkg.env)
assign(x = 'coxEN', value = c("coxEN"), pkg.env)
assign(x = 'classical_methods', value = c("cox", "coxSW", "coxEN"), pkg.env)
assign(x = 'plsicox', value = c("PLS-ICOX"), pkg.env)
assign(x = 'splsdrcox', value = c("sPLS-DRCOX"), pkg.env)
assign(x = 'splsdrcox_mixomics', value = c("sPLS-DRCOX-MixOmics"), pkg.env)
assign(x = 'plsdacox_mixomics', value = c("PLS-DACOX-MixOmics"), pkg.env)
assign(x = 'pls_methods', value = c("PLS-ICOX", "sPLS-DRCOX", "sPLS-DRCOX-MixOmics", "PLS-DACOX-MixOmics"), pkg.env)
assign(x = 'sb.plsicox', value = c("SB.PLS-ICOX"), pkg.env)
assign(x = 'sb.splsdrcox', value = c("SB.sPLS-DRCOX"), pkg.env)
assign(x = 'mb.splsdrcox', value = c("MB.sPLS-DRCOX"), pkg.env)
assign(x = 'mb.splsdacox', value = c("MB.sPLS-DACOX"), pkg.env)
assign(x = 'multiblock_methods', value = c("SB.PLS-ICOX", "SB.sPLS-DRCOX", "MB.sPLS-DRCOX", "MB.sPLS-DACOX"), pkg.env)
assign(x = 'all_methods', value = c(pkg.env$classical_methods, pkg.env$pls_methods, pkg.env$multiblock_methods), pkg.env)
assign(x = 'cv.coxEN', value = c("cv.coxEN"), pkg.env)
assign(x = 'classical_cv', value = pkg.env$cv.coxEN, pkg.env)
assign(x = 'cv.plsicox', value = c("cv.PLS-ICOX"), pkg.env)
assign(x = 'cv.splsdrcox', value = c("cv.sPLS-DRCOX"), pkg.env)
assign(x = 'cv.splsdrcox_mixomics', value = c("cv.sPLS-DRCOX-MixOmics"), pkg.env)
assign(x = 'cv.plsdacox_mixomics', value = c("cv.PLS-DACOX-MixOmics"), pkg.env)
assign(x = 'pls_cv', value = c(pkg.env$cv.plsicox, pkg.env$cv.splsdrcox, pkg.env$cv.splsdrcox_mixomics, pkg.env$cv.plsdacox_mixomics), pkg.env)
assign(x = 'cv.sb.plsicox', value = c("cv.SB.PLS-ICOX"), pkg.env)
assign(x = 'cv.sb.splsdrcox', value = c("cv.SB.sPLS-DRCOX"), pkg.env)
assign(x = 'cv.mb.splsdrcox', value = c("cv.MB.sPLS-DRCOX"), pkg.env)
assign(x = 'cv.mb.splsdacox', value = c("cv.MB.sPLS-DACOX"), pkg.env)
assign(x = 'multiblock_cv', value = c(pkg.env$cv.sb.plsicox, pkg.env$cv.sb.splsdrcox, pkg.env$cv.mb.splsdrcox, pkg.env$cv.mb.splsdacox), pkg.env)
assign(x = 'all_cv', value = c(pkg.env$classical_cv, pkg.env$pls_cv, pkg.env$multiblock_cv), pkg.env)
assign(x = 'AUC_survivalROC', value = c("survivalROC"), pkg.env)
assign(x = 'AUC_cenROC', value = c("cenROC"), pkg.env)
assign(x = 'AUC_nsROC', value = c("nsROC"), pkg.env)
assign(x = 'AUC_smoothROCtime_C', value = c("smoothROCtime_C"), pkg.env)
assign(x = 'AUC_smoothROCtime_I', value = c("smoothROCtime_I"), pkg.env)
assign(x = 'AUC_risksetROC', value = c("risksetROC"), pkg.env)
assign(x = 'AUC_evaluators', value = c("survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I", "risksetROC"), pkg.env)
pkg.env$model_class
pkg.env$plsicox
pkg.env <- new.env(parent = emptyenv())
assign(x = 'model_class', value = "HDcox", pkg.env)
assign(x = 'eval_class', value = "evaluation", pkg.env)
assign(x = 'cox', value = c("cox"), pkg.env)
assign(x = 'coxSW', value = c("coxSW"), pkg.env)
assign(x = 'coxEN', value = c("coxEN"), pkg.env)
assign(x = 'classical_methods', value = c(pkg.env$cox, pkg.env$coxSW, pkg.env$coxEN), pkg.env)
assign(x = 'plsicox', value = c("PLS-ICOX"), pkg.env)
assign(x = 'splsdrcox', value = c("sPLS-DRCOX"), pkg.env)
assign(x = 'splsdrcox_mixomics', value = c("sPLS-DRCOX-MixOmics"), pkg.env)
assign(x = 'plsdacox_mixomics', value = c("PLS-DACOX-MixOmics"), pkg.env)
assign(x = 'pls_methods', value = c(pkg.env$plsicox, pkg.env$splsdrcox, pkg.env$splsdrcox_mixomics, pkg.env$plsdacox_mixomics), pkg.env)
assign(x = 'sb.plsicox', value = c("SB.PLS-ICOX"), pkg.env)
assign(x = 'sb.splsdrcox', value = c("SB.sPLS-DRCOX"), pkg.env)
assign(x = 'mb.splsdrcox', value = c("MB.sPLS-DRCOX"), pkg.env)
assign(x = 'mb.splsdacox', value = c("MB.sPLS-DACOX"), pkg.env)
assign(x = 'multiblock_methods', value = c(pkg.env$sb.plsicox, pkg.env$sb.splsdrcox, pkg.env$mb.splsdrcox, pkg.env$mb.splsdacox), pkg.env)
assign(x = 'all_methods', value = c(pkg.env$classical_methods, pkg.env$pls_methods, pkg.env$multiblock_methods), pkg.env)
assign(x = 'cv.coxEN', value = c("cv.coxEN"), pkg.env)
assign(x = 'classical_cv', value = pkg.env$cv.coxEN, pkg.env)
assign(x = 'cv.plsicox', value = c("cv.PLS-ICOX"), pkg.env)
assign(x = 'cv.splsdrcox', value = c("cv.sPLS-DRCOX"), pkg.env)
assign(x = 'cv.splsdrcox_mixomics', value = c("cv.sPLS-DRCOX-MixOmics"), pkg.env)
assign(x = 'cv.plsdacox_mixomics', value = c("cv.PLS-DACOX-MixOmics"), pkg.env)
assign(x = 'pls_cv', value = c(pkg.env$cv.plsicox, pkg.env$cv.splsdrcox, pkg.env$cv.splsdrcox_mixomics, pkg.env$cv.plsdacox_mixomics), pkg.env)
assign(x = 'cv.sb.plsicox', value = c("cv.SB.PLS-ICOX"), pkg.env)
assign(x = 'cv.sb.splsdrcox', value = c("cv.SB.sPLS-DRCOX"), pkg.env)
assign(x = 'cv.mb.splsdrcox', value = c("cv.MB.sPLS-DRCOX"), pkg.env)
assign(x = 'cv.mb.splsdacox', value = c("cv.MB.sPLS-DACOX"), pkg.env)
assign(x = 'multiblock_cv', value = c(pkg.env$cv.sb.plsicox, pkg.env$cv.sb.splsdrcox, pkg.env$cv.mb.splsdrcox, pkg.env$cv.mb.splsdacox), pkg.env)
assign(x = 'all_cv', value = c(pkg.env$classical_cv, pkg.env$pls_cv, pkg.env$multiblock_cv), pkg.env)
assign(x = 'AUC_survivalROC', value = c("survivalROC"), pkg.env)
assign(x = 'AUC_cenROC', value = c("cenROC"), pkg.env)
assign(x = 'AUC_nsROC', value = c("nsROC"), pkg.env)
assign(x = 'AUC_smoothROCtime_C', value = c("smoothROCtime_C"), pkg.env)
assign(x = 'AUC_smoothROCtime_I', value = c("smoothROCtime_I"), pkg.env)
assign(x = 'AUC_risksetROC', value = c("risksetROC"), pkg.env)
assign(x = 'AUC_evaluators', value = c(pkg.env$AUC_survivalROC, pkg.env$AUC_cenROC, pkg.env$AUC_nsROC, pkg.env$AUC_smoothROCtime_C, pkg.env$AUC_smoothROCtime_I, pkg.env$AUC_risksetROC), pkg.env)
getBestVectorMB <- function(Xh, DR_coxph = NULL, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = 10, MAX_NVAR = 10000, cut_points = 3, EVAL_METHOD = "AUC", EVAL_EVALUATOR = "cenROC", PARALLEL = F, mode = "spls", verbose = F){
if(!mode %in% c("spls", "splsda")){
stop("Mode must be one of: 'spls' or 'splsda'")
}
max_ncol <- purrr::map(Xh, ~ncol(.))
if(is.null(vector)){
#vector <- purrr::map(names(Xh), ~c(min(MIN_NVAR, max_ncol[[.]]), (max_ncol[[.]]+min(MIN_NVAR, max_ncol[[.]]))/2, min(max_ncol[[.]], MAX_NVAR)))
vector <- purrr::map(names(Xh), ~getVectorCuts(vector = c(min(MIN_NVAR, max_ncol[[.]]):min(max_ncol[[.]], MAX_NVAR)), cut_points = cut_points, verbose = verbose))
names(vector) <- names(Xh)
}else{
#check vector is a list, and each value is less than the max.variables of that block
if(class(vector)[1]!="list"){
aux <- list()
for(b in names(Xh)){
aux[[b]] <- vector
}
vector <- aux
message(paste0("The initial vector is: ", paste0(vector, collapse = ", ")))
}else{
if(!all(names(vector) %in% names(Xh))){
message("Your vector not contains the block names. A start vector is created using your vector.")
vector <- purrr::map(names(Xh), ~c(vector))
names(vector) <- names(Xh)
message(paste0("The initial vector is: ", paste0(vector, collapse = ", ")))
}
if(verbose){
message(paste0("Original vector: "))
message(paste0("Block ", names(vector), ": ", paste0(vector), "\n"))
}
lst_mb.spls <- list()
count = 1
var_exp = NULL
#if n_col is minimum than MIN_NVAR, values could be the same, so delete duplicates
vector <- purrr::map(vector, ~unique(.))
l <- vector
all_comb <- expand.grid(l)
## ALL POSSIBLE COMBINATIONS WITH N_VECTOR AND M_BLOCKS
## So we are trying all different number of variables per block
list_KeepX <- list()
for(i in 1:nrow(all_comb)){
keepX = list()
iter_name = NULL
for(k in names(Xh)){
keepX[[k]] = rep(all_comb[[k]][[i]], n.comp)
iter_name = c(iter_name, keepX[[k]][[1]])
}
list_KeepX[[paste0(iter_name, collapse = "_")]] <- keepX
}
if(PARALLEL){
n_cores <- future::availableCores() - 1
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(list_KeepX), n_cores))
}else{
future::plan("multisession", workers = min(length(list_KeepX), n_cores))
}
t1 <- Sys.time()
if(mode %in% "spls"){
lst_cox_value <- furrr::future_map(list_KeepX, ~getCIndex_AUC_CoxModel_block.spls(Xh = Xh, DR_coxph_ori = DR_coxph, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, EVAL_EVALUATOR = EVAL_EVALUATOR, max.iter = max.iter), .progress = F)
}else{
lst_cox_value <- furrr::future_map(list_KeepX, ~getCIndex_AUC_CoxModel_block.splsda(Xh = Xh, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, EVAL_EVALUATOR = EVAL_EVALUATOR, max.iter = max.iter), .progress = F)
}
t2 <- Sys.time()
future::plan("sequential")
}else{
t1 <- Sys.time()
if(mode %in% "spls"){
lst_cox_value <- purrr::map(list_KeepX, ~getCIndex_AUC_CoxModel_block.spls(Xh = Xh, DR_coxph_ori = DR_coxph, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, EVAL_EVALUATOR = EVAL_EVALUATOR, max.iter = max.iter), .progress = F)
}else{
lst_cox_value <- purrr::map(list_KeepX, ~getCIndex_AUC_CoxModel_block.splsda(Xh = Xh, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, EVAL_EVALUATOR = EVAL_EVALUATOR, max.iter = max.iter), .progress = F)
}
t2 <- Sys.time()
}
df_cox_value <- NULL
for(i in 1:length(lst_cox_value)){
if(EVAL_METHOD=="AUC"){
df_cox_value <- rbind(df_cox_value, lst_cox_value[[i]]$AUC)
}else{
df_cox_value <- rbind(df_cox_value, lst_cox_value[[i]]$c_index)
}
rownames(df_cox_value) <- names(list_KeepX)
index <- which.max(df_cox_value) #MAX CONCORDANCE
#Select best keepX
keepX <- list_KeepX[[index]]
FLAG = T
cont = 0
best_c_index <- df_cox_value[index]
best_keepX <- keepX
if(verbose){
message(paste0("First selection: \n"), paste0(paste0("Block ", names(best_keepX), ": ", unlist(purrr::map(best_keepX, ~unique(.)))), "\n"), "Pred. Value: ", round(best_c_index, 4), "\n")
}
ori_vector <- vector
aux_vector <- vector
while(FLAG){
cont = cont + 1
if(verbose){
message(paste0("Iteration: ", cont, "\n"))
}
new_vector <- list()
#before_vector
for(b in names(best_keepX)){
aux <- best_keepX[[b]][[1]]
index <- which(aux_vector[[b]] < aux)
if(length(index)==0){
value = aux_vector[[b]][which(aux_vector[[b]] == aux)]
}else{
value = round(mean(c(aux, aux_vector[[b]][index][[length(aux_vector[[b]][index])]]))) #last smaller
}
new_vector[[b]] <- unique(c(new_vector[[b]], aux, value))
}
#next_vector - always go two sides
for(b in names(best_keepX)){
aux <- best_keepX[[b]][[1]]
index <- which(aux_vector[[b]] > aux)
if(length(index)==0){
value = aux_vector[[b]][which(aux_vector[[b]] == aux)]
}else{
value = round(mean(c(aux, aux_vector[[b]][index][[1]]))) #first greater
}
new_vector[[b]] <- unique(c(new_vector[[b]], aux, value))
}
if(verbose){
message(paste0("Testing: \n"), paste0("Block ", names(best_keepX), ": ", new_vector, "\n"))
}
all_comb <- expand.grid(new_vector)
### update all vector
aux_vector <- purrr::map(names(new_vector), ~unique(c(aux_vector[[.]], new_vector[[.]])))
names(aux_vector) <- names(new_vector)
aux_vector <- purrr::map(names(new_vector), ~aux_vector[[.]][order(aux_vector[[.]])])
names(aux_vector) <- names(new_vector)
### OTHER KEEP_VECTOR
list_KeepX_aux <- list()
for(i in 1:nrow(all_comb)){
keepX_aux = list()
iter_name = NULL
for(k in names(Xh)){
keepX_aux[[k]] = rep(all_comb[[k]][[i]], n.comp)
iter_name = c(iter_name, keepX_aux[[k]][[1]])
}
if(paste0(iter_name, collapse = "_") %in% names(list_KeepX_aux)){
next #one already computed
}
list_KeepX_aux[[paste0(iter_name, collapse = "_")]] <- keepX_aux
}
## Compute next c_index
if(PARALLEL){
n_cores <- future::availableCores() - 1
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(list_KeepX_aux), n_cores))
}else{
future::plan("multisession", workers = min(length(list_KeepX_aux), n_cores))
}
t1 <- Sys.time()
if(mode %in% "spls"){
lst_cox_value <- furrr::future_map(list_KeepX_aux, ~getCIndex_AUC_CoxModel_block.spls(Xh = Xh, DR_coxph_ori = DR_coxph, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, max.iter = max.iter), .progress = F)
}else{
lst_cox_value <- furrr::future_map(list_KeepX_aux, ~getCIndex_AUC_CoxModel_block.splsda(Xh = Xh, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, max.iter = max.iter), .progress = F)
}
t2 <- Sys.time()
future::plan("sequential")
}else{
t1 <- Sys.time()
if(mode %in% "spls"){
lst_cox_value <- purrr::map(list_KeepX_aux, ~getCIndex_AUC_CoxModel_block.spls(Xh = Xh, DR_coxph_ori = DR_coxph, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, max.iter = max.iter), .progress = F)
}else{
lst_cox_value <- purrr::map(list_KeepX_aux, ~getCIndex_AUC_CoxModel_block.splsda(Xh = Xh, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, max.iter = max.iter), .progress = F)
}
t2 <- Sys.time()
}
df_cox_value_aux <- NULL
for(i in 1:length(lst_cox_value)){
if(EVAL_METHOD=="AUC"){
df_cox_value_aux <- rbind(df_cox_value_aux, lst_cox_value[[i]]$AUC)
}else{
df_cox_value_aux <- rbind(df_cox_value_aux, lst_cox_value[[i]]$c_index)
}
rownames(df_cox_value_aux) <- names(list_KeepX_aux)
#index <- which.max(rowSums(df_cox_value_aux)) #MAX VAR_MEDIA
#index <- which.max(df_cox_value_aux[,"Y"]) #MAX Y?
index <- which.max(df_cox_value_aux) #MAX CONCORDANCE
best_c_index_aux <- df_cox_value_aux[index]
if(best_c_index >= best_c_index_aux | best_c_index_aux-best_c_index <= MIN_AUC_INCREASE){
FLAG = F
if(verbose){
message(paste0("End: \n"), paste0(paste0("Block ", names(best_keepX), ": ", unlist(purrr::map(best_keepX, ~unique(.)))), "\n"), paste0("Pred. Value: ", round(best_c_index, 4), "\n"))
}
}else{
best_c_index <- best_c_index_aux
best_keepX <- list_KeepX_aux[[index]]
if(verbose){
message(paste0("New Vector: \n"), paste0(paste0("Block ", names(best_keepX), ": ", unlist(purrr::map(best_keepX, ~unique(.)))), "\n"), paste0("Pred. Value: ", round(best_c_index_aux, 4), "n"))
}
keepX <- best_keepX
return(keepX)
}
load-all()
load_all()
check()
load_all()
check()
install()
