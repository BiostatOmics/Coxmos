cv.splsdrcox_mo_res <- cv.splsdrcox_mixOmics(X = X_train, Y = Y_train,
max.ncomp = 10, vector = NULL,
MIN_NVAR = 10, MAX_NVAR = 1000, n.cut_points = 10, EVAL_METHOD = "cenROC",
n_run = 2, k_folds = 10,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant_models = F, alpha = 0.05,
w_AIC = 0,  w_c.index = 0, w_AUC = 1, times = NULL,
MIN_AUC_INCREASE = 0.05, MIN_AUC = 0.8, MIN_COMP_TO_CHECK = 3,
pred.attr = "mean", pred.method = "cenROC", fast_mode = F,
MIN_EPV = 5, return_models = F,
PARALLEL = T, verbose = F, seed = 123)
sum(Y[(Y[,"event"]==1 | Y[,"event"]==TRUE),"time"]>=t)>2 & t != 0
t
#which times can be computed
res <- NULL
for(t in times){
if(!sum(Y[(Y[,"event"]==1 | Y[,"event"]==TRUE),"time"]<=t)<2 & t != 0){
if(method==pkg.env$AUC_cenROC){
#cenROC needs also two events after the time
if(sum(Y[(Y[,"event"]==1 | Y[,"event"]==TRUE),"time"]>=t)>2 & t != 0){
res <- c(res, TRUE)
}else{
res <- c(res, FALSE)
}
}else{
res <- c(res, TRUE)
}
}else{
res <- c(res, FALSE)
}
res
sum(Y[(Y[,"event"]==1 | Y[,"event"]==TRUE),"time"]>=t)>2 & t != 0
t
t = 3040
sum(Y[(Y[,"event"]==1 | Y[,"event"]==TRUE),"time"]>=t)>2 & t != 0
t1 <- Sys.time()
#### ### ###
# WARNINGS #
#### ### ###
#Check evaluator installed:
checkLibraryEvaluator(pred.method)
#### REQUIREMENTS
checkY.colnames(Y)
check.cv.weights(c(w_AIC, w_c.index, w_AUC))
max.ncomp <- check.ncomp(X, max.ncomp)
# if(!pred.method %in% c("risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I")){
#   stop_quietly(paste0("pred.method must be one of the following: ", paste0(c("risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I"), collapse = ", ")))
# }
if(!pred.method %in% pkg.env$AUC_evaluators){
stop_quietly(paste0("pred.method must be one of the following: ", paste0(pkg.env$AUC_evaluators, collapse = ", ")))
}
#### MAX PREDICTORS
max.ncomp <- check.maxPredictors(X, Y, MIN_EPV, max.ncomp, verbose = verbose)
#### REQUIREMENTS
lst_dnz <- deleteZeroOrNearZeroVariance(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
#### #
# CV #
#### #
set.seed(seed)
lst_data <- splitData_Iterations_Folds(X, Y, n_run = n_run, k_folds = k_folds) #FOR TEST
lst_X_train <- lst_data$lst_X_train
lst_Y_train <- lst_data$lst_Y_train
lst_X_test <- lst_data$lst_X_test
lst_Y_test <- lst_data$lst_Y_test
#### ### ### ###
# TRAIN MODELS #
#### ### ### ###
total_models <- 1 * k_folds * n_run
method = pkg.env$splsdacox_mixomics
eta.list = NULL
EN.alpha.list = NULL
toKeep.zv = NULL
remove_zero_variance = F
remove_near_zero_variance = F
comp_model_lst <- list()
fold_list <- list()
run_list <- list()
eta_model_lst <- NULL
info <- NULL # for sPLS
## CHECK METHOD
if(is.null(eta.list) & is.null(EN.alpha.list) & !method %in% c(pkg.env$plsicox, pkg.env$splsdacox_mixomics, pkg.env$splsdrcox_mixomics, pkg.env$sb.plsicox, pkg.env$mb.splsdrcox, pkg.env$mb.splsdacox)){
stop_quietly("Method must be one of 'PLS-ICOX', 'sPLS-DACOX-MixOmics', 'MB.sPLS-DACOX' or 'sPLS-DRCOX-MixOmics' if 'eta.list' and 'EN.alpha.list' is NULL.")
}else if(!is.null(eta.list) & is.null(EN.alpha.list)  & !method %in% c(pkg.env$splsdrcox, pkg.env$sb.splsdrcox)){
stop_quietly("Method must be 'sPLS-DRCOX' if 'eta.list' is not NULL.")
}else if(!is.null(EN.alpha.list) & !method %in% c(pkg.env$coxEN)){
stop_quietly("Method must be 'coxEN' if 'EN.alpha.list' is not NULL.")
}
# if(method==pkg.env$splsdrcox){
#   if(is.null(n_run.mixOmics)){
#     stop_quietly("For method 'sPLS-DRCOX-MixOmics', parameter 'n_run.mixOmics' cannot be NULL.")
#   }
#   if(is.null(k_folds.mixOmics)){
#     stop_quietly("For method 'sPLS-DRCOX-MixOmics', parameter 'k_folds.mixOmics' cannot be NULL.")
#   }
#   if(is.null(test.keepX)){
#     stop_quietly("For method 'sPLS-DRCOX-MixOmics', parameter 'test.keepX' cannot be NULL.")
#   }
# }
pb_text <- "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated remaining time: :eta]"
pb <- progress::progress_bar$new(format = pb_text,
total = total_models,
complete = "=",   # Caracteres de las iteraciones finalizadas
incomplete = "-", # Caracteres de las iteraciones no finalizadas
current = ">",    # Caracter actual
clear = FALSE,    # Si TRUE, borra la barra cuando termine
width = 100)      # Ancho de la barra de progreso
message(paste0("Training all possible models for ", method, "..."))
pb$tick(0)
#### ### ### ### ### ### #
# UPDATING GLOBALS SIZE #
#### ### ### ### ### ### #
MB = 4000
bytes = MB*1024^2
options(future.globals.maxSize = bytes)
#function to compute all models at the same time - just last component
lst_inputs <- list()
cont = 1
lst_names = NULL
for(i in max.ncomp){
for(r in 1:n_run){
for(f in 1:k_folds){
lst_inputs[[cont]] = list()
lst_inputs[[cont]]$comp = i
lst_inputs[[cont]]$run <- r
lst_inputs[[cont]]$fold <- f
lst_names <- c(lst_names, paste0(i, "_", r, "_", f))
cont = cont + 1
}
names(lst_inputs) <- lst_names
X = data.matrix(lst_X_train$run1$Fold01)
Y = data.matrix(lst_Y_train$run1$Fold01)
n.comp = 2
t1 <- Sys.time()
#### Original data
X_original <- X
Y_original <- Y
time <- Y[,"time"]
event <- Y[,"event"]
#### REQUIREMENTS
lst_check <- checkXY.class(X, Y, verbose = verbose)
X <- lst_check$X
Y <- lst_check$Y
checkY.colnames(Y)
#### ZERO VARIANCE - ALWAYS
lst_dnz <- deleteZeroOrNearZeroVariance(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
#### SCALING
lst_scale <- XY.scale(X, Y, x.center, x.scale, y.center, y.scale)
Xh <- lst_scale$Xh
Yh <- lst_scale$Yh
xmeans <- lst_scale$xmeans
xsds <- lst_scale$xsds
ymeans <- lst_scale$ymeans
ysds <- lst_scale$ysds
X_norm <- Xh
#### MAX PREDICTORS
n.comp <- check.maxPredictors(X, Y, MIN_EPV, n.comp)
DR_coxph <- NULL
if(is.null(vector)){
keepX <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "splsda", verbose = verbose)
}else{
if(is.numeric(vector)){
keepX <- vector
if(length(keepX)>1){
message("keepX must be a number, not a vector. Maximum value will be selected for compute the sPLS model.")
keepX <- max(keepX)
}
if(keepX>ncol(X)){
message("keepX must be a lesser than the number of columns in X. The value will be updated to that one.")
keepX <- ncol(X)
}
}else{
message("Vector does not has the proper structure. Optimizing best n.variables by using your vector as start vector.")
keepX <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector = NULL, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "splsda", verbose = verbose)
}
max.iter  =500
if(is.null(vector)){
keepX <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "splsda", verbose = verbose)
}else{
if(is.numeric(vector)){
keepX <- vector
if(length(keepX)>1){
message("keepX must be a number, not a vector. Maximum value will be selected for compute the sPLS model.")
keepX <- max(keepX)
}
if(keepX>ncol(X)){
message("keepX must be a lesser than the number of columns in X. The value will be updated to that one.")
keepX <- ncol(X)
}
}else{
message("Vector does not has the proper structure. Optimizing best n.variables by using your vector as start vector.")
keepX <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector = NULL, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "splsda", verbose = verbose)
}
t1 <- Sys.time()
#### Original data
X_original <- X
Y_original <- Y
time <- Y[,"time"]
event <- Y[,"event"]
#### REQUIREMENTS
lst_check <- checkXY.class(X, Y, verbose = verbose)
X <- lst_check$X
Y <- lst_check$Y
checkY.colnames(Y)
# if(k_folds.mixOmics<2){
#   message("MixOmics k_folds must be 2 as minimum.")
#   k_folds.mixOmics = 2
# }
#### ZERO VARIANCE - ALWAYS
lst_dnz <- deleteZeroOrNearZeroVariance(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
#### SCALING
lst_scale <- XY.scale(X, Y, x.center, x.scale, y.center, y.scale)
Xh <- lst_scale$Xh
Yh <- lst_scale$Yh
xmeans <- lst_scale$xmeans
xsds <- lst_scale$xsds
ymeans <- lst_scale$ymeans
ysds <- lst_scale$ysds
X_norm <- Xh
#### MAX PREDICTORS
n.comp <- check.maxPredictors(X, Y, MIN_EPV, n.comp)
E <- list()
R2 <- list()
SCR <- list()
SCT <- list()
XXNA <- is.na(Xh) #T is NA
YNA <- is.na(Y) #T is NA
#### ### ### ### ### ### ### ### ### ### ### ###
### ###             sPLS-COX             ### ###
#### ### ### ### ### ### ### ### ### ### ### ###
#2. Surv function - NULL model
coxDR <- survival::coxph(survival::Surv(time = time, event = event, type = "right") ~ 1, as.data.frame(Xh))
#3. Residuals - Default is deviance because eval type="deviance"
DR_coxph <- residuals(coxDR, type = "deviance") #"martingale", "deviance", "score", "schoenfeld", "dfbeta"', "dfbetas", "scaledsch" and "partial"
#### ### ### ### ### ### ### ### ### ### ### ###
##                                            ##
##  Beginning of the loop for the components  ##
##                                            ##
#### ### ### ### ### ### ### ### ### ### ### ###
#4. sPLS Algorithm
n_obs <- nrow(Xh)
n_var <- ncol(Xh)
n_dr <- ncol(DR_coxph)
if(is.null(n_dr))
n_dr=1
#Norm Y
mu <- mean(DR_coxph) #equivalent because Y it is not normalized
DR_coxph <- scale(DR_coxph, center = mu, scale = FALSE) #center DR to DR / patients
DR_coxph_ori <- DR_coxph
#Norm X - Do not center again
# x_center_by_nobs <- colMeans(Xh, na.rm = T)
# Xh <- scale(Xh, center = x_center_by_nobs, scale = FALSE)
flag = T
cv.spls <- NA
#### ### ### ### ### ### ### ### ### ###
# DIVIDE Y VENCERAS - BEST VECTOR SIZE #
#### ### ### ### ### ### ### ### ### ###
if(is.null(vector)){
keepX <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", verbose = verbose)
}else{
if(is.numeric(vector)){
keepX <- vector
if(length(keepX)>1){
message("keepX must be a number, not a vector. Maximum value will be selected for compute the sPLS model.")
keepX <- max(keepX)
}
if(keepX>ncol(X)){
message("keepX must be a lesser than the number of columns in X. The value will be updated to that one.")
keepX <- ncol(X)
}
}else{
message("Vector does not has the proper structure. Optimizing best n. variables by using your vector as start vector.")
keepX <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector = NULL, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", verbose = verbose)
}
keepX
spls <- mixOmics::spls(X = Xh, Y = DR_coxph_ori, ncomp = n.comp, keepX = rep(keepX, n.comp), scale = F)
# sometimes solve(t(P) %*% W) in predict can cause an error
# system is computationally singular: reciprocal condition number = 6.24697e-18
predplsfit <- tryCatch(expr = {predict(spls, newdata=Xh[,rownames(spls$loadings$X),drop=F])},
error = function(e){
if(verbose){
message(e$message)
}
NA
})
predplsfit
lst_all_models <- furrr::future_map(lst_inputs, ~splsdrcox_mixOmics(X = data.matrix(lst_X_train[[.$run]][[.$fold]]),
Y = data.matrix(lst_Y_train[[.$run]][[.$fold]]),
n.comp = .$comp,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD, tol = tol, alpha = alpha,
MIN_EPV = MIN_EPV, returnData = returnData), .options = furrr_options(seed = TRUE))
devtools::load_all(".")
dpi = 125
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dpi=dpi,
fig.retina=1,
fig.width=1440/dpi, #4:3 FHD
fig.height=1080/dpi,
out.width="100%",
crop = NULL,
warning = T,
error = T
)
rm(dpi)
library(RColorConesa)
#theme_set(theme_colorConesa()) #under development
# load Tasic dataset
data("X_miRNA_glioblastoma")
data("Y_miRNA_glioblastoma")
X <- X_miRNA_glioblastoma
Y <- Y_miRNA_glioblastoma
rm(X_miRNA_glioblastoma, Y_miRNA_glioblastoma)
knitr::kable(X[1:5,1:5])
knitr::kable(Y[1:5,])
knitr::kable(dim(X), col.names = "X")
knitr::kable(dim(Y), col.names = "Y")
ggp_density.event <- plot_events(Y = Y,
categories = c("Censored","Death"), #name for FALSE/0 (Censored) and TRUE/1 (Event)
y.text = "Number of observations",
roundTo = 0.5,
max.breaks = 15)
ggp_density.event$plot
set.seed(321)
index_train <- caret::createDataPartition(Y$event,
p = .8, # 80% train
list = FALSE,
times = 1)
X_train <- X[index_train,] #443x534
Y_train <- Y[index_train,]
X_test <- X[-index_train,] #109x534
Y_test <- Y[-index_train,]
EPV <- getEPV(X_train, Y_train)
EPV
coxen_model <- coxEN(X = X_train, Y = Y_train,
EN.alpha = 0, #cv.coxen_res$opt.EN.alpha
max.variables = 47, #cv.coxen_res$opt.nvar
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = F, alpha = 0.05,
MIN_EPV = 5, returnData = T, verbose = F)
coxen_model
coxen_model <- coxEN(X = X_train, Y = Y_train,
EN.alpha = 0, #cv.coxen_res$opt.EN.alpha
max.variables = 47, #cv.coxen_res$opt.nvar
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = T, alpha = 0.05,
MIN_EPV = 5, returnData = T, verbose = F)
coxen_model
plsicox_model <- plsicox(X = X_train, Y = Y_train,
n.comp = 3, #n.comp = cv.plsicox_res$opt.comp
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
MIN_EPV = 5, returnData = T, verbose = F)
plsicox_model
splsdrcox_model <- splsdrcox(X = X_train, Y = Y_train,
n.comp = 1, eta = 0.75, #n.comp = cv.splsdrcox_res$opt.comp, eta = cv.splsdrcox_res$opt.eta
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
MIN_EPV = 5, returnData = T, verbose = F)
splsdrcox_model
splsdrcox_mo_model <- splsdrcox_mixOmics(X = X_train, Y = Y_train,
n.comp = 2, vector = 534,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
MIN_NVAR = 10, MAX_NVAR = 1000, n.cut_points = 5,
MIN_AUC_INCREASE = 0.01,
EVAL_METHOD = "AUC", pred.method = "cenROC", max.iter = 200,
MIN_EPV = 5, returnData = T, verbose = F)
splsdrcox_mo_model
splsdacox_mo_model <- splsdacox_mixOmics(X = X_train, Y = Y_train,
n.comp = 6, vector = 184,
x.center = T, x.scale = F,
y.center = F, y.scale = F,
remove_near_zero_variance = T, remove_zero_variance = F, toKeep.zv = NULL,
MIN_NVAR = 10, MAX_NVAR = 1000, n.cut_points = 5,
MIN_AUC_INCREASE = 0.01,
EVAL_METHOD = "AUC", pred.method = "cenROC", max.iter = 200,
MIN_EPV = 5, returnData = T, verbose = F)
splsdacox_mo_model
lst_models <- list("COX-EN" = coxen_model,
"PLS-ICOX" = plsicox_model,
"sPLS-DRCOX" = splsdrcox_model,
"sPLS-DRCOX-MixOmics" = splsdrcox_mo_model,
"sPLS-DACOX-MixOmics" = splsdacox_mo_model)
eval_results <- eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
pred.method = "cenROC",
pred.attr = "mean",
times = NULL, max_time_points = 15,
PARALLEL = T)
# lst_evaluators <- c(cenROC = "cenROC",
#                     risksetROC = "risksetROC")
#
# eval_results <- purrr::map(lst_evaluators, ~eval_models4.0(lst_models = lst_models,
#                                                            X_test = X_test, Y_test = Y_test,
#                                                            pred.method = .,
#                                                            pred.attr = "mean",
#                                                            times = seq(1,4,0.5), max_time_points = 15,
#                                                            PARALLEL = T))
eval_results
#eval_results$cenROC
lst_eval_results <- plot_evaluation(eval_results)
#lst_eval_results <- plot_evaluation.list(eval_results)
lst_eval_results$lst_plots$lineplot
lst_eval_results$lst_plot_comparisons$anova
# lst_eval_results$cenROC$lst_plots$lineplot.mean
# lst_eval_results$cenROC$lst_plot_comparisons$t.test
lst_models_time <- list(coxen_model,
plsicox_model,
splsdrcox_model,
splsdrcox_mo_model,
splsdacox_mo_model)
ggp_time <- plot_time.list(lst_models_time)
ggp_time
lst_forest_plot <- plot_forest.list(lst_models)
lst_forest_plot$`sPLS-DRCOX-MixOmics`
lst_ph_ggplot <- plot_proportionalHazard.list(lst_models)
lst_ph_ggplot$`sPLS-DRCOX-MixOmics`
density.plots.lp <- plot_cox.event.list(lst_models, type = "lp")
density.plots.lp$`sPLS-DRCOX-MixOmics`$plot.density
density.plots.lp$`sPLS-DRCOX-MixOmics`$plot.histogram
ggp.simulated_beta <- plot_pseudobeta.list(lst_models = lst_models,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, top = 20,
show_percentage = T, size_percentage = 3, verbose = F)
ggp.simulated_beta$`sPLS-DRCOX-MixOmics`$plot
ggp.simulated_beta <- plot_pseudobeta.list(lst_models = lst_models,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, top = 20,
show_percentage = T, size_percentage = 2, verbose = F)
ggp.simulated_beta$`sPLS-DRCOX-MixOmics`$plot
LST_KM_RES_LP <- getAutoKM.list(type = "LP",
lst_models = lst_models,
comp = 1:4,
top = 10,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05)
LST_KM_RES_LP$`sPLS-DRCOX-MixOmics`$LST_PLOTS$LP
lst_cutoff <- getCutoffAutoKM.list(LST_KM_RES_LP)
LST_KM_TEST_LP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "LP",
BREAKTIME = NULL, n.breaks = 20,
lst_cutoff = lst_cutoff)
LST_KM_TEST_LP$`sPLS-DRCOX-MixOmics`
new_pat <- X_test[1,,drop=F]
knitr::kable(Y_test[rownames(new_pat),])
ggp.simulated_beta_newPat <- plot_pseudobeta_newPatient.list(lst_models = lst_models,
new_pat = new_pat,
error.bar = T, onlySig = T, alpha = 0.05,
zero.rm = T, auto.limits = T, show.betas = T, top = 20)
# ggp.simulated_beta_newPat <- plot_pseudobeta_newPatient(model = lst_models$`sPLS-DRCOX-MixOmics`,
#                                                         new_pat = new_pat,
#                                                         error.bar = T, onlySig = T, alpha = 0.05,
#                                                         zero.rm = T, auto.limits = T, show.betas = T, top = 20)
ggp.simulated_beta_newPat$`sPLS-DRCOX-MixOmics`$plot
pat_density <- plot_patient.eventDensity(patient = new_pat,
time = NULL,
model = lst_models$`sPLS-DRCOX-MixOmics`,
type = "lp")
pat_density
knitr::kable(Y_test[1:5,])
lst_cox.comparison <- plot_LP.multiplePatients.list(lst_models = lst_models,
df.pat = X_test[1:5,],
error.bar = T, zero.rm = T, onlySig = T, alpha = 0.05, top = 5)
lst_cox.comparison$`sPLS-DRCOX-MixOmics`$plot
remove.packages("HDcox")
check()
library(devtools)
devtools::load_all(".")
install()
