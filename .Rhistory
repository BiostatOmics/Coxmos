x.scale = x.scale, x.center = x.center, y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV, tol = tol,
pred.attr = pred.attr, pred.method = pred.method, seed = seed,
returnData = T, verbose = T, PARALLEL = PARALLEL)
message(paste0("\nTIME FOR cv.SB.FAST.sPLSDRCOX: ", best_sb.fast.splsdrcox$time, "\n"))
lst_models_full[[best_sb.fast.splsdrcox$class]] = best_sb.fast.splsdrcox
lst_models[[best_sb.fast.splsdrcox$class]] = best_sb.fast.splsdrcox
lst_models_pls[[best_sb.fast.splsdrcox$class]] = best_sb.fast.splsdrcox
save(list = c("best_sb.fast.splsdrcox"), file = paste0(aux_folder, "fast.sb.splsdrcox.RData"))
gc()
}
if(FLAG_MB.sPLSDRCOX){
aux_folder = paste0(folder, "mb.splsdrcox_mixOmics_plot/")
dir.create(aux_folder)
cv.mb.splsdrcox_mixOmics_res <- cv.mb.splsdrcox(X = X_train, Y = data.matrix(Y_train),
max.ncomp = max.ncomp, n_run = n_run, k_folds = k_folds,
vector = vector, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points, EVAL_METHOD = EVAL_METHOD,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha, remove_non_significant_models = remove_non_significant_models,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC, times = times, max_time_points = max_time_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center, y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV, tol = tol,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL, verbose = verbose)
message(paste0("\nTIME FOR cv.MB.sPLSDRCOX_MIXOMICS: ", cv.mb.splsdrcox_mixOmics_res$time, "\n"))
save_ggplot.svg(cv.mb.splsdrcox_mixOmics_res$plot_AUC, folder = aux_folder, wide = T, name = "cv.mb.splsdrcox_mixOmics_res_AUC.svg")
save_ggplot.svg(cv.mb.splsdrcox_mixOmics_res$plot_c_index, folder = aux_folder, wide = T, name = "cv.mb.splsdrcox_mixOmics_res_c_index.svg")
save_ggplot.svg(cv.mb.splsdrcox_mixOmics_res$plot_AIC, folder = aux_folder, wide = T, name = "cv.mb.splsdrcox_mixOmics_res_AIC.svg")
best_mb.splsdrcox_mixOmics <- mb.splsdrcox(X = X_train,
Y = Y_train,
n.comp = cv.mb.splsdrcox_mixOmics_res$opt.comp,
vector = cv.mb.splsdrcox_mixOmics_res$opt.nvar,
x.center = x.center, x.scale = x.scale,
y.scale = y.scale, y.center = y.center,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
pred.method = pred.method, MIN_EPV = MIN_EPV, PARALLEL = PARALLEL, tol = tol,
returnData = returnData, verbose = verbose)
lst_models_full[[cv.mb.splsdrcox_mixOmics_res$class]] = cv.mb.splsdrcox_mixOmics_res
lst_models_full[[best_mb.splsdrcox_mixOmics$class]] = best_mb.splsdrcox_mixOmics
lst_models[[best_mb.splsdrcox_mixOmics$class]] = best_mb.splsdrcox_mixOmics
lst_models_pls[[best_mb.splsdrcox_mixOmics$class]] = best_mb.splsdrcox_mixOmics
save(list = c("cv.mb.splsdrcox_mixOmics_res", "best_mb.splsdrcox_mixOmics"), file = paste0(aux_folder, "mb.splsdrcox.RData"))
gc()
}
# Survival Parameters
MIN_EPV = 5
pred.attr = "mean"
# Algorithm Parameters
remove_non_significant = T
remove_non_significant_models = F
remove_near_zero_variance = T
remove_zero_variance = F
toKeep.zv = NULL
remove_variance_at_fold_level = F
alpha = 0.05
returnData = T
verbose = T
PARALLEL = T
# cox
FORCE = T
# SW
boostDeletion = F
BACKWARDS = T
initialModel = "NULL"
toKeep.sw = NULL
alpha_ENT = 0.1
alpha_OUT = 0.15
alpha_PH  = 0.05
check_PH = F
# coxEN
EN.alpha.list = seq(0,1,0.1)
# PLS
max.ncomp = 10
max.iter = 500
tol = 1e-15
# Cross Validation Parameters
times = NULL
return_models = F
seed = 123
# Weights Parameters
w_AIC = 0
w_c.index = 0
w_AUC = 1
# sPLS-DR-cox
eta.list = seq(0,0.9,0.25)
# mixOmics
vector = NULL
if(data_type %in% c("1","CLINICAL")){
MIN_NVAR = 1 #in order to create a vector and not only get the maximum number of variables if lesser than 10
}else{
MIN_NVAR = 10
}
MAX_NVAR = 1000
n.cut_points = 5
# Eval stop detection
MIN_AUC_INCREASE = 0.01 # 1%
MIN_AUC = 0.75 # 75%
MIN_COMP_TO_CHECK = 3
EVAL_METHOD = "cenROC"
# Model Lists
lst_models_full <- NULL
lst_models <- NULL
lst_models_pls <- NULL
# Evaluation multiple models
max_time_points = 15
#### ### ### #### ### ### ###
#Cross Validation Parameters #
#### ### ### ### ### #### ###
n_run = 5
k_folds = 10
fast_mode = F
pred.method = "cenROC"
aux_folder = paste0(folder, "mb.splsdrcox_mixOmics_plot/")
dir.create(aux_folder)
cv.mb.splsdrcox_mixOmics_res <- cv.mb.splsdrcox(X = X_train, Y = data.matrix(Y_train),
max.ncomp = max.ncomp, n_run = n_run, k_folds = k_folds,
vector = vector, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points, EVAL_METHOD = EVAL_METHOD,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha, remove_non_significant_models = remove_non_significant_models,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC, times = times, max_time_points = max_time_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center, y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV, tol = tol,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL, verbose = verbose)
PARALLEL = F
max.ncomp = 2
n_run = 1
k_folds = 4
cv.mb.splsdrcox_mixOmics_res <- cv.mb.splsdrcox(X = X_train, Y = data.matrix(Y_train),
max.ncomp = max.ncomp, n_run = n_run, k_folds = k_folds,
vector = vector, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points, EVAL_METHOD = EVAL_METHOD,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha, remove_non_significant_models = remove_non_significant_models,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC, times = times, max_time_points = max_time_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center, y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV, tol = tol,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL, verbose = verbose)
X = X_train
Y = data.matrix(Y_train)
t1 <- Sys.time()
#### ### ###
# WARNINGS #
#### ### ###
#### REQUIREMENTS
checkY.colnames(Y)
check.cv.weights(c(w_AIC, w_c.index, w_AUC))
# if(!pred.method %in% c("risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I")){
#   stop_quietly(paste0("pred.method must be one of the following: ", paste0(c("risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I"), collapse = ", ")))
# }
if(!pred.method %in% pkg.env$AUC_evaluators){
stop_quietly(paste0("pred.method must be one of the following: ", paste0(pkg.env$AUC_evaluators, collapse = ", ")))
}
#### ZERO VARIANCE - ALWAYS
if(!remove_variance_at_fold_level & (remove_near_zero_variance | remove_zero_variance)){
lst_dnz <- deleteZeroOrNearZeroVariance.mb(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
}else{
variablesDeleted <- NULL
}
max.ncomp <- check.mb.ncomp(X, max.ncomp)
#### MAX PREDICTORS
max.ncomp <- check.mb.maxPredictors(X, Y, MIN_EPV, max.ncomp, verbose = verbose)
#### #
# CV #
#### #
set.seed(seed)
lst_data <- splitData_Iterations_Folds.mb(X, Y, n_run = n_run, k_folds = k_folds) #FOR TEST
lst_X_train <- lst_data$lst_X_train
lst_Y_train <- lst_data$lst_Y_train
lst_X_test <- lst_data$lst_X_test
lst_Y_test <- lst_data$lst_Y_test
#### ### ### ###
# TRAIN MODELS #
#### ### ### ###
total_models <- 1 * k_folds * n_run
best_mb.splsdrcox_mixOmics <- mb.splsdrcox(X = X_train,
Y = Y_train,
n.comp = 2,
vector = NULL,
x.center = x.center, x.scale = x.scale,
y.scale = y.scale, y.center = y.center,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
pred.method = pred.method, MIN_EPV = MIN_EPV, PARALLEL = PARALLEL, tol = tol,
returnData = returnData, verbose = verbose)
X = X_train
Y = Y_train
n.comp = 2
vector = NULL
t1 <- Sys.time()
#### Original data
X_original <- X
Y_original <- Y
time <- Y[,"time"]
event <- Y[,"event"]
#### REQUIREMENTS
lst_check <- checkXY.mb.class(X, Y, verbose = verbose)
X <- lst_check$X
Y <- lst_check$Y
checkY.colnames(Y)
#### ZERO VARIANCE - ALWAYS
lst_dnz <- deleteZeroOrNearZeroVariance.mb(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
#### SCALING
lst_scale <- XY.mb.scale(X, Y, x.center, x.scale, y.center, y.scale)
Xh <- lst_scale$Xh
Yh <- lst_scale$Yh
xmeans <- lst_scale$xmeans
xsds <- lst_scale$xsds
ymeans <- lst_scale$ymeans
ysds <- lst_scale$ysds
X_norm <- Xh
#### MAX PREDICTORS
n.comp <- check.mb.maxPredictors(X, Y, MIN_EPV, n.comp, verbose = verbose)
E <- list()
R2 <- list()
SCR <- list()
SCT <- list()
XXNA <- purrr::map(Xh, ~is.na(.)) #T is NA
YNA <- is.na(Y) #T is NA
#### ### ### ### ### ### ### ### ### ### ###
# ##          MB:sPLS-COX              ## ##
#### ### ### ### ### ### ### ### ### ### ###
#2. Surv function - NULL model
coxDR <- survival::coxph(survival::Surv(time = time, event = event, type = "right") ~ 1, as.data.frame(Xh))
#3. Residuals - Default is deviance because eval type="deviance"
DR_coxph <- residuals(coxDR, type = "deviance") #"martingale", "deviance", "score", "schoenfeld", "dfbeta"', "dfbetas", "scaledsch" and "partial"
#### ### ### ### ### ### ### ### ### ### ### ###
##                                            ##
##  Beginning of the loop for the components  ##
##                                            ##
#### ### ### ### ### ### ### ### ### ### ### ###
#4. MO-sPLS Algorithm
n_var <- purrr::map(Xh, ~ncol(.))
n_dr <- purrr::map(DR_coxph, ~ncol(.))
if(any(unlist(purrr::map(n_dr, ~is.null(.))))){
n_dr[unlist(purrr::map(n_dr, ~is.null(.)))==T] = 1
}
#CENTER DEVIANCE RESIUDALS
mu <- mean(DR_coxph) #equivalent because Y it is not normalized
DR_coxph <- scale(DR_coxph, center = mu, scale = FALSE) #center DR to DR / patients
DR_coxph_ori <- DR_coxph
# set up a full design where every block is connected
design = matrix(1, ncol = length(Xh), nrow = length(Xh),
dimnames = list(c(names(Xh)), c(names(Xh))))
diag(design) =  0
#### ### ### ### ### ### ### ### ### ###
# DIVIDE Y VENCERAS - BEST VECTOR SIZE #
#### ### ### ### ### ### ### ### ### ###
vector
keepX <- getBestVectorMB(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
EVAL_EVALUATOR = pred.method
PARALLEL = F
mode = "spls"
if(!mode %in% c("spls", "splsda")){
stop("Mode must be one of: 'spls' or 'splsda'")
}
max_ncol <- purrr::map(Xh, ~ncol(.))
#vector <- purrr::map(names(Xh), ~c(min(MIN_NVAR, max_ncol[[.]]), (max_ncol[[.]]+min(MIN_NVAR, max_ncol[[.]]))/2, min(max_ncol[[.]], MAX_NVAR)))
vector <- purrr::map(names(Xh), ~getVectorCuts(vector = c(min(MIN_NVAR, max_ncol[[.]]):min(max_ncol[[.]], MAX_NVAR)), cut_points = cut_points, verbose = verbose))
names(vector) <- names(Xh)
vector
names(Xh)
cut_points
cut_points = 5
#vector <- purrr::map(names(Xh), ~c(min(MIN_NVAR, max_ncol[[.]]), (max_ncol[[.]]+min(MIN_NVAR, max_ncol[[.]]))/2, min(max_ncol[[.]], MAX_NVAR)))
vector <- purrr::map(names(Xh), ~getVectorCuts(vector = c(min(MIN_NVAR, max_ncol[[.]]):min(max_ncol[[.]], MAX_NVAR)), cut_points = cut_points, verbose = verbose))
names(vector) <- names(Xh)
vector
if(verbose){
message(paste0("Original vector: "))
message(paste0("Block ", names(vector), ": ", paste0(vector), "\n"))
}
lst_mb.spls <- list()
count = 1
var_exp = NULL
#if n_col is minimum than MIN_NVAR, values could be the same, so delete duplicates
vector <- purrr::map(vector, ~unique(.))
l <- vector
all_comb <- expand.grid(l)
## ALL POSSIBLE COMBINATIONS WITH N_VECTOR AND M_BLOCKS
## So we are trying all different number of variables per block
list_KeepX <- list()
for(i in 1:nrow(all_comb)){
keepX = list()
iter_name = NULL
for(k in names(Xh)){
keepX[[k]] = rep(all_comb[[k]][[i]], n.comp)
iter_name = c(iter_name, keepX[[k]][[1]])
}
list_KeepX[[paste0(iter_name, collapse = "_")]] <- keepX
}
if(PARALLEL){
n_cores <- future::availableCores() - 1
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(list_KeepX), n_cores))
}else{
future::plan("multisession", workers = min(length(list_KeepX), n_cores))
}
t1 <- Sys.time()
if(mode %in% "spls"){
lst_cox_value <- furrr::future_map(list_KeepX, ~getCIndex_AUC_CoxModel_block.spls(Xh = Xh, DR_coxph_ori = DR_coxph, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, EVAL_EVALUATOR = EVAL_EVALUATOR, max.iter = max.iter, verbose = verbose, time = time, max_time_points = max_time_points), .progress = F)
}else{
lst_cox_value <- furrr::future_map(list_KeepX, ~getCIndex_AUC_CoxModel_block.splsda(Xh = Xh, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, EVAL_EVALUATOR = EVAL_EVALUATOR, max.iter = max.iter, verbose = verbose, time = time, max_time_points = max_time_points), .progress = F)
}
t2 <- Sys.time()
future::plan("sequential")
}else{
t1 <- Sys.time()
if(mode %in% "spls"){
lst_cox_value <- purrr::map(list_KeepX, ~getCIndex_AUC_CoxModel_block.spls(Xh = Xh, DR_coxph_ori = DR_coxph, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, EVAL_EVALUATOR = EVAL_EVALUATOR, max.iter = max.iter, verbose = verbose, time = time, max_time_points = max_time_points), .progress = F)
}else{
lst_cox_value <- purrr::map(list_KeepX, ~getCIndex_AUC_CoxModel_block.splsda(Xh = Xh, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, EVAL_EVALUATOR = EVAL_EVALUATOR, max.iter = max.iter, verbose = verbose, time = time, max_time_points = max_time_points), .progress = F)
}
t2 <- Sys.time()
}
df_cox_value <- NULL
for(i in 1:length(lst_cox_value)){
if(EVAL_METHOD=="AUC"){
df_cox_value <- rbind(df_cox_value, lst_cox_value[[i]]$AUC)
}else{
df_cox_value <- rbind(df_cox_value, lst_cox_value[[i]]$c_index)
}
rownames(df_cox_value) <- names(list_KeepX)
index <- which.max(df_cox_value) #MAX CONCORDANCE
#Select best keepX
keepX <- list_KeepX[[index]]
FLAG = T
cont = 0
best_c_index <- df_cox_value[index]
best_keepX <- keepX
if(verbose){
message(paste0("First selection: \n"), paste0(paste0("Block ", names(best_keepX), ": ", unlist(purrr::map(best_keepX, ~unique(.)))), "\n"), "Pred. Value: ", round(best_c_index, 4), "\n")
}
ori_vector <- vector
aux_vector <- vector
while(FLAG){
cont = cont + 1
if(verbose){
message(paste0("Iteration: ", cont, "\n"))
}
new_vector <- list()
#before_vector
for(b in names(best_keepX)){
aux <- best_keepX[[b]][[1]]
index <- which(aux_vector[[b]] < aux)
if(length(index)==0){
value = aux_vector[[b]][which(aux_vector[[b]] == aux)]
}else{
value = round(mean(c(aux, aux_vector[[b]][index][[length(aux_vector[[b]][index])]]))) #last smaller
}
new_vector[[b]] <- unique(c(new_vector[[b]], aux, value))
}
#next_vector - always go two sides
for(b in names(best_keepX)){
aux <- best_keepX[[b]][[1]]
index <- which(aux_vector[[b]] > aux)
if(length(index)==0){
value = aux_vector[[b]][which(aux_vector[[b]] == aux)]
}else{
value = round(mean(c(aux, aux_vector[[b]][index][[1]]))) #first greater
}
new_vector[[b]] <- unique(c(new_vector[[b]], aux, value))
}
if(verbose){
message(paste0("Testing: \n"), paste0("Block ", names(best_keepX), ": ", new_vector, "\n"))
}
all_comb <- expand.grid(new_vector)
### update all vector
aux_vector <- purrr::map(names(new_vector), ~unique(c(aux_vector[[.]], new_vector[[.]])))
names(aux_vector) <- names(new_vector)
aux_vector <- purrr::map(names(new_vector), ~aux_vector[[.]][order(aux_vector[[.]])])
names(aux_vector) <- names(new_vector)
### OTHER KEEP_VECTOR
list_KeepX_aux <- list()
for(i in 1:nrow(all_comb)){
keepX_aux = list()
iter_name = NULL
for(k in names(Xh)){
keepX_aux[[k]] = rep(all_comb[[k]][[i]], n.comp)
iter_name = c(iter_name, keepX_aux[[k]][[1]])
}
if(paste0(iter_name, collapse = "_") %in% names(list_KeepX_aux)){
next #one already computed
}
list_KeepX_aux[[paste0(iter_name, collapse = "_")]] <- keepX_aux
}
## Compute next c_index
if(PARALLEL){
n_cores <- future::availableCores() - 1
if(.Platform$OS.type == "unix") {
future::plan("multicore", workers = min(length(list_KeepX_aux), n_cores))
}else{
future::plan("multisession", workers = min(length(list_KeepX_aux), n_cores))
}
t1 <- Sys.time()
if(mode %in% "spls"){
lst_cox_value <- furrr::future_map(list_KeepX_aux, ~getCIndex_AUC_CoxModel_block.spls(Xh = Xh, DR_coxph_ori = DR_coxph, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, max.iter = max.iter, verbose = verbose, time = time, max_time_points = max_time_points), .progress = F)
}else{
lst_cox_value <- furrr::future_map(list_KeepX_aux, ~getCIndex_AUC_CoxModel_block.splsda(Xh = Xh, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, max.iter = max.iter, verbose = verbose, time = time, max_time_points = max_time_points), .progress = F)
}
t2 <- Sys.time()
future::plan("sequential")
}else{
t1 <- Sys.time()
if(mode %in% "spls"){
lst_cox_value <- purrr::map(list_KeepX_aux, ~getCIndex_AUC_CoxModel_block.spls(Xh = Xh, DR_coxph_ori = DR_coxph, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, max.iter = max.iter, verbose = verbose, time = time, max_time_points = max_time_points), .progress = F)
}else{
lst_cox_value <- purrr::map(list_KeepX_aux, ~getCIndex_AUC_CoxModel_block.splsda(Xh = Xh, Yh = Yh, n.comp = n.comp, keepX = ., scale = F, near.zero.var = F, max.iter = max.iter, verbose = verbose, time = time, max_time_points = max_time_points), .progress = F)
}
t2 <- Sys.time()
}
df_cox_value_aux <- NULL
for(i in 1:length(lst_cox_value)){
if(EVAL_METHOD=="AUC"){
df_cox_value_aux <- rbind(df_cox_value_aux, lst_cox_value[[i]]$AUC)
}else{
df_cox_value_aux <- rbind(df_cox_value_aux, lst_cox_value[[i]]$c_index)
}
rownames(df_cox_value_aux) <- names(list_KeepX_aux)
#index <- which.max(rowSums(df_cox_value_aux)) #MAX VAR_MEDIA
#index <- which.max(df_cox_value_aux[,"Y"]) #MAX Y?
index <- which.max(df_cox_value_aux) #MAX CONCORDANCE
best_c_index_aux <- df_cox_value_aux[index]
if(best_c_index >= best_c_index_aux | best_c_index_aux-best_c_index <= MIN_AUC_INCREASE){
FLAG = F
if(verbose){
message(paste0("End: \n"), paste0(paste0("Block ", names(best_keepX), ": ", unlist(purrr::map(best_keepX, ~unique(.)))), "\n"), paste0("Pred. Value: ", round(best_c_index, 4), "\n"))
}
}else{
best_c_index <- best_c_index_aux
best_keepX <- list_KeepX_aux[[index]]
if(verbose){
message(paste0("New Vector: \n"), paste0(paste0("Block ", names(best_keepX), ": ", unlist(purrr::map(best_keepX, ~unique(.)))), "\n"), paste0("Pred. Value: ", round(best_c_index_aux, 4), "n"))
}
keepX <- best_keepX
keepX <- getBestVectorMB(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
times
keepX <- getBestVectorMB(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
Y
times
devtools::load_all(".")
keepX <- getBestVectorMB(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
vector
times
keepX <- getBestVectorMB(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
devtools::load_all(".")
keepX <- getBestVectorMB(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
devtools::load_all(".")
keepX <- getBestVectorMB(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
rlang::last_error()
keepX <- getBestVectorMB(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
method
times
devtools::load_all(".")
best_mb.splsdrcox_mixOmics <- mb.splsdrcox(X = X_train,
Y = Y_train,
n.comp = cv.mb.splsdrcox_mixOmics_res$opt.comp,
vector = cv.mb.splsdrcox_mixOmics_res$opt.nvar,
x.center = x.center, x.scale = x.scale,
y.scale = y.scale, y.center = y.center,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
pred.method = pred.method, MIN_EPV = MIN_EPV, PARALLEL = PARALLEL, tol = tol,
returnData = returnData, verbose = verbose)
best_mb.splsdrcox_mixOmics <- mb.splsdrcox(X = X_train,
Y = Y_train,
n.comp = 2,
vector = NULL,
x.center = x.center, x.scale = x.scale,
y.scale = y.scale, y.center = y.center,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
pred.method = pred.method, MIN_EPV = MIN_EPV, PARALLEL = PARALLEL, tol = tol,
returnData = returnData, verbose = verbose)
times
devtools::load_all(".")
best_mb.splsdrcox_mixOmics <- mb.splsdrcox(X = X_train,
Y = Y_train,
n.comp = 2,
vector = NULL,
x.center = x.center, x.scale = x.scale,
y.scale = y.scale, y.center = y.center,
remove_non_significant = remove_non_significant,
remove_near_zero_variance = remove_near_zero_variance, remove_zero_variance = remove_zero_variance, toKeep.zv = toKeep.zv,
pred.method = pred.method, MIN_EPV = MIN_EPV, PARALLEL = PARALLEL, tol = tol,
returnData = returnData, verbose = verbose)
save.image("C:/Users/pedro/Desktop/MB_test.RData")
?times()
