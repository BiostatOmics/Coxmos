brier_survcomp
?sbrier.score2proba
?pec
aux <- as.data.frame(cbind(X_test_mod, Y_test))
colnames(aux)[ncol(aux)] <- "status"
colnames(aux)[ncol(aux)-1] <- "time"
brier_3 = list()
cont = 0
for(t in times[2:length(times)]){
brier_3[[cont]] <- SurvMetrics_BRIER(cox = cox, data = aux, t = t)
cont = cont + 1
}
times
for(t in times[times!=0]){
brier_3[[cont]] <- SurvMetrics_BRIER(cox = cox, data = aux, t = t)
cont = cont + 1
}
cox
aux
t
SurvMetrics::Brier(object = cox, pre_sp = data, t_star = t)
# data: should be a survival dataset on which you want to caculate the Brier Score of the fitted model
cox$naive.var <- NULL
devtools::load_all(".")
aux <- as.data.frame(cbind(X_test_mod, Y_test))
colnames(aux)[ncol(aux)] <- "status"
colnames(aux)[ncol(aux)-1] <- "time"
brier_3 = list()
cont = 0
for(t in times[times!=0]){
brier_3[[cont]] <- SurvMetrics_BRIER(cox = cox, data = aux, t = t)
cont = cont + 1
}
cont
cont = 1
for(t in times[times!=0]){
brier_3[[cont]] <- SurvMetrics_BRIER(cox = cox, data = aux, t = t)
cont = cont + 1
}
brier_3
brier_3[[cont]] <- SurvMetrics_BRIER(cox = cox, data = aux, t = 1:30)
?SurvMetrics::Brier
brier_survMetrics = list()
aux <- as.data.frame(cbind(X_test_mod, Y_test))
colnames(aux)[ncol(aux)] <- "status"
colnames(aux)[ncol(aux)-1] <- "time"
brier_survMetrics = list()
cont = 1
for(t in times[times!=0]){
brier_survMetrics$error <- c(brier_survMetrics$error, SurvMetrics_BRIER(cox = cox, data = aux, t = t))
cont = cont + 1
}
brier_survMetrics$times <- times[times!=0]
brier_survMetrics
brier_survcomp$times
# for(t in times[times!=0]){
for (t in brier_survcomp$times){
brier_survMetrics$error <- c(brier_survMetrics$error, SurvMetrics_BRIER(cox = cox, data = aux, t = t))
cont = cont + 1
}
cont = 1
brier_survMetrics = list()
cont = 1
# for(t in times[times!=0]){
for (t in brier_survcomp$times){
brier_survMetrics$error <- c(brier_survMetrics$error, SurvMetrics_BRIER(cox = cox, data = aux, t = t))
cont = cont + 1
}
brier_survMetrics$times <- times[times!=0]
brier_survMetrics
brier
brier_survcomp
brier_pec
cox <- model$survival_model$fit
brier_survMetrics <- SurvMetrics_BRIER(model = model, X_test_mod = X_test_mod, Y_test = Y_test, times = times)
brier_survMetrics
devtools::load_all(".")
brier_survMetrics <- SurvMetrics_BRIER(model = model, X_test_mod = X_test_mod, Y_test = Y_test, times = times)
aux <- as.data.frame(cbind(X_test_mod, Y_test))
colnames(aux)[ncol(aux)] <- "status"
colnames(aux)[ncol(aux)-1] <- "time"
cox <- model$survival_model$fit
cox$naive.var <- NULL #must be NULL to work - predictCox does not know how to handle frailty
brier_survMetrics = list()
aux
brier_survMetrics$error <- c(brier_survMetrics$error, SurvMetrics::Brier(object = cox, pre_sp = aux, t_star = t))
brier_survMetrics
devtools::load_all(".")
brier_survMetrics <- SurvMetrics_BRIER(model = model, X_test_mod = X_test_mod, Y_test = Y_test, times = times)
brier_survMetrics
mean(brier_survMetrics$error)
median(brier_survMetrics$error)
devtools::load_all(".")
check(vignettes = F)
X = X_train
Y = Y_train
devtools::load_all(".")
#BRIER
#lst_BRIER_values <- survAUC_BRIER_LP(lp = lp$fit, Y = Yh, lp_new = lp$fit, Y_test = Yh)
lst_BRIER_values <- SURVCOMP_BRIER_LP(model = model, lp_test = lp$fit, Y_test = Yh)
devtools::load_all(".")
X = X_train
Y = Y_train
n.comp = 2
vector = 49
x.center = T
y.center = F
y.scale = F
x.scale = F
remove_near_zero_variance = T
remove_zero_variance = F
toKeep.zv = NULL
n.cut_points = 5
MAX_NVAR = 1000
MIN_NVAR = 10
MIN_AUC_INCREASE = 0.01
EVAL_METHOD = "AUC"
pred.method = "cenROC"
max.iter = 200
verbose = F
returnData = T
MIN_EPV = 5
t1 <- Sys.time()
#### Original data
X_original <- X
Y_original <- Y
time <- Y[,"time"]
event <- Y[,"event"]
#### REQUIREMENTS
lst_check <- checkXY.class(X, Y, verbose = verbose)
X <- lst_check$X
Y <- lst_check$Y
checkY.colnames(Y)
# if(k_folds.mixOmics<2){
#   message("MixOmics k_folds must be 2 as minimum.")
#   k_folds.mixOmics = 2
# }
#### ZERO VARIANCE - ALWAYS
lst_dnz <- deleteZeroOrNearZeroVariance(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
#### SCALING
lst_scale <- XY.scale(X, Y, x.center, x.scale, y.center, y.scale)
Xh <- lst_scale$Xh
Yh <- lst_scale$Yh
xmeans <- lst_scale$xmeans
xsds <- lst_scale$xsds
ymeans <- lst_scale$ymeans
ysds <- lst_scale$ysds
X_norm <- Xh
#### MAX PREDICTORS
n.comp <- check.maxPredictors(X, Y, MIN_EPV, n.comp)
E <- list()
R2 <- list()
SCR <- list()
SCT <- list()
XXNA <- is.na(Xh) #T is NA
YNA <- is.na(Y) #T is NA
#### ### ### ### ### ### ### ### ### ### ### ###
### ###             sPLS-COX             ### ###
#### ### ### ### ### ### ### ### ### ### ### ###
#2. Surv function - NULL model
coxDR <- survival::coxph(survival::Surv(time = time, event = event, type = "right") ~ 1, as.data.frame(Xh))
#3. Residuals - Default is deviance because eval type="deviance"
DR_coxph <- residuals(coxDR, type = "deviance") #"martingale", "deviance", "score", "schoenfeld", "dfbeta"', "dfbetas", "scaledsch" and "partial"
#### ### ### ### ### ### ### ### ### ### ### ###
##                                            ##
##  Beginning of the loop for the components  ##
##                                            ##
#### ### ### ### ### ### ### ### ### ### ### ###
#4. sPLS Algorithm
n_obs <- nrow(Xh)
n_var <- ncol(Xh)
n_dr <- ncol(DR_coxph)
if(is.null(n_dr))
n_dr=1
#Norm Y
mu <- mean(DR_coxph) #equivalent because Y it is not normalized
DR_coxph <- scale(DR_coxph, center = mu, scale = FALSE) #center DR to DR / patients
DR_coxph_ori <- DR_coxph
#Norm X - Do not center again
# x_center_by_nobs <- colMeans(Xh, na.rm = T)
# Xh <- scale(Xh, center = x_center_by_nobs, scale = FALSE)
flag = T
cv.spls <- NA
#### ### ### ### ### ### ### ### ### ###
# DIVIDE Y VENCERAS - BEST VECTOR SIZE #
#### ### ### ### ### ### ### ### ### ###
if(is.null(vector)){
lst_BV <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
keepX <- lst_BV$best.keepX
plotVAR <- plot_VAR_eval(lst_BV, EVAL_METHOD = EVAL_METHOD)
}else{
if(is.numeric(vector)){
keepX <- vector
if(length(keepX)>1){
message("keepX must be a number, not a vector. Maximum value will be selected for compute the sPLS model.")
keepX <- max(keepX)
}
if(keepX>ncol(X)){
message("keepX must be a lesser than the number of columns in X. The value will be updated to that one.")
keepX <- ncol(X)
}
}else{
message("Vector does not has the proper structure. Optimizing best n.variables by using your vector as start vector.")
lst_BV <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector = NULL, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
keepX <- lst_BV$best.keepX
}
#### ### ### ### ### ### ### ### ### ### ###
### ##             sPLS              ###  ##
#### ### ### ### ### ### ### ### ### ### ###
spls <- mixOmics::spls(X = Xh, Y = DR_coxph_ori, ncomp = n.comp, keepX = rep(keepX, n.comp), scale = F)
# PREDICTION
# both functions work fine (predict and predict.mixOmixs.pls)
# predplsfit <- predict.mixOmixs.pls(spls, newdata=Xh[,rownames(spls$loadings$X),drop=F])
# predplsfit <- predict(spls, newdata=Xh[,rownames(spls$loadings$X),drop=F])
# sometimes solve(t(P) %*% W) in predict can cause an error
# system is computationally singular: reciprocal condition number = 6.24697e-18
predplsfit <- tryCatch(expr = {predict(spls, newdata=Xh[,rownames(spls$loadings$X),drop=F])},
error = function(e){
if(verbose){
message(e$message)
}
NA
})
if(!all(is.na(predplsfit))){
# R2 calculation
for(h in 1:n.comp){
E[[h]] <- DR_coxph_ori - predplsfit$predict[,,h]
SCR[[h]] = sum(apply(E[[h]],2,function(x) sum(x**2)))
SCT[[h]] = sum(apply(as.matrix(DR_coxph_ori),2,function(x) sum(x**2))) #equivalent sum((DR_coxph_ori - mean(DR_coxph_ori))**2)
R2[[h]] = 1 - (SCR[[h]]/SCT[[h]]) #deviance residuals explanation
}
}else{
E <- NULL
SCR <- NULL
SCT <- NULL
R2 <- NULL
}
#last model includes all of them
tt_splsDR = spls$variates$X
ww_splsDR = spls$loadings$X
rr_splsDR = spls$loadings.star
pp_splsDR = spls$mat.c
#### ### ### ### ### ### ### ### ### ### ### #
#                                            #
#      Computation of the coefficients       #
#      of the model with kk components       #
#                                            #
#### ### ### ### ### ### ### ### ### ### ### #
#### ### ### ### ### ### ## ### ### ### ### #
### ##              PLS-COX            ### ##
#### ### ### ### ### ### ## ### ### ### ### #
n.comp_used <- ncol(tt_splsDR) #can be lesser than expected because we have lesser variables to select because penalization
n.varX_used <- keepX
d <- as.data.frame(tt_splsDR[,,drop=F])
rownames(d) <- rownames(X)
colnames(d) <- paste0("comp_", 1:n.comp_used)
cox_model <- NULL
cox_model$fit <- tryCatch(
# Specifying expression
expr = {
survival::coxph(formula = survival::Surv(time,event) ~ .,
data = d,
ties = "efron",
singular.ok = T,
robust = T,
nocenter = rep(1, ncol(d)),
model=T, x = T)
},
# Specifying error message
error = function(e){
message(paste0("splsdrcox_dynamic: ",conditionMessage(e)))
invisible(gc())
return(NA)
}
)
#RETURN a MODEL with ALL significant Variables from complete, deleting one by one in backward method
removed_variables <- NULL
if(remove_non_significant){
if(all(c("time", "event") %in% colnames(d))){
lst_rnsc <- removeNonSignificativeCox(cox = cox_model$fit, alpha = alpha, cox_input = d, time.value = NULL, event.value = NULL)
}else{
lst_rnsc <- removeNonSignificativeCox(cox = cox_model$fit, alpha = alpha, cox_input = cbind(d, Yh), time.value = NULL, event.value = NULL)
}
cox_model$fit <- lst_rnsc$cox
removed_variables <- lst_rnsc$removed_variables
}
survival_model <- NULL
if(!length(cox_model$fit) == 1){
survival_model <- getInfoCoxModel(cox_model$fit)
}
#get W.star
W <- ww_splsDR
P <- pp_splsDR
if(is.null(P) | is.null(W)){
message(paste0(pkg.env$splsdrcox_dynamic," model cannot be computed because P or W vectors are NULL. Returning NA."))
invisible(gc())
return(NA)
}
#W.star
#sometimes solve(t(P) %*% W)
#system is computationally singular: reciprocal condition number = 6.24697e-18
PW <- tryCatch(expr = {solve(t(P) %*% W, tol = tol)},
error = function(e){
if(verbose){
message(e$message)
}
NA
})
if(all(is.na(PW))){
message(paste0(pkg.env$splsdrcox_dynamic," model cannot be computed due to solve(t(P) %*% W). Reduce 'tol' parameter to fix it. Returning NA."))
invisible(gc())
return(NA)
}
W.star <- W %*% PW
Ts <- tt_splsDR
func_call <- match.call()
rownames(Ts) <- rownames(X)
rownames(P) <- rownames(W) <-  rownames(W.star) <- rownames(ww_splsDR)
colnames(Ts) <- colnames(P) <- colnames(W) <-  colnames(W.star)<- paste0("comp_", 1:n.comp_used)
t2 <- Sys.time()
time <- difftime(t2,t1,units = "mins")
var_by_component
n.varX_used
P
pp_splsDR
dim(pp_splsDR)
ww_splsDR
rr_splsDR
pp_splsDR
colnames(W)
cn = "comp_1"
W[,cn]!=0
rownames(W)[W[,cn]!=0]
length(rownames(W)[W[,cn]!=0])
# variable per component
var_by_component = list()
for(cn in colnames(W)){
var_by_component[[cn]] <- rownames(W)[W[,cn]!=0]
}
var_by_component
plotVAR
lst_BV <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
t1 <- Sys.time()
#### Original data
X_original <- X
Y_original <- Y
time <- Y[,"time"]
event <- Y[,"event"]
#### REQUIREMENTS
lst_check <- checkXY.class(X, Y, verbose = verbose)
X <- lst_check$X
Y <- lst_check$Y
checkY.colnames(Y)
#### ZERO VARIANCE - ALWAYS
lst_dnz <- deleteZeroOrNearZeroVariance(X = X,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
freqCut = 95/5)
X <- lst_dnz$X
variablesDeleted <- lst_dnz$variablesDeleted
#### SCALING
lst_scale <- XY.scale(X, Y, x.center, x.scale, y.center, y.scale)
Xh <- lst_scale$Xh
Yh <- lst_scale$Yh
xmeans <- lst_scale$xmeans
xsds <- lst_scale$xsds
ymeans <- lst_scale$ymeans
ysds <- lst_scale$ysds
X_norm <- Xh
#### MAX PREDICTORS
n.comp <- check.maxPredictors(X, Y, MIN_EPV, n.comp)
E <- list()
R2 <- list()
SCR <- list()
SCT <- list()
XXNA <- is.na(Xh) #T is NA
YNA <- is.na(Y) #T is NA
#2. Surv function - NULL model
coxDR <- survival::coxph(survival::Surv(time = time, event = event, type = "right") ~ 1, as.data.frame(Xh))
#3. Residuals - Default is deviance because eval type="deviance"
DR_coxph <- residuals(coxDR, type = "deviance") #"martingale", "deviance", "score", "schoenfeld", "dfbeta"', "dfbetas", "scaledsch" and "partial"
#4. sPLS Algorithm
n_obs <- nrow(Xh)
n_var <- ncol(Xh)
n_dr <- ncol(DR_coxph)
if(is.null(n_dr))
n_dr=1
#Norm Y
mu <- mean(DR_coxph) #equivalent because Y it is not normalized
DR_coxph <- scale(DR_coxph, center = mu, scale = FALSE) #center DR to DR / patients
DR_coxph_ori <- DR_coxph
#Norm X - Do not center again
# x_center_by_nobs <- colMeans(Xh, na.rm = T)
# Xh <- scale(Xh, center = x_center_by_nobs, scale = FALSE)
flag = T
cv.spls <- NA
if(is.null(vector)){
lst_BV <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
keepX <- lst_BV$best.keepX
plotVAR <- plot_VAR_eval(lst_BV, EVAL_METHOD = EVAL_METHOD)
}else{
if(is.numeric(vector)){
keepX <- vector
if(length(keepX)>1){
message("keepX must be a number, not a vector. Maximum value will be selected for compute the sPLS model.")
keepX <- max(keepX)
}
if(keepX>ncol(X)){
message("keepX must be a lesser than the number of columns in X. The value will be updated to that one.")
keepX <- ncol(X)
}
}else{
message("Vector does not has the proper structure. Optimizing best n.variables by using your vector as start vector.")
lst_BV <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector = NULL, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
keepX <- lst_BV$best.keepX
}
plotVAR
vector
vector = NULL
lst_BV <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
keepX <- lst_BV$best.keepX
plotVAR <- plot_VAR_eval(lst_BV, EVAL_METHOD = EVAL_METHOD)
plotVAR
n.cut_points = 20
lst_BV <- getBestVector(Xh, DR_coxph, Yh, n.comp, max.iter, vector, MIN_AUC_INCREASE, MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, cut_points = n.cut_points,
EVAL_METHOD = EVAL_METHOD, EVAL_EVALUATOR = pred.method, PARALLEL = F, mode = "spls", times = times, max_time_points = max_time_points, verbose = verbose)
keepX <- lst_BV$best.keepX
plotVAR <- plot_VAR_eval(lst_BV, EVAL_METHOD = EVAL_METHOD)
plotVAR
values = NULL #just in case
best_keepX <- lst_BV$best.keepX
best_keepX <- paste0(unlist(lapply(best_keepX, function(x){x[[1]]})), collapse = "_")
df.pval <- data.frame(names = factor(names(lst_BV$p_val), levels = names(lst_BV$p_val)), values = lst_BV$p_val)
if(EVAL_METHOD == "BRIER"){
df.pval$values <- 1- df.pval$values
}
if(requireNamespace("RColorConesa", quietly = TRUE)){
color_conesa <- RColorConesa::colorConesa(1)
}else{
color_conesa <- "blue"
}
ggp <- ggplot(df.pval, aes(x = names, y = values)) +
geom_line(group = 1, color = color_conesa, aes(size = 3)) + ylab("Pred. Value") + xlab("Number of variables")
ggp <- ggplot(df.pval, aes(x = names, y = values)) +
geom_line(group = 1, color = color_conesa, aes(linewidth = 3)) + ylab("Pred. Value") + xlab("Number of variables")
ggp <- ggp + geom_point(data = df.pval[df.pval$names==best_keepX,,drop=F],
aes(x = names, y = values, size = 3), color = color_conesa)
ggp
ggp <- ggplot(df.pval, aes(x = names, y = values)) +
geom_line(group = 1, color = color_conesa, aes(linewidth = 2)) + ylab("Pred. Value") + xlab("Number of variables")
ggp <- ggp + geom_point(data = df.pval[df.pval$names==best_keepX,,drop=F],
aes(x = names, y = values, size = 3), color = color_conesa)
ggp
ggp <- ggplot(df.pval, aes(x = names, y = values)) +
geom_line(group = 1, color = color_conesa, aes(linewidth = 1)) + ylab("Pred. Value") + xlab("Number of variables")
ggp <- ggp + geom_point(data = df.pval[df.pval$names==best_keepX,,drop=F],
aes(x = names, y = values, size = 2), color = color_conesa)
ggp
ggp <- ggplot(df.pval, aes(x = names, y = values)) +
geom_line(group = 1, color = color_conesa, aes(linewidth = 0.5)) + ylab("Pred. Value") + xlab("Number of variables")
ggp <- ggp + geom_point(data = df.pval[df.pval$names==best_keepX,,drop=F],
aes(x = names, y = values, size = 2), color = color_conesa)
ggp
ggp <- ggplot(df.pval, aes(x = names, y = values)) +
geom_line(group = 1, color = color_conesa, linewidth = 0.5) + ylab("Pred. Value") + xlab("Number of variables")
ggp <- ggplot(df.pval, aes(x = names, y = values)) +
geom_line(group = 1, color = color_conesa, linewidth = 0.5) + ylab("Pred. Value") + xlab("Number of variables")
ggp <- ggp + geom_point(data = df.pval[df.pval$names==best_keepX,,drop=F],
aes(x = names, y = values, size = 2), color = color_conesa)
ggp
ggp <- ggp + geom_point(data = df.pval[df.pval$names==best_keepX,,drop=F],
aes(x = names, y = values), color = color_conesa, size = 2)
ggp
ggp <- ggplot(df.pval, aes(x = names, y = values)) +
geom_line(group = 1, color = color_conesa, linewidth = 2) + ylab("Pred. Value") + xlab("Number of variables")
ggp <- ggp + geom_point(data = df.pval[df.pval$names==best_keepX,,drop=F],
aes(x = names, y = values), color = color_conesa, size = 2)
ggp
ggp <- ggplot(df.pval, aes(x = names, y = values)) +
geom_line(group = 1, color = color_conesa, linewidth = 1.5) + ylab("Pred. Value") + xlab("Number of variables")
ggp <- ggp + geom_point(data = df.pval[df.pval$names==best_keepX,,drop=F],
aes(x = names, y = values), color = color_conesa, size = 2)
ggp
ggp <- ggplot(df.pval, aes(x = names, y = values)) +
geom_line(group = 1, color = color_conesa, linewidth = 1.5) + ylab("Pred. Value") + xlab("Number of variables")
ggp <- ggp + geom_point(data = df.pval[df.pval$names==best_keepX,,drop=F],
aes(x = names, y = values), color = color_conesa, size = 3)
ggp
dot_size = 3
ggp <- ggplot(df.pval, aes(x = names, y = values)) +
geom_line(group = 1, color = color_conesa, linewidth = 1.5) + ylab("Pred. Value") + xlab("Number of variables")
ggp <- ggp + geom_point(data = df.pval[df.pval$names==best_keepX,,drop=F],
aes(x = names, y = values), color = color_conesa,
size = dot_size, shape = 23, fill = "white",
stroke = 2, show.legend = F)
ggp
devtools::load_all(".")
check()
check(vignettes = F)
