invisible(gc())
return(NA)
}
#W.star
#sometimes solve(t(P) %*% W)
#system is computationally singular: reciprocal condition number = 6.24697e-18
PW <- tryCatch(expr = {solve(t(P) %*% W, tol = tol)},
error = function(e){
if(verbose){
message(e$message)
}
NA
})
solve(t(P) %*% W, tol = tol)
devtools::load_all(".")
comp_model_lst  <- get_HDCOX_models2.0(method = pkg.env$splsdrcox_mixomics,
lst_X_train = lst_X_train, lst_Y_train = lst_Y_train,
max.ncomp = max.ncomp, eta.list = NULL, EN.alpha.list = NULL, n_run = n_run, k_folds = k_folds,
vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points,
MIN_AUC_INCREASE = MIN_AUC_INCREASE,
EVAL_METHOD = EVAL_METHOD,
x.center = x.center, x.scale = x.scale, y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = F, remove_zero_variance = F, toKeep.zv = NULL,
remove_non_significant = remove_non_significant, tol = tol,
total_models = total_models, PARALLEL = PARALLEL, verbose = verbose)
comp_model_lst
if(all(is.na(unlist(comp_model_lst)))){
message(paste0("Best model could NOT be obtained. All models computed present problems."))
t2 <- Sys.time()
time <- difftime(t2,t1,units = "mins")
if(return_models){
return(cv.splsdrcox_mixOmics_class(list(best_model_info = NULL, df_results_folds = NULL, df_results_runs = NULL, df_results_comps = NULL, lst_models = comp_model_lst, pred.method = pred.method, opt.comp = NULL, opt.nvar = NULL, plot_AUC = NULL, plot_c_index = NULL, plot_AIC = NULL, class = pkg.env$cv.splsdrcox_mixomics, time = time)))
}else{
return(cv.splsdrcox_mixOmics_class(list(best_model_info = NULL, df_results_folds = NULL, df_results_runs = NULL, df_results_comps = NULL, lst_models = NULL, pred.method = pred.method, opt.comp = NULL, opt.nvar = NULL, plot_AUC = NULL, plot_c_index = NULL, plot_AIC = NULL, class = pkg.env$cv.splsdrcox_mixomics, time = time)))
}
total_models <- max.ncomp * k_folds * n_run
df_results_evals <- get_COX_evaluation_AIC_CINDEX(comp_model_lst = comp_model_lst, alpha = alpha,
max.ncomp = max.ncomp, eta.list = NULL, n_run = n_run, k_folds = k_folds,
total_models = total_models, remove_non_significant_models = remove_non_significant_models, verbose = verbose)
df_results_evals
devtools::load_all(".")
cv.splsdrcox_mixOmics_res <- cv.splsdrcox_mixOmics(X = X_train, Y = Y_train,
max.ncomp = max.ncomp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points, EVAL_METHOD = EVAL_METHOD,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
remove_non_significant_models = remove_non_significant_models,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL, tol = tol,
verbose = verbose)
cv.splsdrcox_mixOmics_res
cv.splsdrcox_mixOmics_res$plot_AUC
devtools::load_all(".")
library(RColorConesa) #from GitHub #devtools #usethis and get install.packages('hrbrthemes', repos='http://cran.us.r-project.org')
#Load ggplot theme
loadGgplotTheme <- function(path){
file <- paste0(path,"ggplot_theme.R")
source(file, echo = F)
}
path <- "D:/Pedro/Mega/Doctorado/Otros proyectos/"
loadGgplotTheme(path)
load("D:/Pedro/Mega/Doctorado/Otros proyectos/data_ovarian_clinical.RData")
NAME = "OVARIAN_CLINICAL_"
# METHODS
lst_evaluations <- c("survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I", "risksetROC")
names(lst_evaluations) <- lst_evaluations
# Classical
FLAG_COX = T
FLAG_COXSW = T
# hd
FLAG_COXEN = T
FLAG_PLSICOX = T
FLAG_sPLSDRCOX = T
FLAG_sPLSDRCOX_MO = T
FLAG_sPLSDACOX_MO = T
# mo
FLAG_SB.PLSICOX = F
FLAG_FAST.SB.PLSICOX = F
FLAG_SB.sPLSDRCOX = F
FLAG_FAST.SB.sPLSDRCOX = F
FLAG_MB.sPLSDRCOX = F
FLAG_MB.sPLSDACOX = F
# Scale Parameters
x.center = T
x.scale = T
y.center = F
y.scale = F
# Survival Parameters
MIN_EPV = 5
pred.attr = "mean"
# Algorithm Parameters
remove_non_significant = T
remove_non_significant_models = F
remove_near_zero_variance = T
remove_zero_variance = F
toKeep.zv = NULL
alpha = 0.05
returnData = T
verbose = T
PARALLEL = T
# cox
FORCE = T
# SW
boostDeletion = F
BACKWARDS = T
initialModel = "NULL"
toKeep.sw = NULL
alpha_ENT = 0.1
alpha_OUT = 0.15
alpha_PH  = 0.05
check_PH = F
# coxEN
EN.alpha.list = seq(0,1,0.1)
# PLS
max.ncomp = 10
max.iter = 500
tol = 1e-15
# Cross Validation Parameters
times = NULL
return_models = F
seed = 123
# Weights Parameters
w_AIC = 0
w_c.index = 0
w_AUC = 1
# sPLS-DR-cox
eta.list = seq(0,0.9,0.25)
# mixOmics
vector = NULL
MIN_NVAR = 10
MAX_NVAR = 1000
n.cut_points = 5
EVAL_METHOD = "cenROC"
# Eval stop detection
MIN_AUC_INCREASE = 0.01 # 1%
MIN_AUC = 0.75 # 75%
MIN_COMP_TO_CHECK = 3
# Model Lists
lst_models_full <- NULL
lst_models <- NULL
lst_models_pls <- NULL
# Evaluation multiple models
max_time_points = 15
#### ### ### #### ### ### ###
#Cross Validation Parameters #
#### ### ### ### ### #### ###
n_run = 5
k_folds = 10
fast_mode = F
pred.method = "cenROC"
todaydate <- format(Sys.time(), '%Y-%m-%d')
txt_folder <- paste0(NAME,ifelse(fast_mode, "FAST_", "COMPLETE_"), pred.method, "_runs_", n_run, "_folds_", k_folds)
folder <- paste0(txt_folder,"_",todaydate,"/")
set.seed(123)
index_train <- caret::createDataPartition(Y$event,
p = .7, #70% train
list = FALSE,
times = 1)
X_train <- X[index_train,]
Y_train <- Y[index_train,]
X_test <- X[-index_train,]
Y_test <- Y[-index_train,]
### ###
# COX #
### ###
if(FLAG_COX){
aux_folder = paste0(folder, "cox_plot/")
dir.create(aux_folder)
best_cox <- cox(X = X_train, Y = Y_train,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha,
MIN_EPV = MIN_EPV,
FORCE = FORCE,
returnData = returnData,
verbose = verbose)
save(list = c("best_cox"), file = paste0(aux_folder, "cox.RData"))
gc()
lst_models_full[[best_cox$class]] = best_cox
lst_models[[best_cox$class]] = best_cox
}
best_coxSW <- coxSW(X = X_train, Y = Y_train,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
initialModel = initialModel, toKeep.sw = toKeep.sw,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
max.variables = ncol(X_train),
boostDeletion = boostDeletion,
alpha = alpha, alpha_ENT = alpha_ENT, alpha_OUT = alpha_OUT, alpha_PH  = alpha_PH, check_PH = check_PH,
MIN_EPV = MIN_EPV,
BACKWARDS = BACKWARDS, verbose = verbose)
lst_models_full[[best_coxSW$class]] = best_coxSW
lst_models[[best_coxSW$class]] = best_coxSW
best_cox <- cox(X = X_train, Y = Y_train,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha,
MIN_EPV = MIN_EPV,
FORCE = FORCE,
returnData = returnData,
verbose = verbose)
lst_models_full[[best_cox$class]] = best_cox
lst_models[[best_cox$class]] = best_cox
lst_models_full
cv.splsdrcox_mixOmics_res <- cv.splsdrcox_mixOmics(X = X_train, Y = Y_train,
max.ncomp = max.ncomp, vector = vector,
MIN_NVAR = MIN_NVAR, MAX_NVAR = MAX_NVAR, n.cut_points = n.cut_points, EVAL_METHOD = EVAL_METHOD,
n_run = n_run, k_folds = k_folds,
alpha = alpha, remove_non_significant = remove_non_significant, times = times,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
remove_non_significant_models = remove_non_significant_models,
toKeep.zv = toKeep.zv,
w_AIC = w_AIC, w_c.index = w_c.index, w_AUC = w_AUC,
MIN_AUC_INCREASE = MIN_AUC_INCREASE, MIN_AUC = MIN_AUC, MIN_COMP_TO_CHECK = MIN_COMP_TO_CHECK,
x.scale = x.scale, x.center = x.center,
y.scale = y.scale, y.center = y.center,
fast_mode = fast_mode, return_models = return_models, MIN_EPV = MIN_EPV,
pred.attr = pred.attr, pred.method = pred.method, seed = seed, PARALLEL = PARALLEL, tol = tol,
verbose = verbose)
cv.splsdrcox_mixOmics_res
cv.splsdrcox_mixOmics_res$plot_AUC
best_splsdrcox_mixOmics <- splsdrcox_mixOmics(X = X_train, Y = Y_train,
n.comp = cv.splsdrcox_mixOmics_res$opt.comp,
vector = cv.splsdrcox_mixOmics_res$opt.nvar,
x.center = x.center, x.scale = x.scale,
y.center = y.center, y.scale = y.scale,
remove_near_zero_variance = remove_near_zero_variance,
remove_zero_variance = remove_zero_variance,
toKeep.zv = toKeep.zv,
remove_non_significant = remove_non_significant,
alpha = alpha, tol = tol,
MIN_EPV = MIN_EPV,
returnData = returnData,
verbose = verbose)
lst_models_full[[cv.splsdrcox_mixOmics_res$class]] = cv.splsdrcox_mixOmics_res
lst_models_full[[best_splsdrcox_mixOmics$class]] = best_splsdrcox_mixOmics
lst_models[[best_splsdrcox_mixOmics$class]] = best_splsdrcox_mixOmics
lst_models_pls[[best_splsdrcox_mixOmics$class]] = best_splsdrcox_mixOmics
eval_results <- purrr::map(lst_evaluations, ~eval_models4.0(lst_models = lst_models,
X_test = X_test, Y_test = Y_test, pred.method = .,
pred.attr = pred.attr, verbose = verbose,
times = times, max_time_points = max_time_points, PARALLEL = PARALLEL))
lst_ggp <- plot_evaluation.list(eval_results)
lst_ggp$cenROC$lst_plots
lst_models$cox$survival_model$fit
eval_results$cenROC$df
eval_results <- eval_results$cenROC
pred.attr = "mean"
y.min = NULL
type = "both"
if(!pred.attr %in% c("mean", "median")){
stop("pred.attr parameter must be one of: 'mean' or 'median'")
}
if(!type %in% c("both", "line", "mean")){
type = "both"
}
#select minimum for all evals
if(is.null(y.min)){
y.min <- floor(min(eval_results$df$AUC, na.rm = T)*10)/10
}
if(is.infinite(y.min)){
message("All AUC is NA. Returning NA.")
return(NA)
}
lst_ggp <- list()
lst_plots <- comboplot.performance2.0(df = eval_results$df,
x.var = "time", y.var = "AUC", x.color = "method",
y.limit = c(y.min, 1), pred.attr = pred.attr)
warnings()
eval_results$df
pred.method = "cenROC"
#Check at least two events in total
checkAtLeastTwoEvents(X_test, Y_test)
#Check evaluator installed:
checkLibraryEvaluator(pred.method)
progress_bar = T
if(all(is.null(lst_models))){
stop("List of model is NULL")
}
if(!pred.attr %in% c("mean", "median")){
stop("pred.attr parameter must be one of: 'mean' or 'median'")
}
t1 <- Sys.time()
if(verbose){
message(paste0("\nEvaluating with ", pred.method, "...\n"))
}
#TEST DATA
if(is.null(times)){
times <- getVectorOfTime(Y_test, max_time_points)
}
#MULTIBLOCK
if(isa(X_test, "list")){
X_test_ori  <- purrr::map(X_test, ~data.matrix(.))
Y_test  <- Y_test
}else{
X_test_ori  <- data.matrix(X_test)
Y_test  <- Y_test
}
#models not NAs
names_lst_models <- unlist(lapply(lst_models, function(x){!all(is.na(x))}))
names_lst_models <- names(names_lst_models)[names_lst_models==T]
lst_models <- lst_models[names_lst_models]
if(progress_bar){
total_models <- length(lst_models)
pb_text <- "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated remaining time: :eta]"
pb <- progress::progress_bar$new(format = pb_text,
total = total_models,
complete = "=",   # Caracteres de las iteraciones finalizadas
incomplete = "-", # Caracteres de las iteraciones no finalizadas
current = ">",    # Caracter actual
clear = FALSE,    # Si TRUE, borra la barra cuando termine
width = 100)      # Ancho de la barra de progreso
pb$tick(0)
}
lst_eval <- list()
lst_eval <- purrr::map(lst_models, ~evaluation_list_HDcox(model = ., X_test = X_test, Y_test = Y_test, pred.method = pred.method, pred.attr = pred.attr, times = times, PARALLEL = F, verbose = verbose, progress_bar = progress_bar))
Y_test
Y_test = lst_models$cox
PARALLEL = F
t3 <- Sys.time()
#atomic vector
if(all(is.na(model))){
return(list(model_time = NA, comp.time = NA, aic.cox = NA, c_index.cox = NA, lst_AUC_values = NA))
}
#NULL in HDcox object (NA no anymore)
if(all(is.null(model$survival_model))){
return(list(model_time = NA, comp.time = NA, aic.cox = NA, c_index.cox = NA, lst_AUC_values = NA))
}
model <- lst_models$cox
t3 <- Sys.time()
#atomic vector
if(all(is.na(model))){
return(list(model_time = NA, comp.time = NA, aic.cox = NA, c_index.cox = NA, lst_AUC_values = NA))
}
#NULL in HDcox object (NA no anymore)
if(all(is.null(model$survival_model))){
return(list(model_time = NA, comp.time = NA, aic.cox = NA, c_index.cox = NA, lst_AUC_values = NA))
}
cox <- model$survival_model$fit
aic.cox <- stats::extractAIC(cox, k=2)[2] #k=2 <- AIC, [2] AIC Value
c_index.cox <- survival::concordance(cox)$concordance
cox
#linear predictors
if(isa(X_test, "list") & !attr(model, "model") %in% pkg.env$multiblock_methods){ #mix between multiblock and all PLS - Special case
which_block = purrr::map(names(X_test), ~length(grep(., m, fixed = F))>0)
names(which_block) <- names(X_test)
X_test_mod <- predict.HDcox(object = model, newdata = X_test[[names(which_block)[which_block==T]]])
}else{
X_test_mod <- predict.HDcox(object = model, newdata = X_test) #all multiblock or all PLS - Ok
}
X_test_mod
LST_KM_RES_LP <- getAutoKM.list(type = "LP",
lst_models = lst_models,
comp = 1:10,
top = 20,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05)
lst_models$`sPLS-DRCOX-MixOmics`$survival_model$fit
LST_KM_RES_LP$`sPLS-DRCOX-MixOmics`$LST_PLOTS$LP
lst_cutoff <- getCutoffAutoKM.list(LST_KM_RES_LP)
LST_KM_TEST_LP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "LP",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
LST_KM_RES_LP$coxSW$info_logrank_num$df_nvar_lrtest
devtools::load_all(".")
lst_cutoff <- getCutoffAutoKM.list(LST_KM_RES_LP)
lst_cutoff
LST_KM_TEST_LP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "LP",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
Y_test
Y_test <- Y[-index_train,]
LST_KM_TEST_LP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "LP",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
LST_KM_TEST_LP$`sPLS-DRCOX-MixOmics`
LST_KM_TEST_LP
m = "cox"
LST_KM_TEST_LP[[m]]
km_folder
km_folder = paste0(folder, "km_test_plot/")
km_folder
NAME = "OVARIAN_CLINICAL_"
todaydate <- format(Sys.time(), '%Y-%m-%d')
txt_folder <- paste0(NAME,ifelse(fast_mode, "FAST_", "COMPLETE_"), pred.method, "_runs_", n_run, "_folds_", k_folds)
folder <- paste0(txt_folder,"_",todaydate,"/")
#setwd("D:/Pedro/Mega/Doctorado/Otros proyectos/plsicox/results")
dir.create(folder)
folder
km_folder = paste0(folder, "km_train_plot/")
dir.create(km_folder)
LST_KM_RES_LP <- getAutoKM.list(type = "LP",
lst_models = lst_models,
comp = 1:10,
top = 20,
ori_data = T,
BREAKTIME = NULL,
only_sig = T, alpha = 0.05)
for(m in names(LST_KM_RES_LP)){
save_ggplot_lst.svg(lst_plots = LST_KM_RES_LP[[m]]$LST_PLOTS, object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
if(m %in% names(LST_KM_RES_COMP)){
save_ggplot_lst.svg(lst_plots = LST_KM_RES_COMP[[m]]$LST_PLOTS, object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
save_ggplot_lst.svg(lst_plots = LST_KM_RES_VAR[[m]]$LST_PLOTS, object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
LST_KM_RES_LP[[m]]
for(m in names(LST_KM_RES_LP)){
if(!is.na(LST_KM_RES_LP[[m]])){
save_ggplot_lst.svg(lst_plots = LST_KM_RES_LP[[m]]$LST_PLOTS, object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
if(m %in% names(LST_KM_RES_COMP) && !is.na(LST_KM_RES_COMP[[m]])){
save_ggplot_lst.svg(lst_plots = LST_KM_RES_COMP[[m]]$LST_PLOTS, object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
if(m %in% names(LST_KM_RES_VAR) && !is.na(LST_KM_RES_VAR[[m]])){
save_ggplot_lst.svg(lst_plots = LST_KM_RES_VAR[[m]]$LST_PLOTS, object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
for(m in names(LST_KM_RES_LP)){
if(!all(is.na(LST_KM_RES_LP[[m]]))){
save_ggplot_lst.svg(lst_plots = LST_KM_RES_LP[[m]]$LST_PLOTS, object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
if(m %in% names(LST_KM_RES_COMP) && !all(is.na(LST_KM_RES_COMP[[m]]))){
save_ggplot_lst.svg(lst_plots = LST_KM_RES_COMP[[m]]$LST_PLOTS, object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
if(m %in% names(LST_KM_RES_VAR) && !all(is.na(LST_KM_RES_VAR[[m]]))){
save_ggplot_lst.svg(lst_plots = LST_KM_RES_VAR[[m]]$LST_PLOTS, object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
km_folder = paste0(folder, "km_test_plot/")
dir.create(km_folder)
lst_cutoff <- getCutoffAutoKM.list(LST_KM_RES_LP)
LST_KM_TEST_LP <- getTestKM.list(lst_models = lst_models,
X_test = X_test, Y_test = Y_test,
type = "LP",
BREAKTIME = NULL, n.breaks = 20, title = "Test Data",
lst_cutoff = lst_cutoff)
for(m in LST_KM_TEST_LP){
if(!is.na(LST_KM_TEST_LP[[m]])){
save_ggplot.svg(plot = LST_KM_TEST_LP[[m]], folder = km_folder, wide = T, name = paste0("km_test_", m))
}
if(m %in% names(LST_KM_TEST_COMP) && !is.na(LST_KM_TEST_COMP[[m]])){
save_ggplot_lst.svg(lst_plots = LST_KM_TEST_COMP[[m]], object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
if(m %in% names(LST_KM_TEST_VAR) && !is.na(LST_KM_TEST_VAR[[m]])){
save_ggplot_lst.svg(lst_plots = LST_KM_TEST_VAR[[m]], object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
for(m in LST_KM_TEST_LP){
if(!all(is.na(LST_KM_TEST_LP[[m]]))){
save_ggplot.svg(plot = LST_KM_TEST_LP[[m]], folder = km_folder, wide = T, name = paste0("km_test_", m))
}
if(m %in% names(LST_KM_TEST_COMP) && !all(is.na(LST_KM_TEST_COMP[[m]]))){
save_ggplot_lst.svg(lst_plots = LST_KM_TEST_COMP[[m]], object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
if(m %in% names(LST_KM_TEST_VAR) && !all(is.na(LST_KM_TEST_VAR[[m]]))){
save_ggplot_lst.svg(lst_plots = LST_KM_TEST_VAR[[m]], object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
m
for(m in names(LST_KM_TEST_LP)){
if(!all(is.na(LST_KM_TEST_LP[[m]]))){
save_ggplot.svg(plot = LST_KM_TEST_LP[[m]], folder = km_folder, wide = T, name = paste0("km_test_", m))
}
if(m %in% names(LST_KM_TEST_COMP) && !all(is.na(LST_KM_TEST_COMP[[m]]))){
save_ggplot_lst.svg(lst_plots = LST_KM_TEST_COMP[[m]], object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
if(m %in% names(LST_KM_TEST_VAR) && !all(is.na(LST_KM_TEST_VAR[[m]]))){
save_ggplot_lst.svg(lst_plots = LST_KM_TEST_VAR[[m]], object_name = NULL, folder = km_folder, wide = T, prefix = paste0("km_", m, "_"))
}
m
names(LST_KM_TEST_LP)
m = "sPLS-DRCOX-MixOmics"
if(!all(is.na(LST_KM_TEST_LP[[m]]))){
save_ggplot.svg(plot = LST_KM_TEST_LP[[m]], folder = km_folder, wide = T, name = paste0("km_test_", m))
}
km_folder
LST_KM_TEST_LP[[m]]
paste0("km_test_", m)
km_folder
devtools::load_all(".")
if(!all(is.na(LST_KM_TEST_LP[[m]]))){
save_ggplot.svg(plot = LST_KM_TEST_LP[[m]], folder = km_folder, wide = T, name = paste0("km_test_", m))
}
devtools::load_all(".")
remove.packages("HDcox")
library(devtools)
devtools::load_all(".")
check()
install()
