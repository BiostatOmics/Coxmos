% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HDcox_sb_splsdrcox.R
\name{fast.cv.sb.splsdrcox}
\alias{fast.cv.sb.splsdrcox}
\title{Cross validation fast.cv.sb.splsdrcox}
\usage{
fast.cv.sb.splsdrcox(
  X,
  Y,
  max.ncomp = 10,
  eta.list = seq(0.1, 0.9, 0.1),
  n_run = 10,
  k_folds = 10,
  x.center = TRUE,
  x.scale = FALSE,
  y.center = FALSE,
  y.scale = FALSE,
  remove_near_zero_variance = T,
  remove_zero_variance = T,
  toKeep.zv = NULL,
  remove_variance_at_fold_level = F,
  remove_non_significant_models = F,
  remove_non_significant = F,
  alpha = 0.05,
  w_AIC = 0,
  w_c.index = 0,
  w_AUC = 1,
  times = NULL,
  MIN_AUC_INCREASE = 0.01,
  MIN_AUC = 0.8,
  MIN_COMP_TO_CHECK = 3,
  pred.attr = "mean",
  pred.method = "cenROC",
  fast_mode = F,
  MIN_EPV = 5,
  returnData = T,
  return_models = F,
  tol = 1e-15,
  PARALLEL = F,
  verbose = F,
  seed = 123
)
}
\arguments{
\item{X}{Numeric matrix. Predictor variables}

\item{Y}{Numeric matrix. Response variables. It assumes it has two columns named as "time" and "event". For event column, values can be 0/1 or FALSE/TRUE for censored and event samples.}

\item{max.ncomp}{Numeric. Maximum number of PLS components to compute for the cross validation.}

\item{eta.list}{Numeric vector. Vector of penalty values.}

\item{n_run}{Number. Number of runs for cross validation.}

\item{k_folds}{Number. Number of folds for cross validation.}

\item{x.center}{Logical. If x.center = TRUE, X matrix is centered to zero means (default: TRUE).}

\item{x.scale}{Logical. If x.scale = TRUE, X matrix is scaled to unit variances (default: FALSE).}

\item{y.center}{Logical. If y.center = TRUE, Y matrix is centered to zero means (default: FALSE).}

\item{y.scale}{Logical. If y.scale = TRUE, Y matrix is scaled to unit variances (default: FALSE).}

\item{remove_near_zero_variance}{Logical. If remove_near_zero_variance = TRUE, remove_near_zero_variance variables will be removed.}

\item{remove_zero_variance}{Logical. If remove_zero_variance = TRUE, remove_zero_variance variables will be removed.}

\item{toKeep.zv}{Character vector. Name of variables in X to not be deleted by (near) zero variance filtering.}

\item{remove_variance_at_fold_level}{Logical. Remove variance at fold level (T) or before split the data (F-default).}

\item{remove_non_significant_models}{Logical. If remove_non_significant_models = TRUE, non-significant models are removed before computing the evaluation. A non-significant model is a model with at least one component/variable with a P-Value higher than the alpha cutoff. @param alpha Numeric. Cutoff for establish significant variables. Below the number are considered as significant (default: 0.05).}

\item{remove_non_significant}{Logical. If remove_non_significant = TRUE, non-significant variables in final cox model will be removed until all variables are significant (forward selection).}

\item{alpha}{Numeric. Cutoff for establish significant variables. Below the number are considered as significant (default: 0.05).}

\item{w_AIC}{Numeric. Weight for AIC evaluator. All three weights must sum 1 (default: 0).}

\item{w_c.index}{Numeric. Weight for C-Index evaluator. All three weights must sum 1 (default: 0).}

\item{w_AUC}{Numeric. Weight for AUC evaluator. All three weights must sum 1 (default: 1).}

\item{times}{Numeric vector. Time points where the AUC will be evaluated. If NULL, a maximum of 15 points will be selected equally distributed.}

\item{MIN_AUC_INCREASE}{Numeric. Minimum improvement between different EN.alpha.list to continue evaluating. If not reached for the next MIN_COMP_TO_CHECK penalties and the minimum MIN_AUC is reach, the evaluation stop.}

\item{MIN_AUC}{Numeric. Minimum AUC desire.}

\item{MIN_COMP_TO_CHECK}{Numeric. Number of penalties to check whether the AUC improves.}

\item{pred.attr}{Character. Method for average the AUC. Must be one of the following: "mean" or "median" (default: "mean").}

\item{pred.method}{Character. AUC method for evaluation. Must be one of the following: "risksetROC", "survivalROC", "cenROC", "nsROC", "smoothROCtime_C", "smoothROCtime_I" (default: "cenROC")}

\item{fast_mode}{Logical. If fast_mode = TRUE, for each run, only one fold is evaluated simultaneously. If fast_mode = FALSE, for each run, all linear predictors are computed for test observations. Once all have their linear predictors, the evaluation is perform across all the observations together (default: FALSE).}

\item{MIN_EPV}{Minimum number of Events Per Variable you want reach for the final cox model. Used to restrict the number of variables can appear in cox model. If the minimum is not meet, the model is not computed.}

\item{returnData}{Logical. Return original and normalized X and Y matrices.}

\item{return_models}{Logical. Return all models computed in cross validation.}

\item{tol}{Numeric. Tolerance for solving: solve(t(P) \%*\% W)}

\item{PARALLEL}{Logical. Run the cross validation with multicore option. As many cores as your total cores - 1 will be used. It could lead to higher RAM consumption.}

\item{verbose}{Logical. If verbose = TRUE, extra messages could be displayed (default: FALSE).}

\item{seed}{Number. Seed value for perform the runs/folds divisions.}
}
\value{
Instance of class "HDcox" and model "SB.sPLS-DRCOX".
}
\description{
fast.cv.sb.splsdrcox cross validation model
}
